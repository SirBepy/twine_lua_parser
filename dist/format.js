window.storyFormat({
  "name": "Twine to Lua parser",
  "version": "0.0.34",
  "author": "SirBepy",
  "description": "Export your Twine 2 story as a lua file (RobloxStudio)",
  "proofing": false,
  "source": "<html>\r\n\r\n<head>\r\n  <title>{{STORY_NAME}}</title>\r\n  <script type=\"text/javascript\">\r\n    (function () {\n\t'use strict';\n\n\tfunction getAugmentedNamespace(n) {\n\t  if (n.__esModule) return n;\n\t  var f = n.default;\n\t\tif (typeof f == \"function\") {\n\t\t\tvar a = function a () {\n\t\t\t\tif (this instanceof a) {\n\t        return Reflect.construct(f, arguments, this.constructor);\n\t\t\t\t}\n\t\t\t\treturn f.apply(this, arguments);\n\t\t\t};\n\t\t\ta.prototype = f.prototype;\n\t  } else a = {};\n\t  Object.defineProperty(a, '__esModule', {value: true});\n\t\tObject.keys(n).forEach(function (k) {\n\t\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn n[k];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn a;\n\t}\n\n\tvar xml2js = {};\n\n\tvar defaults = {};\n\n\tvar hasRequiredDefaults;\n\n\tfunction requireDefaults () {\n\t\tif (hasRequiredDefaults) return defaults;\n\t\thasRequiredDefaults = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  defaults.defaults = {\n\t\t    \"0.1\": {\n\t\t      explicitCharkey: false,\n\t\t      trim: true,\n\t\t      normalize: true,\n\t\t      normalizeTags: false,\n\t\t      attrkey: \"@\",\n\t\t      charkey: \"#\",\n\t\t      explicitArray: false,\n\t\t      ignoreAttrs: false,\n\t\t      mergeAttrs: false,\n\t\t      explicitRoot: false,\n\t\t      validator: null,\n\t\t      xmlns: false,\n\t\t      explicitChildren: false,\n\t\t      childkey: '@@',\n\t\t      charsAsChildren: false,\n\t\t      includeWhiteChars: false,\n\t\t      async: false,\n\t\t      strict: true,\n\t\t      attrNameProcessors: null,\n\t\t      attrValueProcessors: null,\n\t\t      tagNameProcessors: null,\n\t\t      valueProcessors: null,\n\t\t      emptyTag: ''\n\t\t    },\n\t\t    \"0.2\": {\n\t\t      explicitCharkey: false,\n\t\t      trim: false,\n\t\t      normalize: false,\n\t\t      normalizeTags: false,\n\t\t      attrkey: \"$\",\n\t\t      charkey: \"_\",\n\t\t      explicitArray: true,\n\t\t      ignoreAttrs: false,\n\t\t      mergeAttrs: false,\n\t\t      explicitRoot: true,\n\t\t      validator: null,\n\t\t      xmlns: false,\n\t\t      explicitChildren: false,\n\t\t      preserveChildrenOrder: false,\n\t\t      childkey: '$',\n\t\t      charsAsChildren: false,\n\t\t      includeWhiteChars: false,\n\t\t      async: false,\n\t\t      strict: true,\n\t\t      attrNameProcessors: null,\n\t\t      attrValueProcessors: null,\n\t\t      tagNameProcessors: null,\n\t\t      valueProcessors: null,\n\t\t      rootName: 'root',\n\t\t      xmldec: {\n\t\t        'version': '1.0',\n\t\t        'encoding': 'UTF-8',\n\t\t        'standalone': true\n\t\t      },\n\t\t      doctype: null,\n\t\t      renderOpts: {\n\t\t        'pretty': true,\n\t\t        'indent': '  ',\n\t\t        'newline': '\\n'\n\t\t      },\n\t\t      headless: false,\n\t\t      chunkSize: 10000,\n\t\t      emptyTag: '',\n\t\t      cdata: false\n\t\t    }\n\t\t  };\n\n\t\t}).call(defaults);\n\t\treturn defaults;\n\t}\n\n\tvar builder = {};\n\n\tvar lib = {};\n\n\tvar Utility = {};\n\n\tvar hasRequiredUtility;\n\n\tfunction requireUtility () {\n\t\tif (hasRequiredUtility) return Utility;\n\t\thasRequiredUtility = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject,\n\t\t    slice = [].slice,\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  assign = function() {\n\t\t    var i, key, len, source, sources, target;\n\t\t    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\t\t    if (isFunction(Object.assign)) {\n\t\t      Object.assign.apply(null, arguments);\n\t\t    } else {\n\t\t      for (i = 0, len = sources.length; i < len; i++) {\n\t\t        source = sources[i];\n\t\t        if (source != null) {\n\t\t          for (key in source) {\n\t\t            if (!hasProp.call(source, key)) continue;\n\t\t            target[key] = source[key];\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    return target;\n\t\t  };\n\n\t\t  isFunction = function(val) {\n\t\t    return !!val && Object.prototype.toString.call(val) === '[object Function]';\n\t\t  };\n\n\t\t  isObject = function(val) {\n\t\t    var ref;\n\t\t    return !!val && ((ref = typeof val) === 'function' || ref === 'object');\n\t\t  };\n\n\t\t  isArray = function(val) {\n\t\t    if (isFunction(Array.isArray)) {\n\t\t      return Array.isArray(val);\n\t\t    } else {\n\t\t      return Object.prototype.toString.call(val) === '[object Array]';\n\t\t    }\n\t\t  };\n\n\t\t  isEmpty = function(val) {\n\t\t    var key;\n\t\t    if (isArray(val)) {\n\t\t      return !val.length;\n\t\t    } else {\n\t\t      for (key in val) {\n\t\t        if (!hasProp.call(val, key)) continue;\n\t\t        return false;\n\t\t      }\n\t\t      return true;\n\t\t    }\n\t\t  };\n\n\t\t  isPlainObject = function(val) {\n\t\t    var ctor, proto;\n\t\t    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));\n\t\t  };\n\n\t\t  getValue = function(obj) {\n\t\t    if (isFunction(obj.valueOf)) {\n\t\t      return obj.valueOf();\n\t\t    } else {\n\t\t      return obj;\n\t\t    }\n\t\t  };\n\n\t\t  Utility.assign = assign;\n\n\t\t  Utility.isFunction = isFunction;\n\n\t\t  Utility.isObject = isObject;\n\n\t\t  Utility.isArray = isArray;\n\n\t\t  Utility.isEmpty = isEmpty;\n\n\t\t  Utility.isPlainObject = isPlainObject;\n\n\t\t  Utility.getValue = getValue;\n\n\t\t}).call(Utility);\n\t\treturn Utility;\n\t}\n\n\tvar XMLDOMImplementation$1 = {exports: {}};\n\n\tvar XMLDOMImplementation = XMLDOMImplementation$1.exports;\n\n\tvar hasRequiredXMLDOMImplementation;\n\n\tfunction requireXMLDOMImplementation () {\n\t\tif (hasRequiredXMLDOMImplementation) return XMLDOMImplementation$1.exports;\n\t\thasRequiredXMLDOMImplementation = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\n\t\t  XMLDOMImplementation$1.exports = (function() {\n\t\t    function XMLDOMImplementation() {}\n\n\t\t    XMLDOMImplementation.prototype.hasFeature = function(feature, version) {\n\t\t      return true;\n\t\t    };\n\n\t\t    XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {\n\t\t      throw new Error(\"This DOM method is not implemented.\");\n\t\t    };\n\n\t\t    XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {\n\t\t      throw new Error(\"This DOM method is not implemented.\");\n\t\t    };\n\n\t\t    XMLDOMImplementation.prototype.createHTMLDocument = function(title) {\n\t\t      throw new Error(\"This DOM method is not implemented.\");\n\t\t    };\n\n\t\t    XMLDOMImplementation.prototype.getFeature = function(feature, version) {\n\t\t      throw new Error(\"This DOM method is not implemented.\");\n\t\t    };\n\n\t\t    return XMLDOMImplementation;\n\n\t\t  })();\n\n\t\t}).call(XMLDOMImplementation);\n\t\treturn XMLDOMImplementation$1.exports;\n\t}\n\n\tvar XMLDocument$1 = {exports: {}};\n\n\tvar XMLDOMConfiguration$1 = {exports: {}};\n\n\tvar XMLDOMErrorHandler$1 = {exports: {}};\n\n\tvar XMLDOMErrorHandler = XMLDOMErrorHandler$1.exports;\n\n\tvar hasRequiredXMLDOMErrorHandler;\n\n\tfunction requireXMLDOMErrorHandler () {\n\t\tif (hasRequiredXMLDOMErrorHandler) return XMLDOMErrorHandler$1.exports;\n\t\thasRequiredXMLDOMErrorHandler = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\n\t\t  XMLDOMErrorHandler$1.exports = (function() {\n\t\t    function XMLDOMErrorHandler() {}\n\n\t\t    XMLDOMErrorHandler.prototype.handleError = function(error) {\n\t\t      throw new Error(error);\n\t\t    };\n\n\t\t    return XMLDOMErrorHandler;\n\n\t\t  })();\n\n\t\t}).call(XMLDOMErrorHandler);\n\t\treturn XMLDOMErrorHandler$1.exports;\n\t}\n\n\tvar XMLDOMStringList$1 = {exports: {}};\n\n\tvar XMLDOMStringList = XMLDOMStringList$1.exports;\n\n\tvar hasRequiredXMLDOMStringList;\n\n\tfunction requireXMLDOMStringList () {\n\t\tif (hasRequiredXMLDOMStringList) return XMLDOMStringList$1.exports;\n\t\thasRequiredXMLDOMStringList = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\n\t\t  XMLDOMStringList$1.exports = (function() {\n\t\t    function XMLDOMStringList(arr) {\n\t\t      this.arr = arr || [];\n\t\t    }\n\n\t\t    Object.defineProperty(XMLDOMStringList.prototype, 'length', {\n\t\t      get: function() {\n\t\t        return this.arr.length;\n\t\t      }\n\t\t    });\n\n\t\t    XMLDOMStringList.prototype.item = function(index) {\n\t\t      return this.arr[index] || null;\n\t\t    };\n\n\t\t    XMLDOMStringList.prototype.contains = function(str) {\n\t\t      return this.arr.indexOf(str) !== -1;\n\t\t    };\n\n\t\t    return XMLDOMStringList;\n\n\t\t  })();\n\n\t\t}).call(XMLDOMStringList);\n\t\treturn XMLDOMStringList$1.exports;\n\t}\n\n\tvar XMLDOMConfiguration = XMLDOMConfiguration$1.exports;\n\n\tvar hasRequiredXMLDOMConfiguration;\n\n\tfunction requireXMLDOMConfiguration () {\n\t\tif (hasRequiredXMLDOMConfiguration) return XMLDOMConfiguration$1.exports;\n\t\thasRequiredXMLDOMConfiguration = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var XMLDOMErrorHandler, XMLDOMStringList;\n\n\t\t  XMLDOMErrorHandler = requireXMLDOMErrorHandler();\n\n\t\t  XMLDOMStringList = requireXMLDOMStringList();\n\n\t\t  XMLDOMConfiguration$1.exports = (function() {\n\t\t    function XMLDOMConfiguration() {\n\t\t      this.defaultParams = {\n\t\t        \"canonical-form\": false,\n\t\t        \"cdata-sections\": false,\n\t\t        \"comments\": false,\n\t\t        \"datatype-normalization\": false,\n\t\t        \"element-content-whitespace\": true,\n\t\t        \"entities\": true,\n\t\t        \"error-handler\": new XMLDOMErrorHandler(),\n\t\t        \"infoset\": true,\n\t\t        \"validate-if-schema\": false,\n\t\t        \"namespaces\": true,\n\t\t        \"namespace-declarations\": true,\n\t\t        \"normalize-characters\": false,\n\t\t        \"schema-location\": '',\n\t\t        \"schema-type\": '',\n\t\t        \"split-cdata-sections\": true,\n\t\t        \"validate\": false,\n\t\t        \"well-formed\": true\n\t\t      };\n\t\t      this.params = Object.create(this.defaultParams);\n\t\t    }\n\n\t\t    Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {\n\t\t      get: function() {\n\t\t        return new XMLDOMStringList(Object.keys(this.defaultParams));\n\t\t      }\n\t\t    });\n\n\t\t    XMLDOMConfiguration.prototype.getParameter = function(name) {\n\t\t      if (this.params.hasOwnProperty(name)) {\n\t\t        return this.params[name];\n\t\t      } else {\n\t\t        return null;\n\t\t      }\n\t\t    };\n\n\t\t    XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {\n\t\t      return true;\n\t\t    };\n\n\t\t    XMLDOMConfiguration.prototype.setParameter = function(name, value) {\n\t\t      if (value != null) {\n\t\t        return this.params[name] = value;\n\t\t      } else {\n\t\t        return delete this.params[name];\n\t\t      }\n\t\t    };\n\n\t\t    return XMLDOMConfiguration;\n\n\t\t  })();\n\n\t\t}).call(XMLDOMConfiguration);\n\t\treturn XMLDOMConfiguration$1.exports;\n\t}\n\n\tvar XMLNode$1 = {exports: {}};\n\n\tvar XMLElement$1 = {exports: {}};\n\n\tvar NodeType$1 = {exports: {}};\n\n\tvar NodeType = NodeType$1.exports;\n\n\tvar hasRequiredNodeType;\n\n\tfunction requireNodeType () {\n\t\tif (hasRequiredNodeType) return NodeType$1.exports;\n\t\thasRequiredNodeType = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  NodeType$1.exports = {\n\t\t    Element: 1,\n\t\t    Attribute: 2,\n\t\t    Text: 3,\n\t\t    CData: 4,\n\t\t    EntityReference: 5,\n\t\t    EntityDeclaration: 6,\n\t\t    ProcessingInstruction: 7,\n\t\t    Comment: 8,\n\t\t    Document: 9,\n\t\t    DocType: 10,\n\t\t    DocumentFragment: 11,\n\t\t    NotationDeclaration: 12,\n\t\t    Declaration: 201,\n\t\t    Raw: 202,\n\t\t    AttributeDeclaration: 203,\n\t\t    ElementDeclaration: 204,\n\t\t    Dummy: 205\n\t\t  };\n\n\t\t}).call(NodeType);\n\t\treturn NodeType$1.exports;\n\t}\n\n\tvar XMLAttribute$1 = {exports: {}};\n\n\tvar XMLAttribute = XMLAttribute$1.exports;\n\n\tvar hasRequiredXMLAttribute;\n\n\tfunction requireXMLAttribute () {\n\t\tif (hasRequiredXMLAttribute) return XMLAttribute$1.exports;\n\t\thasRequiredXMLAttribute = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType;\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  requireXMLNode();\n\n\t\t  XMLAttribute$1.exports = (function() {\n\t\t    function XMLAttribute(parent, name, value) {\n\t\t      this.parent = parent;\n\t\t      if (this.parent) {\n\t\t        this.options = this.parent.options;\n\t\t        this.stringify = this.parent.stringify;\n\t\t      }\n\t\t      if (name == null) {\n\t\t        throw new Error(\"Missing attribute name. \" + this.debugInfo(name));\n\t\t      }\n\t\t      this.name = this.stringify.name(name);\n\t\t      this.value = this.stringify.attValue(value);\n\t\t      this.type = NodeType.Attribute;\n\t\t      this.isId = false;\n\t\t      this.schemaTypeInfo = null;\n\t\t    }\n\n\t\t    Object.defineProperty(XMLAttribute.prototype, 'nodeType', {\n\t\t      get: function() {\n\t\t        return this.type;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {\n\t\t      get: function() {\n\t\t        return this.parent;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLAttribute.prototype, 'textContent', {\n\t\t      get: function() {\n\t\t        return this.value;\n\t\t      },\n\t\t      set: function(value) {\n\t\t        return this.value = value || '';\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {\n\t\t      get: function() {\n\t\t        return '';\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLAttribute.prototype, 'prefix', {\n\t\t      get: function() {\n\t\t        return '';\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLAttribute.prototype, 'localName', {\n\t\t      get: function() {\n\t\t        return this.name;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLAttribute.prototype, 'specified', {\n\t\t      get: function() {\n\t\t        return true;\n\t\t      }\n\t\t    });\n\n\t\t    XMLAttribute.prototype.clone = function() {\n\t\t      return Object.create(this);\n\t\t    };\n\n\t\t    XMLAttribute.prototype.toString = function(options) {\n\t\t      return this.options.writer.attribute(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    XMLAttribute.prototype.debugInfo = function(name) {\n\t\t      name = name || this.name;\n\t\t      if (name == null) {\n\t\t        return \"parent: <\" + this.parent.name + \">\";\n\t\t      } else {\n\t\t        return \"attribute: {\" + name + \"}, parent: <\" + this.parent.name + \">\";\n\t\t      }\n\t\t    };\n\n\t\t    XMLAttribute.prototype.isEqualNode = function(node) {\n\t\t      if (node.namespaceURI !== this.namespaceURI) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.prefix !== this.prefix) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.localName !== this.localName) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.value !== this.value) {\n\t\t        return false;\n\t\t      }\n\t\t      return true;\n\t\t    };\n\n\t\t    return XMLAttribute;\n\n\t\t  })();\n\n\t\t}).call(XMLAttribute);\n\t\treturn XMLAttribute$1.exports;\n\t}\n\n\tvar XMLNamedNodeMap$1 = {exports: {}};\n\n\tvar XMLNamedNodeMap = XMLNamedNodeMap$1.exports;\n\n\tvar hasRequiredXMLNamedNodeMap;\n\n\tfunction requireXMLNamedNodeMap () {\n\t\tif (hasRequiredXMLNamedNodeMap) return XMLNamedNodeMap$1.exports;\n\t\thasRequiredXMLNamedNodeMap = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\n\t\t  XMLNamedNodeMap$1.exports = (function() {\n\t\t    function XMLNamedNodeMap(nodes) {\n\t\t      this.nodes = nodes;\n\t\t    }\n\n\t\t    Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {\n\t\t      get: function() {\n\t\t        return Object.keys(this.nodes).length || 0;\n\t\t      }\n\t\t    });\n\n\t\t    XMLNamedNodeMap.prototype.clone = function() {\n\t\t      return this.nodes = null;\n\t\t    };\n\n\t\t    XMLNamedNodeMap.prototype.getNamedItem = function(name) {\n\t\t      return this.nodes[name];\n\t\t    };\n\n\t\t    XMLNamedNodeMap.prototype.setNamedItem = function(node) {\n\t\t      var oldNode;\n\t\t      oldNode = this.nodes[node.nodeName];\n\t\t      this.nodes[node.nodeName] = node;\n\t\t      return oldNode || null;\n\t\t    };\n\n\t\t    XMLNamedNodeMap.prototype.removeNamedItem = function(name) {\n\t\t      var oldNode;\n\t\t      oldNode = this.nodes[name];\n\t\t      delete this.nodes[name];\n\t\t      return oldNode || null;\n\t\t    };\n\n\t\t    XMLNamedNodeMap.prototype.item = function(index) {\n\t\t      return this.nodes[Object.keys(this.nodes)[index]] || null;\n\t\t    };\n\n\t\t    XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\");\n\t\t    };\n\n\t\t    XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {\n\t\t      throw new Error(\"This DOM method is not implemented.\");\n\t\t    };\n\n\t\t    XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\");\n\t\t    };\n\n\t\t    return XMLNamedNodeMap;\n\n\t\t  })();\n\n\t\t}).call(XMLNamedNodeMap);\n\t\treturn XMLNamedNodeMap$1.exports;\n\t}\n\n\tvar XMLElement = XMLElement$1.exports;\n\n\tvar hasRequiredXMLElement;\n\n\tfunction requireXMLElement () {\n\t\tif (hasRequiredXMLElement) return XMLElement$1.exports;\n\t\thasRequiredXMLElement = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLAttribute, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  ref = requireUtility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLAttribute = requireXMLAttribute();\n\n\t\t  XMLNamedNodeMap = requireXMLNamedNodeMap();\n\n\t\t  XMLElement$1.exports = (function(superClass) {\n\t\t    extend(XMLElement, superClass);\n\n\t\t    function XMLElement(parent, name, attributes) {\n\t\t      var child, j, len, ref1;\n\t\t      XMLElement.__super__.constructor.call(this, parent);\n\t\t      if (name == null) {\n\t\t        throw new Error(\"Missing element name. \" + this.debugInfo());\n\t\t      }\n\t\t      this.name = this.stringify.name(name);\n\t\t      this.type = NodeType.Element;\n\t\t      this.attribs = {};\n\t\t      this.schemaTypeInfo = null;\n\t\t      if (attributes != null) {\n\t\t        this.attribute(attributes);\n\t\t      }\n\t\t      if (parent.type === NodeType.Document) {\n\t\t        this.isRoot = true;\n\t\t        this.documentObject = parent;\n\t\t        parent.rootObject = this;\n\t\t        if (parent.children) {\n\t\t          ref1 = parent.children;\n\t\t          for (j = 0, len = ref1.length; j < len; j++) {\n\t\t            child = ref1[j];\n\t\t            if (child.type === NodeType.DocType) {\n\t\t              child.name = this.name;\n\t\t              break;\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\n\t\t    Object.defineProperty(XMLElement.prototype, 'tagName', {\n\t\t      get: function() {\n\t\t        return this.name;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLElement.prototype, 'namespaceURI', {\n\t\t      get: function() {\n\t\t        return '';\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLElement.prototype, 'prefix', {\n\t\t      get: function() {\n\t\t        return '';\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLElement.prototype, 'localName', {\n\t\t      get: function() {\n\t\t        return this.name;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLElement.prototype, 'id', {\n\t\t      get: function() {\n\t\t        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLElement.prototype, 'className', {\n\t\t      get: function() {\n\t\t        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLElement.prototype, 'classList', {\n\t\t      get: function() {\n\t\t        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLElement.prototype, 'attributes', {\n\t\t      get: function() {\n\t\t        if (!this.attributeMap || !this.attributeMap.nodes) {\n\t\t          this.attributeMap = new XMLNamedNodeMap(this.attribs);\n\t\t        }\n\t\t        return this.attributeMap;\n\t\t      }\n\t\t    });\n\n\t\t    XMLElement.prototype.clone = function() {\n\t\t      var att, attName, clonedSelf, ref1;\n\t\t      clonedSelf = Object.create(this);\n\t\t      if (clonedSelf.isRoot) {\n\t\t        clonedSelf.documentObject = null;\n\t\t      }\n\t\t      clonedSelf.attribs = {};\n\t\t      ref1 = this.attribs;\n\t\t      for (attName in ref1) {\n\t\t        if (!hasProp.call(ref1, attName)) continue;\n\t\t        att = ref1[attName];\n\t\t        clonedSelf.attribs[attName] = att.clone();\n\t\t      }\n\t\t      clonedSelf.children = [];\n\t\t      this.children.forEach(function(child) {\n\t\t        var clonedChild;\n\t\t        clonedChild = child.clone();\n\t\t        clonedChild.parent = clonedSelf;\n\t\t        return clonedSelf.children.push(clonedChild);\n\t\t      });\n\t\t      return clonedSelf;\n\t\t    };\n\n\t\t    XMLElement.prototype.attribute = function(name, value) {\n\t\t      var attName, attValue;\n\t\t      if (name != null) {\n\t\t        name = getValue(name);\n\t\t      }\n\t\t      if (isObject(name)) {\n\t\t        for (attName in name) {\n\t\t          if (!hasProp.call(name, attName)) continue;\n\t\t          attValue = name[attName];\n\t\t          this.attribute(attName, attValue);\n\t\t        }\n\t\t      } else {\n\t\t        if (isFunction(value)) {\n\t\t          value = value.apply();\n\t\t        }\n\t\t        if (this.options.keepNullAttributes && (value == null)) {\n\t\t          this.attribs[name] = new XMLAttribute(this, name, \"\");\n\t\t        } else if (value != null) {\n\t\t          this.attribs[name] = new XMLAttribute(this, name, value);\n\t\t        }\n\t\t      }\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLElement.prototype.removeAttribute = function(name) {\n\t\t      var attName, j, len;\n\t\t      if (name == null) {\n\t\t        throw new Error(\"Missing attribute name. \" + this.debugInfo());\n\t\t      }\n\t\t      name = getValue(name);\n\t\t      if (Array.isArray(name)) {\n\t\t        for (j = 0, len = name.length; j < len; j++) {\n\t\t          attName = name[j];\n\t\t          delete this.attribs[attName];\n\t\t        }\n\t\t      } else {\n\t\t        delete this.attribs[name];\n\t\t      }\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLElement.prototype.toString = function(options) {\n\t\t      return this.options.writer.element(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    XMLElement.prototype.att = function(name, value) {\n\t\t      return this.attribute(name, value);\n\t\t    };\n\n\t\t    XMLElement.prototype.a = function(name, value) {\n\t\t      return this.attribute(name, value);\n\t\t    };\n\n\t\t    XMLElement.prototype.getAttribute = function(name) {\n\t\t      if (this.attribs.hasOwnProperty(name)) {\n\t\t        return this.attribs[name].value;\n\t\t      } else {\n\t\t        return null;\n\t\t      }\n\t\t    };\n\n\t\t    XMLElement.prototype.setAttribute = function(name, value) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.getAttributeNode = function(name) {\n\t\t      if (this.attribs.hasOwnProperty(name)) {\n\t\t        return this.attribs[name];\n\t\t      } else {\n\t\t        return null;\n\t\t      }\n\t\t    };\n\n\t\t    XMLElement.prototype.setAttributeNode = function(newAttr) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.removeAttributeNode = function(oldAttr) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.getElementsByTagName = function(name) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.setAttributeNodeNS = function(newAttr) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.hasAttribute = function(name) {\n\t\t      return this.attribs.hasOwnProperty(name);\n\t\t    };\n\n\t\t    XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.setIdAttribute = function(name, isId) {\n\t\t      if (this.attribs.hasOwnProperty(name)) {\n\t\t        return this.attribs[name].isId;\n\t\t      } else {\n\t\t        return isId;\n\t\t      }\n\t\t    };\n\n\t\t    XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.getElementsByTagName = function(tagname) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.getElementsByClassName = function(classNames) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLElement.prototype.isEqualNode = function(node) {\n\t\t      var i, j, ref1;\n\t\t      if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.namespaceURI !== this.namespaceURI) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.prefix !== this.prefix) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.localName !== this.localName) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.attribs.length !== this.attribs.length) {\n\t\t        return false;\n\t\t      }\n\t\t      for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n\t\t        if (!this.attribs[i].isEqualNode(node.attribs[i])) {\n\t\t          return false;\n\t\t        }\n\t\t      }\n\t\t      return true;\n\t\t    };\n\n\t\t    return XMLElement;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLElement);\n\t\treturn XMLElement$1.exports;\n\t}\n\n\tvar XMLCData$1 = {exports: {}};\n\n\tvar XMLCharacterData$1 = {exports: {}};\n\n\tvar XMLCharacterData = XMLCharacterData$1.exports;\n\n\tvar hasRequiredXMLCharacterData;\n\n\tfunction requireXMLCharacterData () {\n\t\tif (hasRequiredXMLCharacterData) return XMLCharacterData$1.exports;\n\t\thasRequiredXMLCharacterData = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var XMLNode,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  XMLCharacterData$1.exports = (function(superClass) {\n\t\t    extend(XMLCharacterData, superClass);\n\n\t\t    function XMLCharacterData(parent) {\n\t\t      XMLCharacterData.__super__.constructor.call(this, parent);\n\t\t      this.value = '';\n\t\t    }\n\n\t\t    Object.defineProperty(XMLCharacterData.prototype, 'data', {\n\t\t      get: function() {\n\t\t        return this.value;\n\t\t      },\n\t\t      set: function(value) {\n\t\t        return this.value = value || '';\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLCharacterData.prototype, 'length', {\n\t\t      get: function() {\n\t\t        return this.value.length;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLCharacterData.prototype, 'textContent', {\n\t\t      get: function() {\n\t\t        return this.value;\n\t\t      },\n\t\t      set: function(value) {\n\t\t        return this.value = value || '';\n\t\t      }\n\t\t    });\n\n\t\t    XMLCharacterData.prototype.clone = function() {\n\t\t      return Object.create(this);\n\t\t    };\n\n\t\t    XMLCharacterData.prototype.substringData = function(offset, count) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLCharacterData.prototype.appendData = function(arg) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLCharacterData.prototype.insertData = function(offset, arg) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLCharacterData.prototype.deleteData = function(offset, count) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLCharacterData.prototype.replaceData = function(offset, count, arg) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLCharacterData.prototype.isEqualNode = function(node) {\n\t\t      if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.data !== this.data) {\n\t\t        return false;\n\t\t      }\n\t\t      return true;\n\t\t    };\n\n\t\t    return XMLCharacterData;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLCharacterData);\n\t\treturn XMLCharacterData$1.exports;\n\t}\n\n\tvar XMLCData = XMLCData$1.exports;\n\n\tvar hasRequiredXMLCData;\n\n\tfunction requireXMLCData () {\n\t\tif (hasRequiredXMLCData) return XMLCData$1.exports;\n\t\thasRequiredXMLCData = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLCharacterData,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLCharacterData = requireXMLCharacterData();\n\n\t\t  XMLCData$1.exports = (function(superClass) {\n\t\t    extend(XMLCData, superClass);\n\n\t\t    function XMLCData(parent, text) {\n\t\t      XMLCData.__super__.constructor.call(this, parent);\n\t\t      if (text == null) {\n\t\t        throw new Error(\"Missing CDATA text. \" + this.debugInfo());\n\t\t      }\n\t\t      this.name = \"#cdata-section\";\n\t\t      this.type = NodeType.CData;\n\t\t      this.value = this.stringify.cdata(text);\n\t\t    }\n\n\t\t    XMLCData.prototype.clone = function() {\n\t\t      return Object.create(this);\n\t\t    };\n\n\t\t    XMLCData.prototype.toString = function(options) {\n\t\t      return this.options.writer.cdata(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    return XMLCData;\n\n\t\t  })(XMLCharacterData);\n\n\t\t}).call(XMLCData);\n\t\treturn XMLCData$1.exports;\n\t}\n\n\tvar XMLComment$1 = {exports: {}};\n\n\tvar XMLComment = XMLComment$1.exports;\n\n\tvar hasRequiredXMLComment;\n\n\tfunction requireXMLComment () {\n\t\tif (hasRequiredXMLComment) return XMLComment$1.exports;\n\t\thasRequiredXMLComment = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLCharacterData, extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLCharacterData = requireXMLCharacterData();\n\n\t\t  XMLComment$1.exports = (function(superClass) {\n\t\t    extend(XMLComment, superClass);\n\n\t\t    function XMLComment(parent, text) {\n\t\t      XMLComment.__super__.constructor.call(this, parent);\n\t\t      if (text == null) {\n\t\t        throw new Error(\"Missing comment text. \" + this.debugInfo());\n\t\t      }\n\t\t      this.name = \"#comment\";\n\t\t      this.type = NodeType.Comment;\n\t\t      this.value = this.stringify.comment(text);\n\t\t    }\n\n\t\t    XMLComment.prototype.clone = function() {\n\t\t      return Object.create(this);\n\t\t    };\n\n\t\t    XMLComment.prototype.toString = function(options) {\n\t\t      return this.options.writer.comment(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    return XMLComment;\n\n\t\t  })(XMLCharacterData);\n\n\t\t}).call(XMLComment);\n\t\treturn XMLComment$1.exports;\n\t}\n\n\tvar XMLDeclaration$1 = {exports: {}};\n\n\tvar XMLDeclaration = XMLDeclaration$1.exports;\n\n\tvar hasRequiredXMLDeclaration;\n\n\tfunction requireXMLDeclaration () {\n\t\tif (hasRequiredXMLDeclaration) return XMLDeclaration$1.exports;\n\t\thasRequiredXMLDeclaration = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLNode, isObject,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  isObject = requireUtility().isObject;\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLDeclaration$1.exports = (function(superClass) {\n\t\t    extend(XMLDeclaration, superClass);\n\n\t\t    function XMLDeclaration(parent, version, encoding, standalone) {\n\t\t      var ref;\n\t\t      XMLDeclaration.__super__.constructor.call(this, parent);\n\t\t      if (isObject(version)) {\n\t\t        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;\n\t\t      }\n\t\t      if (!version) {\n\t\t        version = '1.0';\n\t\t      }\n\t\t      this.type = NodeType.Declaration;\n\t\t      this.version = this.stringify.xmlVersion(version);\n\t\t      if (encoding != null) {\n\t\t        this.encoding = this.stringify.xmlEncoding(encoding);\n\t\t      }\n\t\t      if (standalone != null) {\n\t\t        this.standalone = this.stringify.xmlStandalone(standalone);\n\t\t      }\n\t\t    }\n\n\t\t    XMLDeclaration.prototype.toString = function(options) {\n\t\t      return this.options.writer.declaration(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    return XMLDeclaration;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLDeclaration);\n\t\treturn XMLDeclaration$1.exports;\n\t}\n\n\tvar XMLDocType$1 = {exports: {}};\n\n\tvar XMLDTDAttList$1 = {exports: {}};\n\n\tvar XMLDTDAttList = XMLDTDAttList$1.exports;\n\n\tvar hasRequiredXMLDTDAttList;\n\n\tfunction requireXMLDTDAttList () {\n\t\tif (hasRequiredXMLDTDAttList) return XMLDTDAttList$1.exports;\n\t\thasRequiredXMLDTDAttList = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLNode,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLDTDAttList$1.exports = (function(superClass) {\n\t\t    extend(XMLDTDAttList, superClass);\n\n\t\t    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n\t\t      XMLDTDAttList.__super__.constructor.call(this, parent);\n\t\t      if (elementName == null) {\n\t\t        throw new Error(\"Missing DTD element name. \" + this.debugInfo());\n\t\t      }\n\t\t      if (attributeName == null) {\n\t\t        throw new Error(\"Missing DTD attribute name. \" + this.debugInfo(elementName));\n\t\t      }\n\t\t      if (!attributeType) {\n\t\t        throw new Error(\"Missing DTD attribute type. \" + this.debugInfo(elementName));\n\t\t      }\n\t\t      if (!defaultValueType) {\n\t\t        throw new Error(\"Missing DTD attribute default. \" + this.debugInfo(elementName));\n\t\t      }\n\t\t      if (defaultValueType.indexOf('#') !== 0) {\n\t\t        defaultValueType = '#' + defaultValueType;\n\t\t      }\n\t\t      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {\n\t\t        throw new Error(\"Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. \" + this.debugInfo(elementName));\n\t\t      }\n\t\t      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {\n\t\t        throw new Error(\"Default value only applies to #FIXED or #DEFAULT. \" + this.debugInfo(elementName));\n\t\t      }\n\t\t      this.elementName = this.stringify.name(elementName);\n\t\t      this.type = NodeType.AttributeDeclaration;\n\t\t      this.attributeName = this.stringify.name(attributeName);\n\t\t      this.attributeType = this.stringify.dtdAttType(attributeType);\n\t\t      if (defaultValue) {\n\t\t        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);\n\t\t      }\n\t\t      this.defaultValueType = defaultValueType;\n\t\t    }\n\n\t\t    XMLDTDAttList.prototype.toString = function(options) {\n\t\t      return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    return XMLDTDAttList;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLDTDAttList);\n\t\treturn XMLDTDAttList$1.exports;\n\t}\n\n\tvar XMLDTDEntity$1 = {exports: {}};\n\n\tvar XMLDTDEntity = XMLDTDEntity$1.exports;\n\n\tvar hasRequiredXMLDTDEntity;\n\n\tfunction requireXMLDTDEntity () {\n\t\tif (hasRequiredXMLDTDEntity) return XMLDTDEntity$1.exports;\n\t\thasRequiredXMLDTDEntity = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLNode, isObject,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  isObject = requireUtility().isObject;\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLDTDEntity$1.exports = (function(superClass) {\n\t\t    extend(XMLDTDEntity, superClass);\n\n\t\t    function XMLDTDEntity(parent, pe, name, value) {\n\t\t      XMLDTDEntity.__super__.constructor.call(this, parent);\n\t\t      if (name == null) {\n\t\t        throw new Error(\"Missing DTD entity name. \" + this.debugInfo(name));\n\t\t      }\n\t\t      if (value == null) {\n\t\t        throw new Error(\"Missing DTD entity value. \" + this.debugInfo(name));\n\t\t      }\n\t\t      this.pe = !!pe;\n\t\t      this.name = this.stringify.name(name);\n\t\t      this.type = NodeType.EntityDeclaration;\n\t\t      if (!isObject(value)) {\n\t\t        this.value = this.stringify.dtdEntityValue(value);\n\t\t        this.internal = true;\n\t\t      } else {\n\t\t        if (!value.pubID && !value.sysID) {\n\t\t          throw new Error(\"Public and/or system identifiers are required for an external entity. \" + this.debugInfo(name));\n\t\t        }\n\t\t        if (value.pubID && !value.sysID) {\n\t\t          throw new Error(\"System identifier is required for a public external entity. \" + this.debugInfo(name));\n\t\t        }\n\t\t        this.internal = false;\n\t\t        if (value.pubID != null) {\n\t\t          this.pubID = this.stringify.dtdPubID(value.pubID);\n\t\t        }\n\t\t        if (value.sysID != null) {\n\t\t          this.sysID = this.stringify.dtdSysID(value.sysID);\n\t\t        }\n\t\t        if (value.nData != null) {\n\t\t          this.nData = this.stringify.dtdNData(value.nData);\n\t\t        }\n\t\t        if (this.pe && this.nData) {\n\t\t          throw new Error(\"Notation declaration is not allowed in a parameter entity. \" + this.debugInfo(name));\n\t\t        }\n\t\t      }\n\t\t    }\n\n\t\t    Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {\n\t\t      get: function() {\n\t\t        return this.pubID;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {\n\t\t      get: function() {\n\t\t        return this.sysID;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {\n\t\t      get: function() {\n\t\t        return this.nData || null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {\n\t\t      get: function() {\n\t\t        return null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {\n\t\t      get: function() {\n\t\t        return null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {\n\t\t      get: function() {\n\t\t        return null;\n\t\t      }\n\t\t    });\n\n\t\t    XMLDTDEntity.prototype.toString = function(options) {\n\t\t      return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    return XMLDTDEntity;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLDTDEntity);\n\t\treturn XMLDTDEntity$1.exports;\n\t}\n\n\tvar XMLDTDElement$1 = {exports: {}};\n\n\tvar XMLDTDElement = XMLDTDElement$1.exports;\n\n\tvar hasRequiredXMLDTDElement;\n\n\tfunction requireXMLDTDElement () {\n\t\tif (hasRequiredXMLDTDElement) return XMLDTDElement$1.exports;\n\t\thasRequiredXMLDTDElement = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLNode,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLDTDElement$1.exports = (function(superClass) {\n\t\t    extend(XMLDTDElement, superClass);\n\n\t\t    function XMLDTDElement(parent, name, value) {\n\t\t      XMLDTDElement.__super__.constructor.call(this, parent);\n\t\t      if (name == null) {\n\t\t        throw new Error(\"Missing DTD element name. \" + this.debugInfo());\n\t\t      }\n\t\t      if (!value) {\n\t\t        value = '(#PCDATA)';\n\t\t      }\n\t\t      if (Array.isArray(value)) {\n\t\t        value = '(' + value.join(',') + ')';\n\t\t      }\n\t\t      this.name = this.stringify.name(name);\n\t\t      this.type = NodeType.ElementDeclaration;\n\t\t      this.value = this.stringify.dtdElementValue(value);\n\t\t    }\n\n\t\t    XMLDTDElement.prototype.toString = function(options) {\n\t\t      return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    return XMLDTDElement;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLDTDElement);\n\t\treturn XMLDTDElement$1.exports;\n\t}\n\n\tvar XMLDTDNotation$1 = {exports: {}};\n\n\tvar XMLDTDNotation = XMLDTDNotation$1.exports;\n\n\tvar hasRequiredXMLDTDNotation;\n\n\tfunction requireXMLDTDNotation () {\n\t\tif (hasRequiredXMLDTDNotation) return XMLDTDNotation$1.exports;\n\t\thasRequiredXMLDTDNotation = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLNode,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLDTDNotation$1.exports = (function(superClass) {\n\t\t    extend(XMLDTDNotation, superClass);\n\n\t\t    function XMLDTDNotation(parent, name, value) {\n\t\t      XMLDTDNotation.__super__.constructor.call(this, parent);\n\t\t      if (name == null) {\n\t\t        throw new Error(\"Missing DTD notation name. \" + this.debugInfo(name));\n\t\t      }\n\t\t      if (!value.pubID && !value.sysID) {\n\t\t        throw new Error(\"Public or system identifiers are required for an external entity. \" + this.debugInfo(name));\n\t\t      }\n\t\t      this.name = this.stringify.name(name);\n\t\t      this.type = NodeType.NotationDeclaration;\n\t\t      if (value.pubID != null) {\n\t\t        this.pubID = this.stringify.dtdPubID(value.pubID);\n\t\t      }\n\t\t      if (value.sysID != null) {\n\t\t        this.sysID = this.stringify.dtdSysID(value.sysID);\n\t\t      }\n\t\t    }\n\n\t\t    Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {\n\t\t      get: function() {\n\t\t        return this.pubID;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {\n\t\t      get: function() {\n\t\t        return this.sysID;\n\t\t      }\n\t\t    });\n\n\t\t    XMLDTDNotation.prototype.toString = function(options) {\n\t\t      return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    return XMLDTDNotation;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLDTDNotation);\n\t\treturn XMLDTDNotation$1.exports;\n\t}\n\n\tvar XMLDocType = XMLDocType$1.exports;\n\n\tvar hasRequiredXMLDocType;\n\n\tfunction requireXMLDocType () {\n\t\tif (hasRequiredXMLDocType) return XMLDocType$1.exports;\n\t\thasRequiredXMLDocType = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLNamedNodeMap, XMLNode, isObject,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  isObject = requireUtility().isObject;\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLDTDAttList = requireXMLDTDAttList();\n\n\t\t  XMLDTDEntity = requireXMLDTDEntity();\n\n\t\t  XMLDTDElement = requireXMLDTDElement();\n\n\t\t  XMLDTDNotation = requireXMLDTDNotation();\n\n\t\t  XMLNamedNodeMap = requireXMLNamedNodeMap();\n\n\t\t  XMLDocType$1.exports = (function(superClass) {\n\t\t    extend(XMLDocType, superClass);\n\n\t\t    function XMLDocType(parent, pubID, sysID) {\n\t\t      var child, i, len, ref, ref1, ref2;\n\t\t      XMLDocType.__super__.constructor.call(this, parent);\n\t\t      this.type = NodeType.DocType;\n\t\t      if (parent.children) {\n\t\t        ref = parent.children;\n\t\t        for (i = 0, len = ref.length; i < len; i++) {\n\t\t          child = ref[i];\n\t\t          if (child.type === NodeType.Element) {\n\t\t            this.name = child.name;\n\t\t            break;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      this.documentObject = parent;\n\t\t      if (isObject(pubID)) {\n\t\t        ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;\n\t\t      }\n\t\t      if (sysID == null) {\n\t\t        ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];\n\t\t      }\n\t\t      if (pubID != null) {\n\t\t        this.pubID = this.stringify.dtdPubID(pubID);\n\t\t      }\n\t\t      if (sysID != null) {\n\t\t        this.sysID = this.stringify.dtdSysID(sysID);\n\t\t      }\n\t\t    }\n\n\t\t    Object.defineProperty(XMLDocType.prototype, 'entities', {\n\t\t      get: function() {\n\t\t        var child, i, len, nodes, ref;\n\t\t        nodes = {};\n\t\t        ref = this.children;\n\t\t        for (i = 0, len = ref.length; i < len; i++) {\n\t\t          child = ref[i];\n\t\t          if ((child.type === NodeType.EntityDeclaration) && !child.pe) {\n\t\t            nodes[child.name] = child;\n\t\t          }\n\t\t        }\n\t\t        return new XMLNamedNodeMap(nodes);\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocType.prototype, 'notations', {\n\t\t      get: function() {\n\t\t        var child, i, len, nodes, ref;\n\t\t        nodes = {};\n\t\t        ref = this.children;\n\t\t        for (i = 0, len = ref.length; i < len; i++) {\n\t\t          child = ref[i];\n\t\t          if (child.type === NodeType.NotationDeclaration) {\n\t\t            nodes[child.name] = child;\n\t\t          }\n\t\t        }\n\t\t        return new XMLNamedNodeMap(nodes);\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocType.prototype, 'publicId', {\n\t\t      get: function() {\n\t\t        return this.pubID;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocType.prototype, 'systemId', {\n\t\t      get: function() {\n\t\t        return this.sysID;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocType.prototype, 'internalSubset', {\n\t\t      get: function() {\n\t\t        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t      }\n\t\t    });\n\n\t\t    XMLDocType.prototype.element = function(name, value) {\n\t\t      var child;\n\t\t      child = new XMLDTDElement(this, name, value);\n\t\t      this.children.push(child);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n\t\t      var child;\n\t\t      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n\t\t      this.children.push(child);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocType.prototype.entity = function(name, value) {\n\t\t      var child;\n\t\t      child = new XMLDTDEntity(this, false, name, value);\n\t\t      this.children.push(child);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocType.prototype.pEntity = function(name, value) {\n\t\t      var child;\n\t\t      child = new XMLDTDEntity(this, true, name, value);\n\t\t      this.children.push(child);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocType.prototype.notation = function(name, value) {\n\t\t      var child;\n\t\t      child = new XMLDTDNotation(this, name, value);\n\t\t      this.children.push(child);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocType.prototype.toString = function(options) {\n\t\t      return this.options.writer.docType(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    XMLDocType.prototype.ele = function(name, value) {\n\t\t      return this.element(name, value);\n\t\t    };\n\n\t\t    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n\t\t      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);\n\t\t    };\n\n\t\t    XMLDocType.prototype.ent = function(name, value) {\n\t\t      return this.entity(name, value);\n\t\t    };\n\n\t\t    XMLDocType.prototype.pent = function(name, value) {\n\t\t      return this.pEntity(name, value);\n\t\t    };\n\n\t\t    XMLDocType.prototype.not = function(name, value) {\n\t\t      return this.notation(name, value);\n\t\t    };\n\n\t\t    XMLDocType.prototype.up = function() {\n\t\t      return this.root() || this.documentObject;\n\t\t    };\n\n\t\t    XMLDocType.prototype.isEqualNode = function(node) {\n\t\t      if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.name !== this.name) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.publicId !== this.publicId) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.systemId !== this.systemId) {\n\t\t        return false;\n\t\t      }\n\t\t      return true;\n\t\t    };\n\n\t\t    return XMLDocType;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLDocType);\n\t\treturn XMLDocType$1.exports;\n\t}\n\n\tvar XMLRaw$1 = {exports: {}};\n\n\tvar XMLRaw = XMLRaw$1.exports;\n\n\tvar hasRequiredXMLRaw;\n\n\tfunction requireXMLRaw () {\n\t\tif (hasRequiredXMLRaw) return XMLRaw$1.exports;\n\t\thasRequiredXMLRaw = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLNode, extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  XMLRaw$1.exports = (function(superClass) {\n\t\t    extend(XMLRaw, superClass);\n\n\t\t    function XMLRaw(parent, text) {\n\t\t      XMLRaw.__super__.constructor.call(this, parent);\n\t\t      if (text == null) {\n\t\t        throw new Error(\"Missing raw text. \" + this.debugInfo());\n\t\t      }\n\t\t      this.type = NodeType.Raw;\n\t\t      this.value = this.stringify.raw(text);\n\t\t    }\n\n\t\t    XMLRaw.prototype.clone = function() {\n\t\t      return Object.create(this);\n\t\t    };\n\n\t\t    XMLRaw.prototype.toString = function(options) {\n\t\t      return this.options.writer.raw(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    return XMLRaw;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLRaw);\n\t\treturn XMLRaw$1.exports;\n\t}\n\n\tvar XMLText$1 = {exports: {}};\n\n\tvar XMLText = XMLText$1.exports;\n\n\tvar hasRequiredXMLText;\n\n\tfunction requireXMLText () {\n\t\tif (hasRequiredXMLText) return XMLText$1.exports;\n\t\thasRequiredXMLText = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLCharacterData, extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLCharacterData = requireXMLCharacterData();\n\n\t\t  XMLText$1.exports = (function(superClass) {\n\t\t    extend(XMLText, superClass);\n\n\t\t    function XMLText(parent, text) {\n\t\t      XMLText.__super__.constructor.call(this, parent);\n\t\t      if (text == null) {\n\t\t        throw new Error(\"Missing element text. \" + this.debugInfo());\n\t\t      }\n\t\t      this.name = \"#text\";\n\t\t      this.type = NodeType.Text;\n\t\t      this.value = this.stringify.text(text);\n\t\t    }\n\n\t\t    Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {\n\t\t      get: function() {\n\t\t        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLText.prototype, 'wholeText', {\n\t\t      get: function() {\n\t\t        var next, prev, str;\n\t\t        str = '';\n\t\t        prev = this.previousSibling;\n\t\t        while (prev) {\n\t\t          str = prev.data + str;\n\t\t          prev = prev.previousSibling;\n\t\t        }\n\t\t        str += this.data;\n\t\t        next = this.nextSibling;\n\t\t        while (next) {\n\t\t          str = str + next.data;\n\t\t          next = next.nextSibling;\n\t\t        }\n\t\t        return str;\n\t\t      }\n\t\t    });\n\n\t\t    XMLText.prototype.clone = function() {\n\t\t      return Object.create(this);\n\t\t    };\n\n\t\t    XMLText.prototype.toString = function(options) {\n\t\t      return this.options.writer.text(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    XMLText.prototype.splitText = function(offset) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLText.prototype.replaceWholeText = function(content) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    return XMLText;\n\n\t\t  })(XMLCharacterData);\n\n\t\t}).call(XMLText);\n\t\treturn XMLText$1.exports;\n\t}\n\n\tvar XMLProcessingInstruction$1 = {exports: {}};\n\n\tvar XMLProcessingInstruction = XMLProcessingInstruction$1.exports;\n\n\tvar hasRequiredXMLProcessingInstruction;\n\n\tfunction requireXMLProcessingInstruction () {\n\t\tif (hasRequiredXMLProcessingInstruction) return XMLProcessingInstruction$1.exports;\n\t\thasRequiredXMLProcessingInstruction = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLCharacterData, extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLCharacterData = requireXMLCharacterData();\n\n\t\t  XMLProcessingInstruction$1.exports = (function(superClass) {\n\t\t    extend(XMLProcessingInstruction, superClass);\n\n\t\t    function XMLProcessingInstruction(parent, target, value) {\n\t\t      XMLProcessingInstruction.__super__.constructor.call(this, parent);\n\t\t      if (target == null) {\n\t\t        throw new Error(\"Missing instruction target. \" + this.debugInfo());\n\t\t      }\n\t\t      this.type = NodeType.ProcessingInstruction;\n\t\t      this.target = this.stringify.insTarget(target);\n\t\t      this.name = this.target;\n\t\t      if (value) {\n\t\t        this.value = this.stringify.insValue(value);\n\t\t      }\n\t\t    }\n\n\t\t    XMLProcessingInstruction.prototype.clone = function() {\n\t\t      return Object.create(this);\n\t\t    };\n\n\t\t    XMLProcessingInstruction.prototype.toString = function(options) {\n\t\t      return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    XMLProcessingInstruction.prototype.isEqualNode = function(node) {\n\t\t      if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.target !== this.target) {\n\t\t        return false;\n\t\t      }\n\t\t      return true;\n\t\t    };\n\n\t\t    return XMLProcessingInstruction;\n\n\t\t  })(XMLCharacterData);\n\n\t\t}).call(XMLProcessingInstruction);\n\t\treturn XMLProcessingInstruction$1.exports;\n\t}\n\n\tvar XMLDummy$1 = {exports: {}};\n\n\tvar XMLDummy = XMLDummy$1.exports;\n\n\tvar hasRequiredXMLDummy;\n\n\tfunction requireXMLDummy () {\n\t\tif (hasRequiredXMLDummy) return XMLDummy$1.exports;\n\t\thasRequiredXMLDummy = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLNode,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLDummy$1.exports = (function(superClass) {\n\t\t    extend(XMLDummy, superClass);\n\n\t\t    function XMLDummy(parent) {\n\t\t      XMLDummy.__super__.constructor.call(this, parent);\n\t\t      this.type = NodeType.Dummy;\n\t\t    }\n\n\t\t    XMLDummy.prototype.clone = function() {\n\t\t      return Object.create(this);\n\t\t    };\n\n\t\t    XMLDummy.prototype.toString = function(options) {\n\t\t      return '';\n\t\t    };\n\n\t\t    return XMLDummy;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLDummy);\n\t\treturn XMLDummy$1.exports;\n\t}\n\n\tvar XMLNodeList$1 = {exports: {}};\n\n\tvar XMLNodeList = XMLNodeList$1.exports;\n\n\tvar hasRequiredXMLNodeList;\n\n\tfunction requireXMLNodeList () {\n\t\tif (hasRequiredXMLNodeList) return XMLNodeList$1.exports;\n\t\thasRequiredXMLNodeList = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\n\t\t  XMLNodeList$1.exports = (function() {\n\t\t    function XMLNodeList(nodes) {\n\t\t      this.nodes = nodes;\n\t\t    }\n\n\t\t    Object.defineProperty(XMLNodeList.prototype, 'length', {\n\t\t      get: function() {\n\t\t        return this.nodes.length || 0;\n\t\t      }\n\t\t    });\n\n\t\t    XMLNodeList.prototype.clone = function() {\n\t\t      return this.nodes = null;\n\t\t    };\n\n\t\t    XMLNodeList.prototype.item = function(index) {\n\t\t      return this.nodes[index] || null;\n\t\t    };\n\n\t\t    return XMLNodeList;\n\n\t\t  })();\n\n\t\t}).call(XMLNodeList);\n\t\treturn XMLNodeList$1.exports;\n\t}\n\n\tvar DocumentPosition$1 = {exports: {}};\n\n\tvar DocumentPosition = DocumentPosition$1.exports;\n\n\tvar hasRequiredDocumentPosition;\n\n\tfunction requireDocumentPosition () {\n\t\tif (hasRequiredDocumentPosition) return DocumentPosition$1.exports;\n\t\thasRequiredDocumentPosition = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  DocumentPosition$1.exports = {\n\t\t    Disconnected: 1,\n\t\t    Preceding: 2,\n\t\t    Following: 4,\n\t\t    Contains: 8,\n\t\t    ContainedBy: 16,\n\t\t    ImplementationSpecific: 32\n\t\t  };\n\n\t\t}).call(DocumentPosition);\n\t\treturn DocumentPosition$1.exports;\n\t}\n\n\tvar XMLNode = XMLNode$1.exports;\n\n\tvar hasRequiredXMLNode;\n\n\tfunction requireXMLNode () {\n\t\tif (hasRequiredXMLNode) return XMLNode$1.exports;\n\t\thasRequiredXMLNode = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1,\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  ref1 = requireUtility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;\n\n\t\t  XMLElement = null;\n\n\t\t  XMLCData = null;\n\n\t\t  XMLComment = null;\n\n\t\t  XMLDeclaration = null;\n\n\t\t  XMLDocType = null;\n\n\t\t  XMLRaw = null;\n\n\t\t  XMLText = null;\n\n\t\t  XMLProcessingInstruction = null;\n\n\t\t  XMLDummy = null;\n\n\t\t  NodeType = null;\n\n\t\t  XMLNodeList = null;\n\n\t\t  DocumentPosition = null;\n\n\t\t  XMLNode$1.exports = (function() {\n\t\t    function XMLNode(parent1) {\n\t\t      this.parent = parent1;\n\t\t      if (this.parent) {\n\t\t        this.options = this.parent.options;\n\t\t        this.stringify = this.parent.stringify;\n\t\t      }\n\t\t      this.value = null;\n\t\t      this.children = [];\n\t\t      this.baseURI = null;\n\t\t      if (!XMLElement) {\n\t\t        XMLElement = requireXMLElement();\n\t\t        XMLCData = requireXMLCData();\n\t\t        XMLComment = requireXMLComment();\n\t\t        XMLDeclaration = requireXMLDeclaration();\n\t\t        XMLDocType = requireXMLDocType();\n\t\t        XMLRaw = requireXMLRaw();\n\t\t        XMLText = requireXMLText();\n\t\t        XMLProcessingInstruction = requireXMLProcessingInstruction();\n\t\t        XMLDummy = requireXMLDummy();\n\t\t        NodeType = requireNodeType();\n\t\t        XMLNodeList = requireXMLNodeList();\n\t\t        requireXMLNamedNodeMap();\n\t\t        DocumentPosition = requireDocumentPosition();\n\t\t      }\n\t\t    }\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n\t\t      get: function() {\n\t\t        return this.name;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n\t\t      get: function() {\n\t\t        return this.type;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n\t\t      get: function() {\n\t\t        return this.value;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n\t\t      get: function() {\n\t\t        return this.parent;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n\t\t      get: function() {\n\t\t        if (!this.childNodeList || !this.childNodeList.nodes) {\n\t\t          this.childNodeList = new XMLNodeList(this.children);\n\t\t        }\n\t\t        return this.childNodeList;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n\t\t      get: function() {\n\t\t        return this.children[0] || null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n\t\t      get: function() {\n\t\t        return this.children[this.children.length - 1] || null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n\t\t      get: function() {\n\t\t        var i;\n\t\t        i = this.parent.children.indexOf(this);\n\t\t        return this.parent.children[i - 1] || null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n\t\t      get: function() {\n\t\t        var i;\n\t\t        i = this.parent.children.indexOf(this);\n\t\t        return this.parent.children[i + 1] || null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n\t\t      get: function() {\n\t\t        return this.document() || null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLNode.prototype, 'textContent', {\n\t\t      get: function() {\n\t\t        var child, j, len, ref2, str;\n\t\t        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n\t\t          str = '';\n\t\t          ref2 = this.children;\n\t\t          for (j = 0, len = ref2.length; j < len; j++) {\n\t\t            child = ref2[j];\n\t\t            if (child.textContent) {\n\t\t              str += child.textContent;\n\t\t            }\n\t\t          }\n\t\t          return str;\n\t\t        } else {\n\t\t          return null;\n\t\t        }\n\t\t      },\n\t\t      set: function(value) {\n\t\t        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t      }\n\t\t    });\n\n\t\t    XMLNode.prototype.setParent = function(parent) {\n\t\t      var child, j, len, ref2, results;\n\t\t      this.parent = parent;\n\t\t      if (parent) {\n\t\t        this.options = parent.options;\n\t\t        this.stringify = parent.stringify;\n\t\t      }\n\t\t      ref2 = this.children;\n\t\t      results = [];\n\t\t      for (j = 0, len = ref2.length; j < len; j++) {\n\t\t        child = ref2[j];\n\t\t        results.push(child.setParent(this));\n\t\t      }\n\t\t      return results;\n\t\t    };\n\n\t\t    XMLNode.prototype.element = function(name, attributes, text) {\n\t\t      var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;\n\t\t      lastChild = null;\n\t\t      if (attributes === null && (text == null)) {\n\t\t        ref2 = [{}, null], attributes = ref2[0], text = ref2[1];\n\t\t      }\n\t\t      if (attributes == null) {\n\t\t        attributes = {};\n\t\t      }\n\t\t      attributes = getValue(attributes);\n\t\t      if (!isObject(attributes)) {\n\t\t        ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];\n\t\t      }\n\t\t      if (name != null) {\n\t\t        name = getValue(name);\n\t\t      }\n\t\t      if (Array.isArray(name)) {\n\t\t        for (j = 0, len = name.length; j < len; j++) {\n\t\t          item = name[j];\n\t\t          lastChild = this.element(item);\n\t\t        }\n\t\t      } else if (isFunction(name)) {\n\t\t        lastChild = this.element(name.apply());\n\t\t      } else if (isObject(name)) {\n\t\t        for (key in name) {\n\t\t          if (!hasProp.call(name, key)) continue;\n\t\t          val = name[key];\n\t\t          if (isFunction(val)) {\n\t\t            val = val.apply();\n\t\t          }\n\t\t          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n\t\t            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n\t\t          } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n\t\t            lastChild = this.dummy();\n\t\t          } else if (isObject(val) && isEmpty(val)) {\n\t\t            lastChild = this.element(key);\n\t\t          } else if (!this.options.keepNullNodes && (val == null)) {\n\t\t            lastChild = this.dummy();\n\t\t          } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n\t\t            for (k = 0, len1 = val.length; k < len1; k++) {\n\t\t              item = val[k];\n\t\t              childNode = {};\n\t\t              childNode[key] = item;\n\t\t              lastChild = this.element(childNode);\n\t\t            }\n\t\t          } else if (isObject(val)) {\n\t\t            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n\t\t              lastChild = this.element(val);\n\t\t            } else {\n\t\t              lastChild = this.element(key);\n\t\t              lastChild.element(val);\n\t\t            }\n\t\t          } else {\n\t\t            lastChild = this.element(key, val);\n\t\t          }\n\t\t        }\n\t\t      } else if (!this.options.keepNullNodes && text === null) {\n\t\t        lastChild = this.dummy();\n\t\t      } else {\n\t\t        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n\t\t          lastChild = this.text(text);\n\t\t        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n\t\t          lastChild = this.cdata(text);\n\t\t        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n\t\t          lastChild = this.comment(text);\n\t\t        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n\t\t          lastChild = this.raw(text);\n\t\t        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n\t\t          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n\t\t        } else {\n\t\t          lastChild = this.node(name, attributes, text);\n\t\t        }\n\t\t      }\n\t\t      if (lastChild == null) {\n\t\t        throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n\t\t      }\n\t\t      return lastChild;\n\t\t    };\n\n\t\t    XMLNode.prototype.insertBefore = function(name, attributes, text) {\n\t\t      var child, i, newChild, refChild, removed;\n\t\t      if (name != null ? name.type : undefined) {\n\t\t        newChild = name;\n\t\t        refChild = attributes;\n\t\t        newChild.setParent(this);\n\t\t        if (refChild) {\n\t\t          i = children.indexOf(refChild);\n\t\t          removed = children.splice(i);\n\t\t          children.push(newChild);\n\t\t          Array.prototype.push.apply(children, removed);\n\t\t        } else {\n\t\t          children.push(newChild);\n\t\t        }\n\t\t        return newChild;\n\t\t      } else {\n\t\t        if (this.isRoot) {\n\t\t          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n\t\t        }\n\t\t        i = this.parent.children.indexOf(this);\n\t\t        removed = this.parent.children.splice(i);\n\t\t        child = this.parent.element(name, attributes, text);\n\t\t        Array.prototype.push.apply(this.parent.children, removed);\n\t\t        return child;\n\t\t      }\n\t\t    };\n\n\t\t    XMLNode.prototype.insertAfter = function(name, attributes, text) {\n\t\t      var child, i, removed;\n\t\t      if (this.isRoot) {\n\t\t        throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n\t\t      }\n\t\t      i = this.parent.children.indexOf(this);\n\t\t      removed = this.parent.children.splice(i + 1);\n\t\t      child = this.parent.element(name, attributes, text);\n\t\t      Array.prototype.push.apply(this.parent.children, removed);\n\t\t      return child;\n\t\t    };\n\n\t\t    XMLNode.prototype.remove = function() {\n\t\t      var i;\n\t\t      if (this.isRoot) {\n\t\t        throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n\t\t      }\n\t\t      i = this.parent.children.indexOf(this);\n\t\t      [].splice.apply(this.parent.children, [i, i - i + 1].concat([]));\n\t\t      return this.parent;\n\t\t    };\n\n\t\t    XMLNode.prototype.node = function(name, attributes, text) {\n\t\t      var child, ref2;\n\t\t      if (name != null) {\n\t\t        name = getValue(name);\n\t\t      }\n\t\t      attributes || (attributes = {});\n\t\t      attributes = getValue(attributes);\n\t\t      if (!isObject(attributes)) {\n\t\t        ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];\n\t\t      }\n\t\t      child = new XMLElement(this, name, attributes);\n\t\t      if (text != null) {\n\t\t        child.text(text);\n\t\t      }\n\t\t      this.children.push(child);\n\t\t      return child;\n\t\t    };\n\n\t\t    XMLNode.prototype.text = function(value) {\n\t\t      var child;\n\t\t      if (isObject(value)) {\n\t\t        this.element(value);\n\t\t      }\n\t\t      child = new XMLText(this, value);\n\t\t      this.children.push(child);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLNode.prototype.cdata = function(value) {\n\t\t      var child;\n\t\t      child = new XMLCData(this, value);\n\t\t      this.children.push(child);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLNode.prototype.comment = function(value) {\n\t\t      var child;\n\t\t      child = new XMLComment(this, value);\n\t\t      this.children.push(child);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLNode.prototype.commentBefore = function(value) {\n\t\t      var i, removed;\n\t\t      i = this.parent.children.indexOf(this);\n\t\t      removed = this.parent.children.splice(i);\n\t\t      this.parent.comment(value);\n\t\t      Array.prototype.push.apply(this.parent.children, removed);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLNode.prototype.commentAfter = function(value) {\n\t\t      var i, removed;\n\t\t      i = this.parent.children.indexOf(this);\n\t\t      removed = this.parent.children.splice(i + 1);\n\t\t      this.parent.comment(value);\n\t\t      Array.prototype.push.apply(this.parent.children, removed);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLNode.prototype.raw = function(value) {\n\t\t      var child;\n\t\t      child = new XMLRaw(this, value);\n\t\t      this.children.push(child);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLNode.prototype.dummy = function() {\n\t\t      var child;\n\t\t      child = new XMLDummy(this);\n\t\t      return child;\n\t\t    };\n\n\t\t    XMLNode.prototype.instruction = function(target, value) {\n\t\t      var insTarget, insValue, instruction, j, len;\n\t\t      if (target != null) {\n\t\t        target = getValue(target);\n\t\t      }\n\t\t      if (value != null) {\n\t\t        value = getValue(value);\n\t\t      }\n\t\t      if (Array.isArray(target)) {\n\t\t        for (j = 0, len = target.length; j < len; j++) {\n\t\t          insTarget = target[j];\n\t\t          this.instruction(insTarget);\n\t\t        }\n\t\t      } else if (isObject(target)) {\n\t\t        for (insTarget in target) {\n\t\t          if (!hasProp.call(target, insTarget)) continue;\n\t\t          insValue = target[insTarget];\n\t\t          this.instruction(insTarget, insValue);\n\t\t        }\n\t\t      } else {\n\t\t        if (isFunction(value)) {\n\t\t          value = value.apply();\n\t\t        }\n\t\t        instruction = new XMLProcessingInstruction(this, target, value);\n\t\t        this.children.push(instruction);\n\t\t      }\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLNode.prototype.instructionBefore = function(target, value) {\n\t\t      var i, removed;\n\t\t      i = this.parent.children.indexOf(this);\n\t\t      removed = this.parent.children.splice(i);\n\t\t      this.parent.instruction(target, value);\n\t\t      Array.prototype.push.apply(this.parent.children, removed);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLNode.prototype.instructionAfter = function(target, value) {\n\t\t      var i, removed;\n\t\t      i = this.parent.children.indexOf(this);\n\t\t      removed = this.parent.children.splice(i + 1);\n\t\t      this.parent.instruction(target, value);\n\t\t      Array.prototype.push.apply(this.parent.children, removed);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLNode.prototype.declaration = function(version, encoding, standalone) {\n\t\t      var doc, xmldec;\n\t\t      doc = this.document();\n\t\t      xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n\t\t      if (doc.children.length === 0) {\n\t\t        doc.children.unshift(xmldec);\n\t\t      } else if (doc.children[0].type === NodeType.Declaration) {\n\t\t        doc.children[0] = xmldec;\n\t\t      } else {\n\t\t        doc.children.unshift(xmldec);\n\t\t      }\n\t\t      return doc.root() || doc;\n\t\t    };\n\n\t\t    XMLNode.prototype.dtd = function(pubID, sysID) {\n\t\t      var child, doc, doctype, i, j, k, len, len1, ref2, ref3;\n\t\t      doc = this.document();\n\t\t      doctype = new XMLDocType(doc, pubID, sysID);\n\t\t      ref2 = doc.children;\n\t\t      for (i = j = 0, len = ref2.length; j < len; i = ++j) {\n\t\t        child = ref2[i];\n\t\t        if (child.type === NodeType.DocType) {\n\t\t          doc.children[i] = doctype;\n\t\t          return doctype;\n\t\t        }\n\t\t      }\n\t\t      ref3 = doc.children;\n\t\t      for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {\n\t\t        child = ref3[i];\n\t\t        if (child.isRoot) {\n\t\t          doc.children.splice(i, 0, doctype);\n\t\t          return doctype;\n\t\t        }\n\t\t      }\n\t\t      doc.children.push(doctype);\n\t\t      return doctype;\n\t\t    };\n\n\t\t    XMLNode.prototype.up = function() {\n\t\t      if (this.isRoot) {\n\t\t        throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n\t\t      }\n\t\t      return this.parent;\n\t\t    };\n\n\t\t    XMLNode.prototype.root = function() {\n\t\t      var node;\n\t\t      node = this;\n\t\t      while (node) {\n\t\t        if (node.type === NodeType.Document) {\n\t\t          return node.rootObject;\n\t\t        } else if (node.isRoot) {\n\t\t          return node;\n\t\t        } else {\n\t\t          node = node.parent;\n\t\t        }\n\t\t      }\n\t\t    };\n\n\t\t    XMLNode.prototype.document = function() {\n\t\t      var node;\n\t\t      node = this;\n\t\t      while (node) {\n\t\t        if (node.type === NodeType.Document) {\n\t\t          return node;\n\t\t        } else {\n\t\t          node = node.parent;\n\t\t        }\n\t\t      }\n\t\t    };\n\n\t\t    XMLNode.prototype.end = function(options) {\n\t\t      return this.document().end(options);\n\t\t    };\n\n\t\t    XMLNode.prototype.prev = function() {\n\t\t      var i;\n\t\t      i = this.parent.children.indexOf(this);\n\t\t      if (i < 1) {\n\t\t        throw new Error(\"Already at the first node. \" + this.debugInfo());\n\t\t      }\n\t\t      return this.parent.children[i - 1];\n\t\t    };\n\n\t\t    XMLNode.prototype.next = function() {\n\t\t      var i;\n\t\t      i = this.parent.children.indexOf(this);\n\t\t      if (i === -1 || i === this.parent.children.length - 1) {\n\t\t        throw new Error(\"Already at the last node. \" + this.debugInfo());\n\t\t      }\n\t\t      return this.parent.children[i + 1];\n\t\t    };\n\n\t\t    XMLNode.prototype.importDocument = function(doc) {\n\t\t      var clonedRoot;\n\t\t      clonedRoot = doc.root().clone();\n\t\t      clonedRoot.parent = this;\n\t\t      clonedRoot.isRoot = false;\n\t\t      this.children.push(clonedRoot);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLNode.prototype.debugInfo = function(name) {\n\t\t      var ref2, ref3;\n\t\t      name = name || this.name;\n\t\t      if ((name == null) && !((ref2 = this.parent) != null ? ref2.name : undefined)) {\n\t\t        return \"\";\n\t\t      } else if (name == null) {\n\t\t        return \"parent: <\" + this.parent.name + \">\";\n\t\t      } else if (!((ref3 = this.parent) != null ? ref3.name : undefined)) {\n\t\t        return \"node: <\" + name + \">\";\n\t\t      } else {\n\t\t        return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n\t\t      }\n\t\t    };\n\n\t\t    XMLNode.prototype.ele = function(name, attributes, text) {\n\t\t      return this.element(name, attributes, text);\n\t\t    };\n\n\t\t    XMLNode.prototype.nod = function(name, attributes, text) {\n\t\t      return this.node(name, attributes, text);\n\t\t    };\n\n\t\t    XMLNode.prototype.txt = function(value) {\n\t\t      return this.text(value);\n\t\t    };\n\n\t\t    XMLNode.prototype.dat = function(value) {\n\t\t      return this.cdata(value);\n\t\t    };\n\n\t\t    XMLNode.prototype.com = function(value) {\n\t\t      return this.comment(value);\n\t\t    };\n\n\t\t    XMLNode.prototype.ins = function(target, value) {\n\t\t      return this.instruction(target, value);\n\t\t    };\n\n\t\t    XMLNode.prototype.doc = function() {\n\t\t      return this.document();\n\t\t    };\n\n\t\t    XMLNode.prototype.dec = function(version, encoding, standalone) {\n\t\t      return this.declaration(version, encoding, standalone);\n\t\t    };\n\n\t\t    XMLNode.prototype.e = function(name, attributes, text) {\n\t\t      return this.element(name, attributes, text);\n\t\t    };\n\n\t\t    XMLNode.prototype.n = function(name, attributes, text) {\n\t\t      return this.node(name, attributes, text);\n\t\t    };\n\n\t\t    XMLNode.prototype.t = function(value) {\n\t\t      return this.text(value);\n\t\t    };\n\n\t\t    XMLNode.prototype.d = function(value) {\n\t\t      return this.cdata(value);\n\t\t    };\n\n\t\t    XMLNode.prototype.c = function(value) {\n\t\t      return this.comment(value);\n\t\t    };\n\n\t\t    XMLNode.prototype.r = function(value) {\n\t\t      return this.raw(value);\n\t\t    };\n\n\t\t    XMLNode.prototype.i = function(target, value) {\n\t\t      return this.instruction(target, value);\n\t\t    };\n\n\t\t    XMLNode.prototype.u = function() {\n\t\t      return this.up();\n\t\t    };\n\n\t\t    XMLNode.prototype.importXMLBuilder = function(doc) {\n\t\t      return this.importDocument(doc);\n\t\t    };\n\n\t\t    XMLNode.prototype.replaceChild = function(newChild, oldChild) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.removeChild = function(oldChild) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.appendChild = function(newChild) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.hasChildNodes = function() {\n\t\t      return this.children.length !== 0;\n\t\t    };\n\n\t\t    XMLNode.prototype.cloneNode = function(deep) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.normalize = function() {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.isSupported = function(feature, version) {\n\t\t      return true;\n\t\t    };\n\n\t\t    XMLNode.prototype.hasAttributes = function() {\n\t\t      return this.attribs.length !== 0;\n\t\t    };\n\n\t\t    XMLNode.prototype.compareDocumentPosition = function(other) {\n\t\t      var ref, res;\n\t\t      ref = this;\n\t\t      if (ref === other) {\n\t\t        return 0;\n\t\t      } else if (this.document() !== other.document()) {\n\t\t        res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n\t\t        if (Math.random() < 0.5) {\n\t\t          res |= DocumentPosition.Preceding;\n\t\t        } else {\n\t\t          res |= DocumentPosition.Following;\n\t\t        }\n\t\t        return res;\n\t\t      } else if (ref.isAncestor(other)) {\n\t\t        return DocumentPosition.Contains | DocumentPosition.Preceding;\n\t\t      } else if (ref.isDescendant(other)) {\n\t\t        return DocumentPosition.Contains | DocumentPosition.Following;\n\t\t      } else if (ref.isPreceding(other)) {\n\t\t        return DocumentPosition.Preceding;\n\t\t      } else {\n\t\t        return DocumentPosition.Following;\n\t\t      }\n\t\t    };\n\n\t\t    XMLNode.prototype.isSameNode = function(other) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.lookupPrefix = function(namespaceURI) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.lookupNamespaceURI = function(prefix) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.isEqualNode = function(node) {\n\t\t      var i, j, ref2;\n\t\t      if (node.nodeType !== this.nodeType) {\n\t\t        return false;\n\t\t      }\n\t\t      if (node.children.length !== this.children.length) {\n\t\t        return false;\n\t\t      }\n\t\t      for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {\n\t\t        if (!this.children[i].isEqualNode(node.children[i])) {\n\t\t          return false;\n\t\t        }\n\t\t      }\n\t\t      return true;\n\t\t    };\n\n\t\t    XMLNode.prototype.getFeature = function(feature, version) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.setUserData = function(key, data, handler) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.getUserData = function(key) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLNode.prototype.contains = function(other) {\n\t\t      if (!other) {\n\t\t        return false;\n\t\t      }\n\t\t      return other === this || this.isDescendant(other);\n\t\t    };\n\n\t\t    XMLNode.prototype.isDescendant = function(node) {\n\t\t      var child, isDescendantChild, j, len, ref2;\n\t\t      ref2 = this.children;\n\t\t      for (j = 0, len = ref2.length; j < len; j++) {\n\t\t        child = ref2[j];\n\t\t        if (node === child) {\n\t\t          return true;\n\t\t        }\n\t\t        isDescendantChild = child.isDescendant(node);\n\t\t        if (isDescendantChild) {\n\t\t          return true;\n\t\t        }\n\t\t      }\n\t\t      return false;\n\t\t    };\n\n\t\t    XMLNode.prototype.isAncestor = function(node) {\n\t\t      return node.isDescendant(this);\n\t\t    };\n\n\t\t    XMLNode.prototype.isPreceding = function(node) {\n\t\t      var nodePos, thisPos;\n\t\t      nodePos = this.treePosition(node);\n\t\t      thisPos = this.treePosition(this);\n\t\t      if (nodePos === -1 || thisPos === -1) {\n\t\t        return false;\n\t\t      } else {\n\t\t        return nodePos < thisPos;\n\t\t      }\n\t\t    };\n\n\t\t    XMLNode.prototype.isFollowing = function(node) {\n\t\t      var nodePos, thisPos;\n\t\t      nodePos = this.treePosition(node);\n\t\t      thisPos = this.treePosition(this);\n\t\t      if (nodePos === -1 || thisPos === -1) {\n\t\t        return false;\n\t\t      } else {\n\t\t        return nodePos > thisPos;\n\t\t      }\n\t\t    };\n\n\t\t    XMLNode.prototype.treePosition = function(node) {\n\t\t      var found, pos;\n\t\t      pos = 0;\n\t\t      found = false;\n\t\t      this.foreachTreeNode(this.document(), function(childNode) {\n\t\t        pos++;\n\t\t        if (!found && childNode === node) {\n\t\t          return found = true;\n\t\t        }\n\t\t      });\n\t\t      if (found) {\n\t\t        return pos;\n\t\t      } else {\n\t\t        return -1;\n\t\t      }\n\t\t    };\n\n\t\t    XMLNode.prototype.foreachTreeNode = function(node, func) {\n\t\t      var child, j, len, ref2, res;\n\t\t      node || (node = this.document());\n\t\t      ref2 = node.children;\n\t\t      for (j = 0, len = ref2.length; j < len; j++) {\n\t\t        child = ref2[j];\n\t\t        if (res = func(child)) {\n\t\t          return res;\n\t\t        } else {\n\t\t          res = this.foreachTreeNode(child, func);\n\t\t          if (res) {\n\t\t            return res;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    };\n\n\t\t    return XMLNode;\n\n\t\t  })();\n\n\t\t}).call(XMLNode);\n\t\treturn XMLNode$1.exports;\n\t}\n\n\tvar XMLStringifier$1 = {exports: {}};\n\n\tvar XMLStringifier = XMLStringifier$1.exports;\n\n\tvar hasRequiredXMLStringifier;\n\n\tfunction requireXMLStringifier () {\n\t\tif (hasRequiredXMLStringifier) return XMLStringifier$1.exports;\n\t\thasRequiredXMLStringifier = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  XMLStringifier$1.exports = (function() {\n\t\t    function XMLStringifier(options) {\n\t\t      this.assertLegalName = bind(this.assertLegalName, this);\n\t\t      this.assertLegalChar = bind(this.assertLegalChar, this);\n\t\t      var key, ref, value;\n\t\t      options || (options = {});\n\t\t      this.options = options;\n\t\t      if (!this.options.version) {\n\t\t        this.options.version = '1.0';\n\t\t      }\n\t\t      ref = options.stringify || {};\n\t\t      for (key in ref) {\n\t\t        if (!hasProp.call(ref, key)) continue;\n\t\t        value = ref[key];\n\t\t        this[key] = value;\n\t\t      }\n\t\t    }\n\n\t\t    XMLStringifier.prototype.name = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalName('' + val || '');\n\t\t    };\n\n\t\t    XMLStringifier.prototype.text = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalChar(this.textEscape('' + val || ''));\n\t\t    };\n\n\t\t    XMLStringifier.prototype.cdata = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      val = '' + val || '';\n\t\t      val = val.replace(']]>', ']]]]><![CDATA[>');\n\t\t      return this.assertLegalChar(val);\n\t\t    };\n\n\t\t    XMLStringifier.prototype.comment = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      val = '' + val || '';\n\t\t      if (val.match(/--/)) {\n\t\t        throw new Error(\"Comment text cannot contain double-hypen: \" + val);\n\t\t      }\n\t\t      return this.assertLegalChar(val);\n\t\t    };\n\n\t\t    XMLStringifier.prototype.raw = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return '' + val || '';\n\t\t    };\n\n\t\t    XMLStringifier.prototype.attValue = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalChar(this.attEscape(val = '' + val || ''));\n\t\t    };\n\n\t\t    XMLStringifier.prototype.insTarget = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalChar('' + val || '');\n\t\t    };\n\n\t\t    XMLStringifier.prototype.insValue = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      val = '' + val || '';\n\t\t      if (val.match(/\\?>/)) {\n\t\t        throw new Error(\"Invalid processing instruction value: \" + val);\n\t\t      }\n\t\t      return this.assertLegalChar(val);\n\t\t    };\n\n\t\t    XMLStringifier.prototype.xmlVersion = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      val = '' + val || '';\n\t\t      if (!val.match(/1\\.[0-9]+/)) {\n\t\t        throw new Error(\"Invalid version number: \" + val);\n\t\t      }\n\t\t      return val;\n\t\t    };\n\n\t\t    XMLStringifier.prototype.xmlEncoding = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      val = '' + val || '';\n\t\t      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {\n\t\t        throw new Error(\"Invalid encoding: \" + val);\n\t\t      }\n\t\t      return this.assertLegalChar(val);\n\t\t    };\n\n\t\t    XMLStringifier.prototype.xmlStandalone = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      if (val) {\n\t\t        return \"yes\";\n\t\t      } else {\n\t\t        return \"no\";\n\t\t      }\n\t\t    };\n\n\t\t    XMLStringifier.prototype.dtdPubID = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalChar('' + val || '');\n\t\t    };\n\n\t\t    XMLStringifier.prototype.dtdSysID = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalChar('' + val || '');\n\t\t    };\n\n\t\t    XMLStringifier.prototype.dtdElementValue = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalChar('' + val || '');\n\t\t    };\n\n\t\t    XMLStringifier.prototype.dtdAttType = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalChar('' + val || '');\n\t\t    };\n\n\t\t    XMLStringifier.prototype.dtdAttDefault = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalChar('' + val || '');\n\t\t    };\n\n\t\t    XMLStringifier.prototype.dtdEntityValue = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalChar('' + val || '');\n\t\t    };\n\n\t\t    XMLStringifier.prototype.dtdNData = function(val) {\n\t\t      if (this.options.noValidation) {\n\t\t        return val;\n\t\t      }\n\t\t      return this.assertLegalChar('' + val || '');\n\t\t    };\n\n\t\t    XMLStringifier.prototype.convertAttKey = '@';\n\n\t\t    XMLStringifier.prototype.convertPIKey = '?';\n\n\t\t    XMLStringifier.prototype.convertTextKey = '#text';\n\n\t\t    XMLStringifier.prototype.convertCDataKey = '#cdata';\n\n\t\t    XMLStringifier.prototype.convertCommentKey = '#comment';\n\n\t\t    XMLStringifier.prototype.convertRawKey = '#raw';\n\n\t\t    XMLStringifier.prototype.assertLegalChar = function(str) {\n\t\t      var regex, res;\n\t\t      if (this.options.noValidation) {\n\t\t        return str;\n\t\t      }\n\t\t      regex = '';\n\t\t      if (this.options.version === '1.0') {\n\t\t        regex = /[\\0-\\x08\\x0B\\f\\x0E-\\x1F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n\t\t        if (res = str.match(regex)) {\n\t\t          throw new Error(\"Invalid character in string: \" + str + \" at index \" + res.index);\n\t\t        }\n\t\t      } else if (this.options.version === '1.1') {\n\t\t        regex = /[\\0\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n\t\t        if (res = str.match(regex)) {\n\t\t          throw new Error(\"Invalid character in string: \" + str + \" at index \" + res.index);\n\t\t        }\n\t\t      }\n\t\t      return str;\n\t\t    };\n\n\t\t    XMLStringifier.prototype.assertLegalName = function(str) {\n\t\t      var regex;\n\t\t      if (this.options.noValidation) {\n\t\t        return str;\n\t\t      }\n\t\t      this.assertLegalChar(str);\n\t\t      regex = /^([:A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])([\\x2D\\.0-:A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\n\t\t      if (!str.match(regex)) {\n\t\t        throw new Error(\"Invalid character in name\");\n\t\t      }\n\t\t      return str;\n\t\t    };\n\n\t\t    XMLStringifier.prototype.textEscape = function(str) {\n\t\t      var ampregex;\n\t\t      if (this.options.noValidation) {\n\t\t        return str;\n\t\t      }\n\t\t      ampregex = this.options.noDoubleEncoding ? /(?!&\\S+;)&/g : /&/g;\n\t\t      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\r/g, '&#xD;');\n\t\t    };\n\n\t\t    XMLStringifier.prototype.attEscape = function(str) {\n\t\t      var ampregex;\n\t\t      if (this.options.noValidation) {\n\t\t        return str;\n\t\t      }\n\t\t      ampregex = this.options.noDoubleEncoding ? /(?!&\\S+;)&/g : /&/g;\n\t\t      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\n\t\t    };\n\n\t\t    return XMLStringifier;\n\n\t\t  })();\n\n\t\t}).call(XMLStringifier);\n\t\treturn XMLStringifier$1.exports;\n\t}\n\n\tvar XMLStringWriter$1 = {exports: {}};\n\n\tvar XMLWriterBase$1 = {exports: {}};\n\n\tvar WriterState$1 = {exports: {}};\n\n\tvar WriterState = WriterState$1.exports;\n\n\tvar hasRequiredWriterState;\n\n\tfunction requireWriterState () {\n\t\tif (hasRequiredWriterState) return WriterState$1.exports;\n\t\thasRequiredWriterState = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  WriterState$1.exports = {\n\t\t    None: 0,\n\t\t    OpenTag: 1,\n\t\t    InsideTag: 2,\n\t\t    CloseTag: 3\n\t\t  };\n\n\t\t}).call(WriterState);\n\t\treturn WriterState$1.exports;\n\t}\n\n\tvar XMLWriterBase = XMLWriterBase$1.exports;\n\n\tvar hasRequiredXMLWriterBase;\n\n\tfunction requireXMLWriterBase () {\n\t\tif (hasRequiredXMLWriterBase) return XMLWriterBase$1.exports;\n\t\thasRequiredXMLWriterBase = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, WriterState, assign,\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  assign = requireUtility().assign;\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  requireXMLDeclaration();\n\n\t\t  requireXMLDocType();\n\n\t\t  requireXMLCData();\n\n\t\t  requireXMLComment();\n\n\t\t  requireXMLElement();\n\n\t\t  requireXMLRaw();\n\n\t\t  requireXMLText();\n\n\t\t  requireXMLProcessingInstruction();\n\n\t\t  requireXMLDummy();\n\n\t\t  requireXMLDTDAttList();\n\n\t\t  requireXMLDTDElement();\n\n\t\t  requireXMLDTDEntity();\n\n\t\t  requireXMLDTDNotation();\n\n\t\t  WriterState = requireWriterState();\n\n\t\t  XMLWriterBase$1.exports = (function() {\n\t\t    function XMLWriterBase(options) {\n\t\t      var key, ref, value;\n\t\t      options || (options = {});\n\t\t      this.options = options;\n\t\t      ref = options.writer || {};\n\t\t      for (key in ref) {\n\t\t        if (!hasProp.call(ref, key)) continue;\n\t\t        value = ref[key];\n\t\t        this[\"_\" + key] = this[key];\n\t\t        this[key] = value;\n\t\t      }\n\t\t    }\n\n\t\t    XMLWriterBase.prototype.filterOptions = function(options) {\n\t\t      var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n\t\t      options || (options = {});\n\t\t      options = assign({}, this.options, options);\n\t\t      filteredOptions = {\n\t\t        writer: this\n\t\t      };\n\t\t      filteredOptions.pretty = options.pretty || false;\n\t\t      filteredOptions.allowEmpty = options.allowEmpty || false;\n\t\t      filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';\n\t\t      filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\\n';\n\t\t      filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;\n\t\t      filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;\n\t\t      filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';\n\t\t      if (filteredOptions.spaceBeforeSlash === true) {\n\t\t        filteredOptions.spaceBeforeSlash = ' ';\n\t\t      }\n\t\t      filteredOptions.suppressPrettyCount = 0;\n\t\t      filteredOptions.user = {};\n\t\t      filteredOptions.state = WriterState.None;\n\t\t      return filteredOptions;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.indent = function(node, options, level) {\n\t\t      var indentLevel;\n\t\t      if (!options.pretty || options.suppressPrettyCount) {\n\t\t        return '';\n\t\t      } else if (options.pretty) {\n\t\t        indentLevel = (level || 0) + options.offset + 1;\n\t\t        if (indentLevel > 0) {\n\t\t          return new Array(indentLevel).join(options.indent);\n\t\t        }\n\t\t      }\n\t\t      return '';\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.endline = function(node, options, level) {\n\t\t      if (!options.pretty || options.suppressPrettyCount) {\n\t\t        return '';\n\t\t      } else {\n\t\t        return options.newline;\n\t\t      }\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.attribute = function(att, options, level) {\n\t\t      var r;\n\t\t      this.openAttribute(att, options, level);\n\t\t      r = ' ' + att.name + '=\"' + att.value + '\"';\n\t\t      this.closeAttribute(att, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.cdata = function(node, options, level) {\n\t\t      var r;\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level) + '<![CDATA[';\n\t\t      options.state = WriterState.InsideTag;\n\t\t      r += node.value;\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += ']]>' + this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.comment = function(node, options, level) {\n\t\t      var r;\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level) + '<!-- ';\n\t\t      options.state = WriterState.InsideTag;\n\t\t      r += node.value;\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += ' -->' + this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.declaration = function(node, options, level) {\n\t\t      var r;\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level) + '<?xml';\n\t\t      options.state = WriterState.InsideTag;\n\t\t      r += ' version=\"' + node.version + '\"';\n\t\t      if (node.encoding != null) {\n\t\t        r += ' encoding=\"' + node.encoding + '\"';\n\t\t      }\n\t\t      if (node.standalone != null) {\n\t\t        r += ' standalone=\"' + node.standalone + '\"';\n\t\t      }\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += options.spaceBeforeSlash + '?>';\n\t\t      r += this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.docType = function(node, options, level) {\n\t\t      var child, i, len, r, ref;\n\t\t      level || (level = 0);\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level);\n\t\t      r += '<!DOCTYPE ' + node.root().name;\n\t\t      if (node.pubID && node.sysID) {\n\t\t        r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n\t\t      } else if (node.sysID) {\n\t\t        r += ' SYSTEM \"' + node.sysID + '\"';\n\t\t      }\n\t\t      if (node.children.length > 0) {\n\t\t        r += ' [';\n\t\t        r += this.endline(node, options, level);\n\t\t        options.state = WriterState.InsideTag;\n\t\t        ref = node.children;\n\t\t        for (i = 0, len = ref.length; i < len; i++) {\n\t\t          child = ref[i];\n\t\t          r += this.writeChildNode(child, options, level + 1);\n\t\t        }\n\t\t        options.state = WriterState.CloseTag;\n\t\t        r += ']';\n\t\t      }\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += options.spaceBeforeSlash + '>';\n\t\t      r += this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.element = function(node, options, level) {\n\t\t      var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;\n\t\t      level || (level = 0);\n\t\t      prettySuppressed = false;\n\t\t      r = '';\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r += this.indent(node, options, level) + '<' + node.name;\n\t\t      ref = node.attribs;\n\t\t      for (name in ref) {\n\t\t        if (!hasProp.call(ref, name)) continue;\n\t\t        att = ref[name];\n\t\t        r += this.attribute(att, options, level);\n\t\t      }\n\t\t      childNodeCount = node.children.length;\n\t\t      firstChildNode = childNodeCount === 0 ? null : node.children[0];\n\t\t      if (childNodeCount === 0 || node.children.every(function(e) {\n\t\t        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n\t\t      })) {\n\t\t        if (options.allowEmpty) {\n\t\t          r += '>';\n\t\t          options.state = WriterState.CloseTag;\n\t\t          r += '</' + node.name + '>' + this.endline(node, options, level);\n\t\t        } else {\n\t\t          options.state = WriterState.CloseTag;\n\t\t          r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);\n\t\t        }\n\t\t      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {\n\t\t        r += '>';\n\t\t        options.state = WriterState.InsideTag;\n\t\t        options.suppressPrettyCount++;\n\t\t        prettySuppressed = true;\n\t\t        r += this.writeChildNode(firstChildNode, options, level + 1);\n\t\t        options.suppressPrettyCount--;\n\t\t        prettySuppressed = false;\n\t\t        options.state = WriterState.CloseTag;\n\t\t        r += '</' + node.name + '>' + this.endline(node, options, level);\n\t\t      } else {\n\t\t        if (options.dontPrettyTextNodes) {\n\t\t          ref1 = node.children;\n\t\t          for (i = 0, len = ref1.length; i < len; i++) {\n\t\t            child = ref1[i];\n\t\t            if ((child.type === NodeType.Text || child.type === NodeType.Raw) && (child.value != null)) {\n\t\t              options.suppressPrettyCount++;\n\t\t              prettySuppressed = true;\n\t\t              break;\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t        r += '>' + this.endline(node, options, level);\n\t\t        options.state = WriterState.InsideTag;\n\t\t        ref2 = node.children;\n\t\t        for (j = 0, len1 = ref2.length; j < len1; j++) {\n\t\t          child = ref2[j];\n\t\t          r += this.writeChildNode(child, options, level + 1);\n\t\t        }\n\t\t        options.state = WriterState.CloseTag;\n\t\t        r += this.indent(node, options, level) + '</' + node.name + '>';\n\t\t        if (prettySuppressed) {\n\t\t          options.suppressPrettyCount--;\n\t\t        }\n\t\t        r += this.endline(node, options, level);\n\t\t        options.state = WriterState.None;\n\t\t      }\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.writeChildNode = function(node, options, level) {\n\t\t      switch (node.type) {\n\t\t        case NodeType.CData:\n\t\t          return this.cdata(node, options, level);\n\t\t        case NodeType.Comment:\n\t\t          return this.comment(node, options, level);\n\t\t        case NodeType.Element:\n\t\t          return this.element(node, options, level);\n\t\t        case NodeType.Raw:\n\t\t          return this.raw(node, options, level);\n\t\t        case NodeType.Text:\n\t\t          return this.text(node, options, level);\n\t\t        case NodeType.ProcessingInstruction:\n\t\t          return this.processingInstruction(node, options, level);\n\t\t        case NodeType.Dummy:\n\t\t          return '';\n\t\t        case NodeType.Declaration:\n\t\t          return this.declaration(node, options, level);\n\t\t        case NodeType.DocType:\n\t\t          return this.docType(node, options, level);\n\t\t        case NodeType.AttributeDeclaration:\n\t\t          return this.dtdAttList(node, options, level);\n\t\t        case NodeType.ElementDeclaration:\n\t\t          return this.dtdElement(node, options, level);\n\t\t        case NodeType.EntityDeclaration:\n\t\t          return this.dtdEntity(node, options, level);\n\t\t        case NodeType.NotationDeclaration:\n\t\t          return this.dtdNotation(node, options, level);\n\t\t        default:\n\t\t          throw new Error(\"Unknown XML node type: \" + node.constructor.name);\n\t\t      }\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.processingInstruction = function(node, options, level) {\n\t\t      var r;\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level) + '<?';\n\t\t      options.state = WriterState.InsideTag;\n\t\t      r += node.target;\n\t\t      if (node.value) {\n\t\t        r += ' ' + node.value;\n\t\t      }\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += options.spaceBeforeSlash + '?>';\n\t\t      r += this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.raw = function(node, options, level) {\n\t\t      var r;\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level);\n\t\t      options.state = WriterState.InsideTag;\n\t\t      r += node.value;\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.text = function(node, options, level) {\n\t\t      var r;\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level);\n\t\t      options.state = WriterState.InsideTag;\n\t\t      r += node.value;\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.dtdAttList = function(node, options, level) {\n\t\t      var r;\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level) + '<!ATTLIST';\n\t\t      options.state = WriterState.InsideTag;\n\t\t      r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;\n\t\t      if (node.defaultValueType !== '#DEFAULT') {\n\t\t        r += ' ' + node.defaultValueType;\n\t\t      }\n\t\t      if (node.defaultValue) {\n\t\t        r += ' \"' + node.defaultValue + '\"';\n\t\t      }\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.dtdElement = function(node, options, level) {\n\t\t      var r;\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level) + '<!ELEMENT';\n\t\t      options.state = WriterState.InsideTag;\n\t\t      r += ' ' + node.name + ' ' + node.value;\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.dtdEntity = function(node, options, level) {\n\t\t      var r;\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level) + '<!ENTITY';\n\t\t      options.state = WriterState.InsideTag;\n\t\t      if (node.pe) {\n\t\t        r += ' %';\n\t\t      }\n\t\t      r += ' ' + node.name;\n\t\t      if (node.value) {\n\t\t        r += ' \"' + node.value + '\"';\n\t\t      } else {\n\t\t        if (node.pubID && node.sysID) {\n\t\t          r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n\t\t        } else if (node.sysID) {\n\t\t          r += ' SYSTEM \"' + node.sysID + '\"';\n\t\t        }\n\t\t        if (node.nData) {\n\t\t          r += ' NDATA ' + node.nData;\n\t\t        }\n\t\t      }\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.dtdNotation = function(node, options, level) {\n\t\t      var r;\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      r = this.indent(node, options, level) + '<!NOTATION';\n\t\t      options.state = WriterState.InsideTag;\n\t\t      r += ' ' + node.name;\n\t\t      if (node.pubID && node.sysID) {\n\t\t        r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n\t\t      } else if (node.pubID) {\n\t\t        r += ' PUBLIC \"' + node.pubID + '\"';\n\t\t      } else if (node.sysID) {\n\t\t        r += ' SYSTEM \"' + node.sysID + '\"';\n\t\t      }\n\t\t      options.state = WriterState.CloseTag;\n\t\t      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n\t\t      options.state = WriterState.None;\n\t\t      this.closeNode(node, options, level);\n\t\t      return r;\n\t\t    };\n\n\t\t    XMLWriterBase.prototype.openNode = function(node, options, level) {};\n\n\t\t    XMLWriterBase.prototype.closeNode = function(node, options, level) {};\n\n\t\t    XMLWriterBase.prototype.openAttribute = function(att, options, level) {};\n\n\t\t    XMLWriterBase.prototype.closeAttribute = function(att, options, level) {};\n\n\t\t    return XMLWriterBase;\n\n\t\t  })();\n\n\t\t}).call(XMLWriterBase);\n\t\treturn XMLWriterBase$1.exports;\n\t}\n\n\tvar XMLStringWriter = XMLStringWriter$1.exports;\n\n\tvar hasRequiredXMLStringWriter;\n\n\tfunction requireXMLStringWriter () {\n\t\tif (hasRequiredXMLStringWriter) return XMLStringWriter$1.exports;\n\t\thasRequiredXMLStringWriter = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var XMLWriterBase,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  XMLWriterBase = requireXMLWriterBase();\n\n\t\t  XMLStringWriter$1.exports = (function(superClass) {\n\t\t    extend(XMLStringWriter, superClass);\n\n\t\t    function XMLStringWriter(options) {\n\t\t      XMLStringWriter.__super__.constructor.call(this, options);\n\t\t    }\n\n\t\t    XMLStringWriter.prototype.document = function(doc, options) {\n\t\t      var child, i, len, r, ref;\n\t\t      options = this.filterOptions(options);\n\t\t      r = '';\n\t\t      ref = doc.children;\n\t\t      for (i = 0, len = ref.length; i < len; i++) {\n\t\t        child = ref[i];\n\t\t        r += this.writeChildNode(child, options, 0);\n\t\t      }\n\t\t      if (options.pretty && r.slice(-options.newline.length) === options.newline) {\n\t\t        r = r.slice(0, -options.newline.length);\n\t\t      }\n\t\t      return r;\n\t\t    };\n\n\t\t    return XMLStringWriter;\n\n\t\t  })(XMLWriterBase);\n\n\t\t}).call(XMLStringWriter);\n\t\treturn XMLStringWriter$1.exports;\n\t}\n\n\tvar XMLDocument = XMLDocument$1.exports;\n\n\tvar hasRequiredXMLDocument;\n\n\tfunction requireXMLDocument () {\n\t\tif (hasRequiredXMLDocument) return XMLDocument$1.exports;\n\t\thasRequiredXMLDocument = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  isPlainObject = requireUtility().isPlainObject;\n\n\t\t  XMLDOMImplementation = requireXMLDOMImplementation();\n\n\t\t  XMLDOMConfiguration = requireXMLDOMConfiguration();\n\n\t\t  XMLNode = requireXMLNode();\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLStringifier = requireXMLStringifier();\n\n\t\t  XMLStringWriter = requireXMLStringWriter();\n\n\t\t  XMLDocument$1.exports = (function(superClass) {\n\t\t    extend(XMLDocument, superClass);\n\n\t\t    function XMLDocument(options) {\n\t\t      XMLDocument.__super__.constructor.call(this, null);\n\t\t      this.name = \"#document\";\n\t\t      this.type = NodeType.Document;\n\t\t      this.documentURI = null;\n\t\t      this.domConfig = new XMLDOMConfiguration();\n\t\t      options || (options = {});\n\t\t      if (!options.writer) {\n\t\t        options.writer = new XMLStringWriter();\n\t\t      }\n\t\t      this.options = options;\n\t\t      this.stringify = new XMLStringifier(options);\n\t\t    }\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'implementation', {\n\t\t      value: new XMLDOMImplementation()\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'doctype', {\n\t\t      get: function() {\n\t\t        var child, i, len, ref;\n\t\t        ref = this.children;\n\t\t        for (i = 0, len = ref.length; i < len; i++) {\n\t\t          child = ref[i];\n\t\t          if (child.type === NodeType.DocType) {\n\t\t            return child;\n\t\t          }\n\t\t        }\n\t\t        return null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'documentElement', {\n\t\t      get: function() {\n\t\t        return this.rootObject || null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {\n\t\t      get: function() {\n\t\t        return null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {\n\t\t      get: function() {\n\t\t        return false;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {\n\t\t      get: function() {\n\t\t        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {\n\t\t          return this.children[0].encoding;\n\t\t        } else {\n\t\t          return null;\n\t\t        }\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {\n\t\t      get: function() {\n\t\t        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {\n\t\t          return this.children[0].standalone === 'yes';\n\t\t        } else {\n\t\t          return false;\n\t\t        }\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {\n\t\t      get: function() {\n\t\t        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {\n\t\t          return this.children[0].version;\n\t\t        } else {\n\t\t          return \"1.0\";\n\t\t        }\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'URL', {\n\t\t      get: function() {\n\t\t        return this.documentURI;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'origin', {\n\t\t      get: function() {\n\t\t        return null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'compatMode', {\n\t\t      get: function() {\n\t\t        return null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'characterSet', {\n\t\t      get: function() {\n\t\t        return null;\n\t\t      }\n\t\t    });\n\n\t\t    Object.defineProperty(XMLDocument.prototype, 'contentType', {\n\t\t      get: function() {\n\t\t        return null;\n\t\t      }\n\t\t    });\n\n\t\t    XMLDocument.prototype.end = function(writer) {\n\t\t      var writerOptions;\n\t\t      writerOptions = {};\n\t\t      if (!writer) {\n\t\t        writer = this.options.writer;\n\t\t      } else if (isPlainObject(writer)) {\n\t\t        writerOptions = writer;\n\t\t        writer = this.options.writer;\n\t\t      }\n\t\t      return writer.document(this, writer.filterOptions(writerOptions));\n\t\t    };\n\n\t\t    XMLDocument.prototype.toString = function(options) {\n\t\t      return this.options.writer.document(this, this.options.writer.filterOptions(options));\n\t\t    };\n\n\t\t    XMLDocument.prototype.createElement = function(tagName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createDocumentFragment = function() {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createTextNode = function(data) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createComment = function(data) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createCDATASection = function(data) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createProcessingInstruction = function(target, data) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createAttribute = function(name) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createEntityReference = function(name) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.getElementsByTagName = function(tagname) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.importNode = function(importedNode, deep) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.getElementById = function(elementId) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.adoptNode = function(source) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.normalizeDocument = function() {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.getElementsByClassName = function(classNames) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createEvent = function(eventInterface) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createRange = function() {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {\n\t\t      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n\t\t    };\n\n\t\t    return XMLDocument;\n\n\t\t  })(XMLNode);\n\n\t\t}).call(XMLDocument);\n\t\treturn XMLDocument$1.exports;\n\t}\n\n\tvar XMLDocumentCB$1 = {exports: {}};\n\n\tvar XMLDocumentCB = XMLDocumentCB$1.exports;\n\n\tvar hasRequiredXMLDocumentCB;\n\n\tfunction requireXMLDocumentCB () {\n\t\tif (hasRequiredXMLDocumentCB) return XMLDocumentCB$1.exports;\n\t\thasRequiredXMLDocumentCB = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref,\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  ref = requireUtility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLDocument = requireXMLDocument();\n\n\t\t  XMLElement = requireXMLElement();\n\n\t\t  XMLCData = requireXMLCData();\n\n\t\t  XMLComment = requireXMLComment();\n\n\t\t  XMLRaw = requireXMLRaw();\n\n\t\t  XMLText = requireXMLText();\n\n\t\t  XMLProcessingInstruction = requireXMLProcessingInstruction();\n\n\t\t  XMLDeclaration = requireXMLDeclaration();\n\n\t\t  XMLDocType = requireXMLDocType();\n\n\t\t  XMLDTDAttList = requireXMLDTDAttList();\n\n\t\t  XMLDTDEntity = requireXMLDTDEntity();\n\n\t\t  XMLDTDElement = requireXMLDTDElement();\n\n\t\t  XMLDTDNotation = requireXMLDTDNotation();\n\n\t\t  XMLAttribute = requireXMLAttribute();\n\n\t\t  XMLStringifier = requireXMLStringifier();\n\n\t\t  XMLStringWriter = requireXMLStringWriter();\n\n\t\t  WriterState = requireWriterState();\n\n\t\t  XMLDocumentCB$1.exports = (function() {\n\t\t    function XMLDocumentCB(options, onData, onEnd) {\n\t\t      var writerOptions;\n\t\t      this.name = \"?xml\";\n\t\t      this.type = NodeType.Document;\n\t\t      options || (options = {});\n\t\t      writerOptions = {};\n\t\t      if (!options.writer) {\n\t\t        options.writer = new XMLStringWriter();\n\t\t      } else if (isPlainObject(options.writer)) {\n\t\t        writerOptions = options.writer;\n\t\t        options.writer = new XMLStringWriter();\n\t\t      }\n\t\t      this.options = options;\n\t\t      this.writer = options.writer;\n\t\t      this.writerOptions = this.writer.filterOptions(writerOptions);\n\t\t      this.stringify = new XMLStringifier(options);\n\t\t      this.onDataCallback = onData || function() {};\n\t\t      this.onEndCallback = onEnd || function() {};\n\t\t      this.currentNode = null;\n\t\t      this.currentLevel = -1;\n\t\t      this.openTags = {};\n\t\t      this.documentStarted = false;\n\t\t      this.documentCompleted = false;\n\t\t      this.root = null;\n\t\t    }\n\n\t\t    XMLDocumentCB.prototype.createChildNode = function(node) {\n\t\t      var att, attName, attributes, child, i, len, ref1, ref2;\n\t\t      switch (node.type) {\n\t\t        case NodeType.CData:\n\t\t          this.cdata(node.value);\n\t\t          break;\n\t\t        case NodeType.Comment:\n\t\t          this.comment(node.value);\n\t\t          break;\n\t\t        case NodeType.Element:\n\t\t          attributes = {};\n\t\t          ref1 = node.attribs;\n\t\t          for (attName in ref1) {\n\t\t            if (!hasProp.call(ref1, attName)) continue;\n\t\t            att = ref1[attName];\n\t\t            attributes[attName] = att.value;\n\t\t          }\n\t\t          this.node(node.name, attributes);\n\t\t          break;\n\t\t        case NodeType.Dummy:\n\t\t          this.dummy();\n\t\t          break;\n\t\t        case NodeType.Raw:\n\t\t          this.raw(node.value);\n\t\t          break;\n\t\t        case NodeType.Text:\n\t\t          this.text(node.value);\n\t\t          break;\n\t\t        case NodeType.ProcessingInstruction:\n\t\t          this.instruction(node.target, node.value);\n\t\t          break;\n\t\t        default:\n\t\t          throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n\t\t      }\n\t\t      ref2 = node.children;\n\t\t      for (i = 0, len = ref2.length; i < len; i++) {\n\t\t        child = ref2[i];\n\t\t        this.createChildNode(child);\n\t\t        if (child.type === NodeType.Element) {\n\t\t          this.up();\n\t\t        }\n\t\t      }\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.dummy = function() {\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.node = function(name, attributes, text) {\n\t\t      var ref1;\n\t\t      if (name == null) {\n\t\t        throw new Error(\"Missing node name.\");\n\t\t      }\n\t\t      if (this.root && this.currentLevel === -1) {\n\t\t        throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n\t\t      }\n\t\t      this.openCurrent();\n\t\t      name = getValue(name);\n\t\t      if (attributes == null) {\n\t\t        attributes = {};\n\t\t      }\n\t\t      attributes = getValue(attributes);\n\t\t      if (!isObject(attributes)) {\n\t\t        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];\n\t\t      }\n\t\t      this.currentNode = new XMLElement(this, name, attributes);\n\t\t      this.currentNode.children = false;\n\t\t      this.currentLevel++;\n\t\t      this.openTags[this.currentLevel] = this.currentNode;\n\t\t      if (text != null) {\n\t\t        this.text(text);\n\t\t      }\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.element = function(name, attributes, text) {\n\t\t      var child, i, len, oldValidationFlag, ref1, root;\n\t\t      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n\t\t        this.dtdElement.apply(this, arguments);\n\t\t      } else {\n\t\t        if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n\t\t          oldValidationFlag = this.options.noValidation;\n\t\t          this.options.noValidation = true;\n\t\t          root = new XMLDocument(this.options).element('TEMP_ROOT');\n\t\t          root.element(name);\n\t\t          this.options.noValidation = oldValidationFlag;\n\t\t          ref1 = root.children;\n\t\t          for (i = 0, len = ref1.length; i < len; i++) {\n\t\t            child = ref1[i];\n\t\t            this.createChildNode(child);\n\t\t            if (child.type === NodeType.Element) {\n\t\t              this.up();\n\t\t            }\n\t\t          }\n\t\t        } else {\n\t\t          this.node(name, attributes, text);\n\t\t        }\n\t\t      }\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.attribute = function(name, value) {\n\t\t      var attName, attValue;\n\t\t      if (!this.currentNode || this.currentNode.children) {\n\t\t        throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n\t\t      }\n\t\t      if (name != null) {\n\t\t        name = getValue(name);\n\t\t      }\n\t\t      if (isObject(name)) {\n\t\t        for (attName in name) {\n\t\t          if (!hasProp.call(name, attName)) continue;\n\t\t          attValue = name[attName];\n\t\t          this.attribute(attName, attValue);\n\t\t        }\n\t\t      } else {\n\t\t        if (isFunction(value)) {\n\t\t          value = value.apply();\n\t\t        }\n\t\t        if (this.options.keepNullAttributes && (value == null)) {\n\t\t          this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n\t\t        } else if (value != null) {\n\t\t          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n\t\t        }\n\t\t      }\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.text = function(value) {\n\t\t      var node;\n\t\t      this.openCurrent();\n\t\t      node = new XMLText(this, value);\n\t\t      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.cdata = function(value) {\n\t\t      var node;\n\t\t      this.openCurrent();\n\t\t      node = new XMLCData(this, value);\n\t\t      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.comment = function(value) {\n\t\t      var node;\n\t\t      this.openCurrent();\n\t\t      node = new XMLComment(this, value);\n\t\t      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.raw = function(value) {\n\t\t      var node;\n\t\t      this.openCurrent();\n\t\t      node = new XMLRaw(this, value);\n\t\t      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.instruction = function(target, value) {\n\t\t      var i, insTarget, insValue, len, node;\n\t\t      this.openCurrent();\n\t\t      if (target != null) {\n\t\t        target = getValue(target);\n\t\t      }\n\t\t      if (value != null) {\n\t\t        value = getValue(value);\n\t\t      }\n\t\t      if (Array.isArray(target)) {\n\t\t        for (i = 0, len = target.length; i < len; i++) {\n\t\t          insTarget = target[i];\n\t\t          this.instruction(insTarget);\n\t\t        }\n\t\t      } else if (isObject(target)) {\n\t\t        for (insTarget in target) {\n\t\t          if (!hasProp.call(target, insTarget)) continue;\n\t\t          insValue = target[insTarget];\n\t\t          this.instruction(insTarget, insValue);\n\t\t        }\n\t\t      } else {\n\t\t        if (isFunction(value)) {\n\t\t          value = value.apply();\n\t\t        }\n\t\t        node = new XMLProcessingInstruction(this, target, value);\n\t\t        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      }\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {\n\t\t      var node;\n\t\t      this.openCurrent();\n\t\t      if (this.documentStarted) {\n\t\t        throw new Error(\"declaration() must be the first node.\");\n\t\t      }\n\t\t      node = new XMLDeclaration(this, version, encoding, standalone);\n\t\t      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {\n\t\t      this.openCurrent();\n\t\t      if (root == null) {\n\t\t        throw new Error(\"Missing root node name.\");\n\t\t      }\n\t\t      if (this.root) {\n\t\t        throw new Error(\"dtd() must come before the root node.\");\n\t\t      }\n\t\t      this.currentNode = new XMLDocType(this, pubID, sysID);\n\t\t      this.currentNode.rootNodeName = root;\n\t\t      this.currentNode.children = false;\n\t\t      this.currentLevel++;\n\t\t      this.openTags[this.currentLevel] = this.currentNode;\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.dtdElement = function(name, value) {\n\t\t      var node;\n\t\t      this.openCurrent();\n\t\t      node = new XMLDTDElement(this, name, value);\n\t\t      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n\t\t      var node;\n\t\t      this.openCurrent();\n\t\t      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n\t\t      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.entity = function(name, value) {\n\t\t      var node;\n\t\t      this.openCurrent();\n\t\t      node = new XMLDTDEntity(this, false, name, value);\n\t\t      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.pEntity = function(name, value) {\n\t\t      var node;\n\t\t      this.openCurrent();\n\t\t      node = new XMLDTDEntity(this, true, name, value);\n\t\t      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.notation = function(name, value) {\n\t\t      var node;\n\t\t      this.openCurrent();\n\t\t      node = new XMLDTDNotation(this, name, value);\n\t\t      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.up = function() {\n\t\t      if (this.currentLevel < 0) {\n\t\t        throw new Error(\"The document node has no parent.\");\n\t\t      }\n\t\t      if (this.currentNode) {\n\t\t        if (this.currentNode.children) {\n\t\t          this.closeNode(this.currentNode);\n\t\t        } else {\n\t\t          this.openNode(this.currentNode);\n\t\t        }\n\t\t        this.currentNode = null;\n\t\t      } else {\n\t\t        this.closeNode(this.openTags[this.currentLevel]);\n\t\t      }\n\t\t      delete this.openTags[this.currentLevel];\n\t\t      this.currentLevel--;\n\t\t      return this;\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.end = function() {\n\t\t      while (this.currentLevel >= 0) {\n\t\t        this.up();\n\t\t      }\n\t\t      return this.onEnd();\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.openCurrent = function() {\n\t\t      if (this.currentNode) {\n\t\t        this.currentNode.children = true;\n\t\t        return this.openNode(this.currentNode);\n\t\t      }\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.openNode = function(node) {\n\t\t      var att, chunk, name, ref1;\n\t\t      if (!node.isOpen) {\n\t\t        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n\t\t          this.root = node;\n\t\t        }\n\t\t        chunk = '';\n\t\t        if (node.type === NodeType.Element) {\n\t\t          this.writerOptions.state = WriterState.OpenTag;\n\t\t          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n\t\t          ref1 = node.attribs;\n\t\t          for (name in ref1) {\n\t\t            if (!hasProp.call(ref1, name)) continue;\n\t\t            att = ref1[name];\n\t\t            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n\t\t          }\n\t\t          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n\t\t          this.writerOptions.state = WriterState.InsideTag;\n\t\t        } else {\n\t\t          this.writerOptions.state = WriterState.OpenTag;\n\t\t          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;\n\t\t          if (node.pubID && node.sysID) {\n\t\t            chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n\t\t          } else if (node.sysID) {\n\t\t            chunk += ' SYSTEM \"' + node.sysID + '\"';\n\t\t          }\n\t\t          if (node.children) {\n\t\t            chunk += ' [';\n\t\t            this.writerOptions.state = WriterState.InsideTag;\n\t\t          } else {\n\t\t            this.writerOptions.state = WriterState.CloseTag;\n\t\t            chunk += '>';\n\t\t          }\n\t\t          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n\t\t        }\n\t\t        this.onData(chunk, this.currentLevel);\n\t\t        return node.isOpen = true;\n\t\t      }\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.closeNode = function(node) {\n\t\t      var chunk;\n\t\t      if (!node.isClosed) {\n\t\t        chunk = '';\n\t\t        this.writerOptions.state = WriterState.CloseTag;\n\t\t        if (node.type === NodeType.Element) {\n\t\t          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n\t\t        } else {\n\t\t          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n\t\t        }\n\t\t        this.writerOptions.state = WriterState.None;\n\t\t        this.onData(chunk, this.currentLevel);\n\t\t        return node.isClosed = true;\n\t\t      }\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.onData = function(chunk, level) {\n\t\t      this.documentStarted = true;\n\t\t      return this.onDataCallback(chunk, level + 1);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.onEnd = function() {\n\t\t      this.documentCompleted = true;\n\t\t      return this.onEndCallback();\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.debugInfo = function(name) {\n\t\t      if (name == null) {\n\t\t        return \"\";\n\t\t      } else {\n\t\t        return \"node: <\" + name + \">\";\n\t\t      }\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.ele = function() {\n\t\t      return this.element.apply(this, arguments);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.nod = function(name, attributes, text) {\n\t\t      return this.node(name, attributes, text);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.txt = function(value) {\n\t\t      return this.text(value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.dat = function(value) {\n\t\t      return this.cdata(value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.com = function(value) {\n\t\t      return this.comment(value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.ins = function(target, value) {\n\t\t      return this.instruction(target, value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {\n\t\t      return this.declaration(version, encoding, standalone);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {\n\t\t      return this.doctype(root, pubID, sysID);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.e = function(name, attributes, text) {\n\t\t      return this.element(name, attributes, text);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.n = function(name, attributes, text) {\n\t\t      return this.node(name, attributes, text);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.t = function(value) {\n\t\t      return this.text(value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.d = function(value) {\n\t\t      return this.cdata(value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.c = function(value) {\n\t\t      return this.comment(value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.r = function(value) {\n\t\t      return this.raw(value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.i = function(target, value) {\n\t\t      return this.instruction(target, value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.att = function() {\n\t\t      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n\t\t        return this.attList.apply(this, arguments);\n\t\t      } else {\n\t\t        return this.attribute.apply(this, arguments);\n\t\t      }\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.a = function() {\n\t\t      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n\t\t        return this.attList.apply(this, arguments);\n\t\t      } else {\n\t\t        return this.attribute.apply(this, arguments);\n\t\t      }\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.ent = function(name, value) {\n\t\t      return this.entity(name, value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.pent = function(name, value) {\n\t\t      return this.pEntity(name, value);\n\t\t    };\n\n\t\t    XMLDocumentCB.prototype.not = function(name, value) {\n\t\t      return this.notation(name, value);\n\t\t    };\n\n\t\t    return XMLDocumentCB;\n\n\t\t  })();\n\n\t\t}).call(XMLDocumentCB);\n\t\treturn XMLDocumentCB$1.exports;\n\t}\n\n\tvar XMLStreamWriter$1 = {exports: {}};\n\n\tvar XMLStreamWriter = XMLStreamWriter$1.exports;\n\n\tvar hasRequiredXMLStreamWriter;\n\n\tfunction requireXMLStreamWriter () {\n\t\tif (hasRequiredXMLStreamWriter) return XMLStreamWriter$1.exports;\n\t\thasRequiredXMLStreamWriter = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, WriterState, XMLWriterBase,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  XMLWriterBase = requireXMLWriterBase();\n\n\t\t  WriterState = requireWriterState();\n\n\t\t  XMLStreamWriter$1.exports = (function(superClass) {\n\t\t    extend(XMLStreamWriter, superClass);\n\n\t\t    function XMLStreamWriter(stream, options) {\n\t\t      this.stream = stream;\n\t\t      XMLStreamWriter.__super__.constructor.call(this, options);\n\t\t    }\n\n\t\t    XMLStreamWriter.prototype.endline = function(node, options, level) {\n\t\t      if (node.isLastRootNode && options.state === WriterState.CloseTag) {\n\t\t        return '';\n\t\t      } else {\n\t\t        return XMLStreamWriter.__super__.endline.call(this, node, options, level);\n\t\t      }\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.document = function(doc, options) {\n\t\t      var child, i, j, k, len, len1, ref, ref1, results;\n\t\t      ref = doc.children;\n\t\t      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n\t\t        child = ref[i];\n\t\t        child.isLastRootNode = i === doc.children.length - 1;\n\t\t      }\n\t\t      options = this.filterOptions(options);\n\t\t      ref1 = doc.children;\n\t\t      results = [];\n\t\t      for (k = 0, len1 = ref1.length; k < len1; k++) {\n\t\t        child = ref1[k];\n\t\t        results.push(this.writeChildNode(child, options, 0));\n\t\t      }\n\t\t      return results;\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.attribute = function(att, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.cdata = function(node, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.comment = function(node, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.declaration = function(node, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.docType = function(node, options, level) {\n\t\t      var child, j, len, ref;\n\t\t      level || (level = 0);\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      this.stream.write(this.indent(node, options, level));\n\t\t      this.stream.write('<!DOCTYPE ' + node.root().name);\n\t\t      if (node.pubID && node.sysID) {\n\t\t        this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n\t\t      } else if (node.sysID) {\n\t\t        this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n\t\t      }\n\t\t      if (node.children.length > 0) {\n\t\t        this.stream.write(' [');\n\t\t        this.stream.write(this.endline(node, options, level));\n\t\t        options.state = WriterState.InsideTag;\n\t\t        ref = node.children;\n\t\t        for (j = 0, len = ref.length; j < len; j++) {\n\t\t          child = ref[j];\n\t\t          this.writeChildNode(child, options, level + 1);\n\t\t        }\n\t\t        options.state = WriterState.CloseTag;\n\t\t        this.stream.write(']');\n\t\t      }\n\t\t      options.state = WriterState.CloseTag;\n\t\t      this.stream.write(options.spaceBeforeSlash + '>');\n\t\t      this.stream.write(this.endline(node, options, level));\n\t\t      options.state = WriterState.None;\n\t\t      return this.closeNode(node, options, level);\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.element = function(node, options, level) {\n\t\t      var att, child, childNodeCount, firstChildNode, j, len, name, ref, ref1;\n\t\t      level || (level = 0);\n\t\t      this.openNode(node, options, level);\n\t\t      options.state = WriterState.OpenTag;\n\t\t      this.stream.write(this.indent(node, options, level) + '<' + node.name);\n\t\t      ref = node.attribs;\n\t\t      for (name in ref) {\n\t\t        if (!hasProp.call(ref, name)) continue;\n\t\t        att = ref[name];\n\t\t        this.attribute(att, options, level);\n\t\t      }\n\t\t      childNodeCount = node.children.length;\n\t\t      firstChildNode = childNodeCount === 0 ? null : node.children[0];\n\t\t      if (childNodeCount === 0 || node.children.every(function(e) {\n\t\t        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n\t\t      })) {\n\t\t        if (options.allowEmpty) {\n\t\t          this.stream.write('>');\n\t\t          options.state = WriterState.CloseTag;\n\t\t          this.stream.write('</' + node.name + '>');\n\t\t        } else {\n\t\t          options.state = WriterState.CloseTag;\n\t\t          this.stream.write(options.spaceBeforeSlash + '/>');\n\t\t        }\n\t\t      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {\n\t\t        this.stream.write('>');\n\t\t        options.state = WriterState.InsideTag;\n\t\t        options.suppressPrettyCount++;\n\t\t        this.writeChildNode(firstChildNode, options, level + 1);\n\t\t        options.suppressPrettyCount--;\n\t\t        options.state = WriterState.CloseTag;\n\t\t        this.stream.write('</' + node.name + '>');\n\t\t      } else {\n\t\t        this.stream.write('>' + this.endline(node, options, level));\n\t\t        options.state = WriterState.InsideTag;\n\t\t        ref1 = node.children;\n\t\t        for (j = 0, len = ref1.length; j < len; j++) {\n\t\t          child = ref1[j];\n\t\t          this.writeChildNode(child, options, level + 1);\n\t\t        }\n\t\t        options.state = WriterState.CloseTag;\n\t\t        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');\n\t\t      }\n\t\t      this.stream.write(this.endline(node, options, level));\n\t\t      options.state = WriterState.None;\n\t\t      return this.closeNode(node, options, level);\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.raw = function(node, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.text = function(node, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.dtdElement = function(node, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));\n\t\t    };\n\n\t\t    XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {\n\t\t      return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));\n\t\t    };\n\n\t\t    return XMLStreamWriter;\n\n\t\t  })(XMLWriterBase);\n\n\t\t}).call(XMLStreamWriter);\n\t\treturn XMLStreamWriter$1.exports;\n\t}\n\n\tvar hasRequiredLib;\n\n\tfunction requireLib () {\n\t\tif (hasRequiredLib) return lib;\n\t\thasRequiredLib = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;\n\n\t\t  ref = requireUtility(), assign = ref.assign, isFunction = ref.isFunction;\n\n\t\t  XMLDOMImplementation = requireXMLDOMImplementation();\n\n\t\t  XMLDocument = requireXMLDocument();\n\n\t\t  XMLDocumentCB = requireXMLDocumentCB();\n\n\t\t  XMLStringWriter = requireXMLStringWriter();\n\n\t\t  XMLStreamWriter = requireXMLStreamWriter();\n\n\t\t  NodeType = requireNodeType();\n\n\t\t  WriterState = requireWriterState();\n\n\t\t  lib.create = function(name, xmldec, doctype, options) {\n\t\t    var doc, root;\n\t\t    if (name == null) {\n\t\t      throw new Error(\"Root element needs a name.\");\n\t\t    }\n\t\t    options = assign({}, xmldec, doctype, options);\n\t\t    doc = new XMLDocument(options);\n\t\t    root = doc.element(name);\n\t\t    if (!options.headless) {\n\t\t      doc.declaration(options);\n\t\t      if ((options.pubID != null) || (options.sysID != null)) {\n\t\t        doc.dtd(options);\n\t\t      }\n\t\t    }\n\t\t    return root;\n\t\t  };\n\n\t\t  lib.begin = function(options, onData, onEnd) {\n\t\t    var ref1;\n\t\t    if (isFunction(options)) {\n\t\t      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];\n\t\t      options = {};\n\t\t    }\n\t\t    if (onData) {\n\t\t      return new XMLDocumentCB(options, onData, onEnd);\n\t\t    } else {\n\t\t      return new XMLDocument(options);\n\t\t    }\n\t\t  };\n\n\t\t  lib.stringWriter = function(options) {\n\t\t    return new XMLStringWriter(options);\n\t\t  };\n\n\t\t  lib.streamWriter = function(stream, options) {\n\t\t    return new XMLStreamWriter(stream, options);\n\t\t  };\n\n\t\t  lib.implementation = new XMLDOMImplementation();\n\n\t\t  lib.nodeType = NodeType;\n\n\t\t  lib.writerState = WriterState;\n\n\t\t}).call(lib);\n\t\treturn lib;\n\t}\n\n\tvar hasRequiredBuilder;\n\n\tfunction requireBuilder () {\n\t\tif (hasRequiredBuilder) return builder;\n\t\thasRequiredBuilder = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var builder$1, defaults, escapeCDATA, requiresCDATA, wrapCDATA,\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  builder$1 = requireLib();\n\n\t\t  defaults = requireDefaults().defaults;\n\n\t\t  requiresCDATA = function(entry) {\n\t\t    return typeof entry === \"string\" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);\n\t\t  };\n\n\t\t  wrapCDATA = function(entry) {\n\t\t    return \"<![CDATA[\" + (escapeCDATA(entry)) + \"]]>\";\n\t\t  };\n\n\t\t  escapeCDATA = function(entry) {\n\t\t    return entry.replace(']]>', ']]]]><![CDATA[>');\n\t\t  };\n\n\t\t  builder.Builder = (function() {\n\t\t    function Builder(opts) {\n\t\t      var key, ref, value;\n\t\t      this.options = {};\n\t\t      ref = defaults[\"0.2\"];\n\t\t      for (key in ref) {\n\t\t        if (!hasProp.call(ref, key)) continue;\n\t\t        value = ref[key];\n\t\t        this.options[key] = value;\n\t\t      }\n\t\t      for (key in opts) {\n\t\t        if (!hasProp.call(opts, key)) continue;\n\t\t        value = opts[key];\n\t\t        this.options[key] = value;\n\t\t      }\n\t\t    }\n\n\t\t    Builder.prototype.buildObject = function(rootObj) {\n\t\t      var attrkey, charkey, render, rootElement, rootName;\n\t\t      attrkey = this.options.attrkey;\n\t\t      charkey = this.options.charkey;\n\t\t      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {\n\t\t        rootName = Object.keys(rootObj)[0];\n\t\t        rootObj = rootObj[rootName];\n\t\t      } else {\n\t\t        rootName = this.options.rootName;\n\t\t      }\n\t\t      render = (function(_this) {\n\t\t        return function(element, obj) {\n\t\t          var attr, child, entry, index, key, value;\n\t\t          if (typeof obj !== 'object') {\n\t\t            if (_this.options.cdata && requiresCDATA(obj)) {\n\t\t              element.raw(wrapCDATA(obj));\n\t\t            } else {\n\t\t              element.txt(obj);\n\t\t            }\n\t\t          } else if (Array.isArray(obj)) {\n\t\t            for (index in obj) {\n\t\t              if (!hasProp.call(obj, index)) continue;\n\t\t              child = obj[index];\n\t\t              for (key in child) {\n\t\t                entry = child[key];\n\t\t                element = render(element.ele(key), entry).up();\n\t\t              }\n\t\t            }\n\t\t          } else {\n\t\t            for (key in obj) {\n\t\t              if (!hasProp.call(obj, key)) continue;\n\t\t              child = obj[key];\n\t\t              if (key === attrkey) {\n\t\t                if (typeof child === \"object\") {\n\t\t                  for (attr in child) {\n\t\t                    value = child[attr];\n\t\t                    element = element.att(attr, value);\n\t\t                  }\n\t\t                }\n\t\t              } else if (key === charkey) {\n\t\t                if (_this.options.cdata && requiresCDATA(child)) {\n\t\t                  element = element.raw(wrapCDATA(child));\n\t\t                } else {\n\t\t                  element = element.txt(child);\n\t\t                }\n\t\t              } else if (Array.isArray(child)) {\n\t\t                for (index in child) {\n\t\t                  if (!hasProp.call(child, index)) continue;\n\t\t                  entry = child[index];\n\t\t                  if (typeof entry === 'string') {\n\t\t                    if (_this.options.cdata && requiresCDATA(entry)) {\n\t\t                      element = element.ele(key).raw(wrapCDATA(entry)).up();\n\t\t                    } else {\n\t\t                      element = element.ele(key, entry).up();\n\t\t                    }\n\t\t                  } else {\n\t\t                    element = render(element.ele(key), entry).up();\n\t\t                  }\n\t\t                }\n\t\t              } else if (typeof child === \"object\") {\n\t\t                element = render(element.ele(key), child).up();\n\t\t              } else {\n\t\t                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {\n\t\t                  element = element.ele(key).raw(wrapCDATA(child)).up();\n\t\t                } else {\n\t\t                  if (child == null) {\n\t\t                    child = '';\n\t\t                  }\n\t\t                  element = element.ele(key, child.toString()).up();\n\t\t                }\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t          return element;\n\t\t        };\n\t\t      })(this);\n\t\t      rootElement = builder$1.create(rootName, this.options.xmldec, this.options.doctype, {\n\t\t        headless: this.options.headless,\n\t\t        allowSurrogateChars: this.options.allowSurrogateChars\n\t\t      });\n\t\t      return render(rootElement, rootObj).end(this.options.renderOpts);\n\t\t    };\n\n\t\t    return Builder;\n\n\t\t  })();\n\n\t\t}).call(builder);\n\t\treturn builder;\n\t}\n\n\tvar parser = {};\n\n\tvar global$1 = (typeof global !== \"undefined\" ? global :\n\t  typeof self !== \"undefined\" ? self :\n\t  typeof window !== \"undefined\" ? window : {});\n\n\tvar lookup = [];\n\tvar revLookup = [];\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\tvar inited = false;\n\tfunction init () {\n\t  inited = true;\n\t  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t  for (var i = 0, len = code.length; i < len; ++i) {\n\t    lookup[i] = code[i];\n\t    revLookup[code.charCodeAt(i)] = i;\n\t  }\n\n\t  revLookup['-'.charCodeAt(0)] = 62;\n\t  revLookup['_'.charCodeAt(0)] = 63;\n\t}\n\n\tfunction toByteArray (b64) {\n\t  if (!inited) {\n\t    init();\n\t  }\n\t  var i, j, l, tmp, placeHolders, arr;\n\t  var len = b64.length;\n\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  arr = new Arr(len * 3 / 4 - placeHolders);\n\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len;\n\n\t  var L = 0;\n\n\t  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];\n\t    arr[L++] = (tmp >> 16) & 0xFF;\n\t    arr[L++] = (tmp >> 8) & 0xFF;\n\t    arr[L++] = tmp & 0xFF;\n\t  }\n\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n\t    arr[L++] = tmp & 0xFF;\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);\n\t    arr[L++] = (tmp >> 8) & 0xFF;\n\t    arr[L++] = tmp & 0xFF;\n\t  }\n\n\t  return arr\n\t}\n\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp;\n\t  var output = [];\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t    output.push(tripletToBase64(tmp));\n\t  }\n\t  return output.join('')\n\t}\n\n\tfunction fromByteArray (uint8) {\n\t  if (!inited) {\n\t    init();\n\t  }\n\t  var tmp;\n\t  var len = uint8.length;\n\t  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\t  var output = '';\n\t  var parts = [];\n\t  var maxChunkLength = 16383; // must be multiple of 3\n\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n\t  }\n\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1];\n\t    output += lookup[tmp >> 2];\n\t    output += lookup[(tmp << 4) & 0x3F];\n\t    output += '==';\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);\n\t    output += lookup[tmp >> 10];\n\t    output += lookup[(tmp >> 4) & 0x3F];\n\t    output += lookup[(tmp << 2) & 0x3F];\n\t    output += '=';\n\t  }\n\n\t  parts.push(output);\n\n\t  return parts.join('')\n\t}\n\n\tfunction read (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m;\n\t  var eLen = nBytes * 8 - mLen - 1;\n\t  var eMax = (1 << eLen) - 1;\n\t  var eBias = eMax >> 1;\n\t  var nBits = -7;\n\t  var i = isLE ? (nBytes - 1) : 0;\n\t  var d = isLE ? -1 : 1;\n\t  var s = buffer[offset + i];\n\n\t  i += d;\n\n\t  e = s & ((1 << (-nBits)) - 1);\n\t  s >>= (-nBits);\n\t  nBits += eLen;\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n\t  m = e & ((1 << (-nBits)) - 1);\n\t  e >>= (-nBits);\n\t  nBits += mLen;\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n\t  if (e === 0) {\n\t    e = 1 - eBias;\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen);\n\t    e = e - eBias;\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\n\tfunction write (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c;\n\t  var eLen = nBytes * 8 - mLen - 1;\n\t  var eMax = (1 << eLen) - 1;\n\t  var eBias = eMax >> 1;\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n\t  var i = isLE ? 0 : (nBytes - 1);\n\t  var d = isLE ? 1 : -1;\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n\t  value = Math.abs(value);\n\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0;\n\t    e = eMax;\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2);\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--;\n\t      c *= 2;\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c;\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias);\n\t    }\n\t    if (value * c >= 2) {\n\t      e++;\n\t      c /= 2;\n\t    }\n\n\t    if (e + eBias >= eMax) {\n\t      m = 0;\n\t      e = eMax;\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen);\n\t      e = e + eBias;\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n\t      e = 0;\n\t    }\n\t  }\n\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n\t  e = (e << mLen) | m;\n\t  eLen += mLen;\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n\t  buffer[offset + i - d] |= s * 128;\n\t}\n\n\tvar toString = {}.toString;\n\n\tvar isArray$1 = Array.isArray || function (arr) {\n\t  return toString.call(arr) == '[object Array]';\n\t};\n\n\t/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\n\n\tvar INSPECT_MAX_BYTES = 50;\n\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global$1.TYPED_ARRAY_SUPPORT\n\t  : true;\n\n\t/*\n\t * Export kMaxLength after typed array support is determined.\n\t */\n\tkMaxLength();\n\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\n\tfunction createBuffer (that, length) {\n\t  if (kMaxLength() < length) {\n\t    throw new RangeError('Invalid typed array length')\n\t  }\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = new Uint8Array(length);\n\t    that.__proto__ = Buffer.prototype;\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    if (that === null) {\n\t      that = new Buffer(length);\n\t    }\n\t    that.length = length;\n\t  }\n\n\t  return that\n\t}\n\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n\t    return new Buffer(arg, encodingOrOffset, length)\n\t  }\n\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new Error(\n\t        'If encoding is specified then the first argument must be a string'\n\t      )\n\t    }\n\t    return allocUnsafe(this, arg)\n\t  }\n\t  return from(this, arg, encodingOrOffset, length)\n\t}\n\n\tBuffer.poolSize = 8192; // not used by this implementation\n\n\t// TODO: Legacy, not needed anymore. Remove in next major version.\n\tBuffer._augment = function (arr) {\n\t  arr.__proto__ = Buffer.prototype;\n\t  return arr\n\t};\n\n\tfunction from (that, value, encodingOrOffset, length) {\n\t  if (typeof value === 'number') {\n\t    throw new TypeError('\"value\" argument must not be a number')\n\t  }\n\n\t  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n\t    return fromArrayBuffer(that, value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof value === 'string') {\n\t    return fromString(that, value, encodingOrOffset)\n\t  }\n\n\t  return fromObject(that, value)\n\t}\n\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(null, value, encodingOrOffset, length)\n\t};\n\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype;\n\t  Buffer.__proto__ = Uint8Array;\n\t  if (typeof Symbol !== 'undefined' && Symbol.species &&\n\t      Buffer[Symbol.species] === Buffer) ;\n\t}\n\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be a number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('\"size\" argument must not be negative')\n\t  }\n\t}\n\n\tfunction alloc (that, size, fill, encoding) {\n\t  assertSize(size);\n\t  if (size <= 0) {\n\t    return createBuffer(that, size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpretted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(that, size).fill(fill, encoding)\n\t      : createBuffer(that, size).fill(fill)\n\t  }\n\t  return createBuffer(that, size)\n\t}\n\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(null, size, fill, encoding)\n\t};\n\n\tfunction allocUnsafe (that, size) {\n\t  assertSize(size);\n\t  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < size; ++i) {\n\t      that[i] = 0;\n\t    }\n\t  }\n\t  return that\n\t}\n\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(null, size)\n\t};\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(null, size)\n\t};\n\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8';\n\t  }\n\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('\"encoding\" must be a valid string encoding')\n\t  }\n\n\t  var length = byteLength(string, encoding) | 0;\n\t  that = createBuffer(that, length);\n\n\t  var actual = that.write(string, encoding);\n\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    that = that.slice(0, actual);\n\t  }\n\n\t  return that\n\t}\n\n\tfunction fromArrayLike (that, array) {\n\t  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n\t  that = createBuffer(that, length);\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255;\n\t  }\n\t  return that\n\t}\n\n\tfunction fromArrayBuffer (that, array, byteOffset, length) {\n\t  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\\'offset\\' is out of bounds')\n\t  }\n\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\\'length\\' is out of bounds')\n\t  }\n\n\t  if (byteOffset === undefined && length === undefined) {\n\t    array = new Uint8Array(array);\n\t  } else if (length === undefined) {\n\t    array = new Uint8Array(array, byteOffset);\n\t  } else {\n\t    array = new Uint8Array(array, byteOffset, length);\n\t  }\n\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = array;\n\t    that.__proto__ = Buffer.prototype;\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromArrayLike(that, array);\n\t  }\n\t  return that\n\t}\n\n\tfunction fromObject (that, obj) {\n\t  if (internalIsBuffer(obj)) {\n\t    var len = checked(obj.length) | 0;\n\t    that = createBuffer(that, len);\n\n\t    if (that.length === 0) {\n\t      return that\n\t    }\n\n\t    obj.copy(that, 0, 0, len);\n\t    return that\n\t  }\n\n\t  if (obj) {\n\t    if ((typeof ArrayBuffer !== 'undefined' &&\n\t        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n\t      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n\t        return createBuffer(that, 0)\n\t      }\n\t      return fromArrayLike(that, obj)\n\t    }\n\n\t    if (obj.type === 'Buffer' && isArray$1(obj.data)) {\n\t      return fromArrayLike(that, obj.data)\n\t    }\n\t  }\n\n\t  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n\t}\n\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength()` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\tBuffer.isBuffer = isBuffer;\n\tfunction internalIsBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\n\tBuffer.compare = function compare (a, b) {\n\t  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\n\t  if (a === b) return 0\n\n\t  var x = a.length;\n\t  var y = b.length;\n\n\t  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i];\n\t      y = b[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t};\n\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray$1(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\n\t  var i;\n\t  if (length === undefined) {\n\t    length = 0;\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length;\n\t    }\n\t  }\n\n\t  var buffer = Buffer.allocUnsafe(length);\n\t  var pos = 0;\n\t  for (i = 0; i < list.length; ++i) {\n\t    var buf = list[i];\n\t    if (!internalIsBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    }\n\t    buf.copy(buffer, pos);\n\t    pos += buf.length;\n\t  }\n\t  return buffer\n\t};\n\n\tfunction byteLength (string, encoding) {\n\t  if (internalIsBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n\t      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    string = '' + string;\n\t  }\n\n\t  var len = string.length;\n\t  if (len === 0) return 0\n\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t      case undefined:\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength;\n\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false;\n\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0;\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length;\n\t  }\n\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\n\t  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0;\n\t  start >>>= 0;\n\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\n\t// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n\t// Buffer instances.\n\tBuffer.prototype._isBuffer = true;\n\n\tfunction swap (b, n, m) {\n\t  var i = b[n];\n\t  b[n] = b[m];\n\t  b[m] = i;\n\t}\n\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  var len = this.length;\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  var len = this.length;\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3);\n\t    swap(this, i + 1, i + 2);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  var len = this.length;\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (var i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7);\n\t    swap(this, i + 1, i + 6);\n\t    swap(this, i + 2, i + 5);\n\t    swap(this, i + 3, i + 4);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0;\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t};\n\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t};\n\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = '';\n\t  var max = INSPECT_MAX_BYTES;\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n\t    if (this.length > max) str += ' ... ';\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t};\n\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (!internalIsBuffer(target)) {\n\t    throw new TypeError('Argument must be a Buffer')\n\t  }\n\n\t  if (start === undefined) {\n\t    start = 0;\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0;\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0;\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length;\n\t  }\n\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\n\t  start >>>= 0;\n\t  end >>>= 0;\n\t  thisStart >>>= 0;\n\t  thisEnd >>>= 0;\n\n\t  if (this === target) return 0\n\n\t  var x = thisEnd - thisStart;\n\t  var y = end - start;\n\t  var len = Math.min(x, y);\n\n\t  var thisCopy = this.slice(thisStart, thisEnd);\n\t  var targetCopy = target.slice(start, end);\n\n\t  for (var i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i];\n\t      y = targetCopy[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset;\n\t    byteOffset = 0;\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff;\n\t  } else if (byteOffset < -2147483648) {\n\t    byteOffset = -2147483648;\n\t  }\n\t  byteOffset = +byteOffset;  // Coerce to Number.\n\t  if (isNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1);\n\t  }\n\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1;\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0;\n\t    else return -1\n\t  }\n\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding);\n\t  }\n\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (internalIsBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF; // Search for a byte value [0-255]\n\t    if (Buffer.TYPED_ARRAY_SUPPORT &&\n\t        typeof Uint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n\t  }\n\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  var indexSize = 1;\n\t  var arrLength = arr.length;\n\t  var valLength = val.length;\n\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase();\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2;\n\t      arrLength /= 2;\n\t      valLength /= 2;\n\t      byteOffset /= 2;\n\t    }\n\t  }\n\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\n\t  var i;\n\t  if (dir) {\n\t    var foundIndex = -1;\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i;\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex;\n\t        foundIndex = -1;\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      var found = true;\n\t      for (var j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false;\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t};\n\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t};\n\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t};\n\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0;\n\t  var remaining = buf.length - offset;\n\t  if (!length) {\n\t    length = remaining;\n\t  } else {\n\t    length = Number(length);\n\t    if (length > remaining) {\n\t      length = remaining;\n\t    }\n\t  }\n\n\t  // must be an even number of digits\n\t  var strLen = string.length;\n\t  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2;\n\t  }\n\t  for (var i = 0; i < length; ++i) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16);\n\t    if (isNaN(parsed)) return i\n\t    buf[offset + i] = parsed;\n\t  }\n\t  return i\n\t}\n\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\n\tfunction latin1Write (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8';\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset;\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0;\n\t    if (isFinite(length)) {\n\t      length = length | 0;\n\t      if (encoding === undefined) encoding = 'utf8';\n\t    } else {\n\t      encoding = length;\n\t      length = undefined;\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\n\t  var remaining = this.length - offset;\n\t  if (length === undefined || length > remaining) length = remaining;\n\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  var loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Write(this, string, offset, length)\n\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t};\n\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t};\n\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return fromByteArray(buf)\n\t  } else {\n\t    return fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end);\n\t  var res = [];\n\n\t  var i = start;\n\t  while (i < end) {\n\t    var firstByte = buf[i];\n\t    var codePoint = null;\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1;\n\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte;\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1];\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          fourthByte = buf[i + 3];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t      }\n\t    }\n\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD;\n\t      bytesPerSequence = 1;\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000;\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n\t      codePoint = 0xDC00 | codePoint & 0x3FF;\n\t    }\n\n\t    res.push(codePoint);\n\t    i += bytesPerSequence;\n\t  }\n\n\t  return decodeCodePointsArray(res)\n\t}\n\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length;\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = '';\n\t  var i = 0;\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    );\n\t  }\n\t  return res\n\t}\n\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F);\n\t  }\n\t  return ret\n\t}\n\n\tfunction latin1Slice (buf, start, end) {\n\t  var ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (var i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i]);\n\t  }\n\t  return ret\n\t}\n\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length;\n\n\t  if (!start || start < 0) start = 0;\n\t  if (!end || end < 0 || end > len) end = len;\n\n\t  var out = '';\n\t  for (var i = start; i < end; ++i) {\n\t    out += toHex(buf[i]);\n\t  }\n\t  return out\n\t}\n\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end);\n\t  var res = '';\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n\t  }\n\t  return res\n\t}\n\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length;\n\t  start = ~~start;\n\t  end = end === undefined ? len : ~~end;\n\n\t  if (start < 0) {\n\t    start += len;\n\t    if (start < 0) start = 0;\n\t  } else if (start > len) {\n\t    start = len;\n\t  }\n\n\t  if (end < 0) {\n\t    end += len;\n\t    if (end < 0) end = 0;\n\t  } else if (end > len) {\n\t    end = len;\n\t  }\n\n\t  if (end < start) end = start;\n\n\t  var newBuf;\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = this.subarray(start, end);\n\t    newBuf.__proto__ = Buffer.prototype;\n\t  } else {\n\t    var sliceLen = end - start;\n\t    newBuf = new Buffer(sliceLen, undefined);\n\t    for (var i = 0; i < sliceLen; ++i) {\n\t      newBuf[i] = this[i + start];\n\t    }\n\t  }\n\n\t  return newBuf\n\t};\n\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  var val = this[offset];\n\t  var mul = 1;\n\t  var i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length);\n\t  }\n\n\t  var val = this[offset + --byteLength];\n\t  var mul = 1;\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  return this[offset]\n\t};\n\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return this[offset] | (this[offset + 1] << 8)\n\t};\n\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return (this[offset] << 8) | this[offset + 1]\n\t};\n\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t};\n\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t};\n\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  var val = this[offset];\n\t  var mul = 1;\n\t  var i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  var i = byteLength;\n\t  var mul = 1;\n\t  var val = this[offset + --i];\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t};\n\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  var val = this[offset] | (this[offset + 1] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  var val = this[offset + 1] | (this[offset] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t};\n\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t};\n\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return read(this, offset, true, 23, 4)\n\t};\n\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return read(this, offset, false, 23, 4)\n\t};\n\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return read(this, offset, true, 52, 8)\n\t};\n\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return read(this, offset, false, 52, 8)\n\t};\n\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  var mul = 1;\n\t  var i = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  byteLength = byteLength | 0;\n\t  if (!noAssert) {\n\t    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  var i = byteLength - 1;\n\t  var mul = 1;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1;\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8;\n\t  }\n\t}\n\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff);\n\t    this[offset + 1] = (value >>> 8);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true);\n\t  }\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8);\n\t    this[offset + 1] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false);\n\t  }\n\t  return offset + 2\n\t};\n\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;\n\t  }\n\t}\n\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24);\n\t    this[offset + 2] = (value >>> 16);\n\t    this[offset + 1] = (value >>> 8);\n\t    this[offset] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true);\n\t  }\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24);\n\t    this[offset + 1] = (value >>> 16);\n\t    this[offset + 2] = (value >>> 8);\n\t    this[offset + 3] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false);\n\t  }\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  var i = 0;\n\t  var mul = 1;\n\t  var sub = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  var i = byteLength - 1;\n\t  var mul = 1;\n\t  var sub = 0;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n\t  if (value < 0) value = 0xff + value + 1;\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff);\n\t    this[offset + 1] = (value >>> 8);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true);\n\t  }\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8);\n\t    this[offset + 1] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false);\n\t  }\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff);\n\t    this[offset + 1] = (value >>> 8);\n\t    this[offset + 2] = (value >>> 16);\n\t    this[offset + 3] = (value >>> 24);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true);\n\t  }\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset | 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24);\n\t    this[offset + 1] = (value >>> 16);\n\t    this[offset + 2] = (value >>> 8);\n\t    this[offset + 3] = (value & 0xff);\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false);\n\t  }\n\t  return offset + 4\n\t};\n\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4);\n\t  }\n\t  write(buf, value, offset, littleEndian, 23, 4);\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t};\n\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8);\n\t  }\n\t  write(buf, value, offset, littleEndian, 52, 8);\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t};\n\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0;\n\t  if (!end && end !== 0) end = this.length;\n\t  if (targetStart >= target.length) targetStart = target.length;\n\t  if (!targetStart) targetStart = 0;\n\t  if (end > 0 && end < start) end = start;\n\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length;\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start;\n\t  }\n\n\t  var len = end - start;\n\t  var i;\n\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; --i) {\n\t      target[i + targetStart] = this[i + start];\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; ++i) {\n\t      target[i + targetStart] = this[i + start];\n\t    }\n\t  } else {\n\t    Uint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, start + len),\n\t      targetStart\n\t    );\n\t  }\n\n\t  return len\n\t};\n\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start;\n\t      start = 0;\n\t      end = this.length;\n\t    } else if (typeof end === 'string') {\n\t      encoding = end;\n\t      end = this.length;\n\t    }\n\t    if (val.length === 1) {\n\t      var code = val.charCodeAt(0);\n\t      if (code < 256) {\n\t        val = code;\n\t      }\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255;\n\t  }\n\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (end <= start) {\n\t    return this\n\t  }\n\n\t  start = start >>> 0;\n\t  end = end === undefined ? this.length : end >>> 0;\n\n\t  if (!val) val = 0;\n\n\t  var i;\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val;\n\t    }\n\t  } else {\n\t    var bytes = internalIsBuffer(val)\n\t      ? val\n\t      : utf8ToBytes(new Buffer(val, encoding).toString());\n\t    var len = bytes.length;\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len];\n\t    }\n\t  }\n\n\t  return this\n\t};\n\n\t// HELPER FUNCTIONS\n\t// ================\n\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '=';\n\t  }\n\t  return str\n\t}\n\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity;\n\t  var codePoint;\n\t  var length = string.length;\n\t  var leadSurrogate = null;\n\t  var bytes = [];\n\n\t  for (var i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i);\n\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        }\n\n\t        // valid lead\n\t        leadSurrogate = codePoint;\n\n\t        continue\n\t      }\n\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t        leadSurrogate = codePoint;\n\t        continue\n\t      }\n\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t    }\n\n\t    leadSurrogate = null;\n\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint);\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\n\t  return bytes\n\t}\n\n\tfunction asciiToBytes (str) {\n\t  var byteArray = [];\n\t  for (var i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF);\n\t  }\n\t  return byteArray\n\t}\n\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo;\n\t  var byteArray = [];\n\t  for (var i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\n\t    c = str.charCodeAt(i);\n\t    hi = c >> 8;\n\t    lo = c % 256;\n\t    byteArray.push(lo);\n\t    byteArray.push(hi);\n\t  }\n\n\t  return byteArray\n\t}\n\n\n\tfunction base64ToBytes (str) {\n\t  return toByteArray(base64clean(str))\n\t}\n\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i];\n\t  }\n\t  return i\n\t}\n\n\tfunction isnan (val) {\n\t  return val !== val // eslint-disable-line no-self-compare\n\t}\n\n\n\t// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n\t// The _isBuffer check is for Safari 5-7 support, because it's missing\n\t// Object.prototype.constructor. Remove this eventually\n\tfunction isBuffer(obj) {\n\t  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n\t}\n\n\tfunction isFastBuffer (obj) {\n\t  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n\t}\n\n\t// For Node v0.10 support. Remove this eventually.\n\tfunction isSlowBuffer (obj) {\n\t  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n\t}\n\n\tvar sax = {};\n\n\tvar domain;\n\n\t// This constructor is used to store event handlers. Instantiating this is\n\t// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n\t// object (tested with v8 v4.9).\n\tfunction EventHandlers() {}\n\tEventHandlers.prototype = Object.create(null);\n\n\tfunction EventEmitter() {\n\t  EventEmitter.init.call(this);\n\t}\n\n\t// nodejs oddity\n\t// require('events') === require('events').EventEmitter\n\tEventEmitter.EventEmitter = EventEmitter;\n\n\tEventEmitter.usingDomains = false;\n\n\tEventEmitter.prototype.domain = undefined;\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\n\tEventEmitter.init = function() {\n\t  this.domain = null;\n\t  if (EventEmitter.usingDomains) {\n\t    // if there is an active domain, then attach to it.\n\t    if (domain.active) ;\n\t  }\n\n\t  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n\t    this._events = new EventHandlers();\n\t    this._eventsCount = 0;\n\t  }\n\n\t  this._maxListeners = this._maxListeners || undefined;\n\t};\n\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n\t  if (typeof n !== 'number' || n < 0 || isNaN(n))\n\t    throw new TypeError('\"n\" argument must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\n\tfunction $getMaxListeners(that) {\n\t  if (that._maxListeners === undefined)\n\t    return EventEmitter.defaultMaxListeners;\n\t  return that._maxListeners;\n\t}\n\n\tEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n\t  return $getMaxListeners(this);\n\t};\n\n\t// These standalone emit* functions are used to optimize calling of event\n\t// handlers for fast cases because emit() itself often has a variable number of\n\t// arguments and can be deoptimized because of that. These functions always have\n\t// the same number of arguments and thus do not get deoptimized, so the code\n\t// inside them can execute faster.\n\tfunction emitNone(handler, isFn, self) {\n\t  if (isFn)\n\t    handler.call(self);\n\t  else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i)\n\t      listeners[i].call(self);\n\t  }\n\t}\n\tfunction emitOne(handler, isFn, self, arg1) {\n\t  if (isFn)\n\t    handler.call(self, arg1);\n\t  else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i)\n\t      listeners[i].call(self, arg1);\n\t  }\n\t}\n\tfunction emitTwo(handler, isFn, self, arg1, arg2) {\n\t  if (isFn)\n\t    handler.call(self, arg1, arg2);\n\t  else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i)\n\t      listeners[i].call(self, arg1, arg2);\n\t  }\n\t}\n\tfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n\t  if (isFn)\n\t    handler.call(self, arg1, arg2, arg3);\n\t  else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i)\n\t      listeners[i].call(self, arg1, arg2, arg3);\n\t  }\n\t}\n\n\tfunction emitMany(handler, isFn, self, args) {\n\t  if (isFn)\n\t    handler.apply(self, args);\n\t  else {\n\t    var len = handler.length;\n\t    var listeners = arrayClone(handler, len);\n\t    for (var i = 0; i < len; ++i)\n\t      listeners[i].apply(self, args);\n\t  }\n\t}\n\n\tEventEmitter.prototype.emit = function emit(type) {\n\t  var er, handler, len, args, i, events, domain;\n\t  var doError = (type === 'error');\n\n\t  events = this._events;\n\t  if (events)\n\t    doError = (doError && events.error == null);\n\t  else if (!doError)\n\t    return false;\n\n\t  domain = this.domain;\n\n\t  // If there is no 'error' event listener then throw.\n\t  if (doError) {\n\t    er = arguments[1];\n\t    if (domain) {\n\t      if (!er)\n\t        er = new Error('Uncaught, unspecified \"error\" event');\n\t      er.domainEmitter = this;\n\t      er.domain = domain;\n\t      er.domainThrown = false;\n\t      domain.emit('error', er);\n\t    } else if (er instanceof Error) {\n\t      throw er; // Unhandled 'error' event\n\t    } else {\n\t      // At least give some kind of context to the user\n\t      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t      err.context = er;\n\t      throw err;\n\t    }\n\t    return false;\n\t  }\n\n\t  handler = events[type];\n\n\t  if (!handler)\n\t    return false;\n\n\t  var isFn = typeof handler === 'function';\n\t  len = arguments.length;\n\t  switch (len) {\n\t    // fast cases\n\t    case 1:\n\t      emitNone(handler, isFn, this);\n\t      break;\n\t    case 2:\n\t      emitOne(handler, isFn, this, arguments[1]);\n\t      break;\n\t    case 3:\n\t      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n\t      break;\n\t    case 4:\n\t      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n\t      break;\n\t    // slower\n\t    default:\n\t      args = new Array(len - 1);\n\t      for (i = 1; i < len; i++)\n\t        args[i - 1] = arguments[i];\n\t      emitMany(handler, isFn, this, args);\n\t  }\n\n\t  return true;\n\t};\n\n\tfunction _addListener(target, type, listener, prepend) {\n\t  var m;\n\t  var events;\n\t  var existing;\n\n\t  if (typeof listener !== 'function')\n\t    throw new TypeError('\"listener\" argument must be a function');\n\n\t  events = target._events;\n\t  if (!events) {\n\t    events = target._events = new EventHandlers();\n\t    target._eventsCount = 0;\n\t  } else {\n\t    // To avoid recursion in the case that type === \"newListener\"! Before\n\t    // adding it to the listeners, first emit \"newListener\".\n\t    if (events.newListener) {\n\t      target.emit('newListener', type,\n\t                  listener.listener ? listener.listener : listener);\n\n\t      // Re-assign `events` because a newListener handler could have caused the\n\t      // this._events to be assigned to a new object\n\t      events = target._events;\n\t    }\n\t    existing = events[type];\n\t  }\n\n\t  if (!existing) {\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    existing = events[type] = listener;\n\t    ++target._eventsCount;\n\t  } else {\n\t    if (typeof existing === 'function') {\n\t      // Adding the second element, need to change to array.\n\t      existing = events[type] = prepend ? [listener, existing] :\n\t                                          [existing, listener];\n\t    } else {\n\t      // If we've already got an array, just append.\n\t      if (prepend) {\n\t        existing.unshift(listener);\n\t      } else {\n\t        existing.push(listener);\n\t      }\n\t    }\n\n\t    // Check for listener leak\n\t    if (!existing.warned) {\n\t      m = $getMaxListeners(target);\n\t      if (m && m > 0 && existing.length > m) {\n\t        existing.warned = true;\n\t        var w = new Error('Possible EventEmitter memory leak detected. ' +\n\t                            existing.length + ' ' + type + ' listeners added. ' +\n\t                            'Use emitter.setMaxListeners() to increase limit');\n\t        w.name = 'MaxListenersExceededWarning';\n\t        w.emitter = target;\n\t        w.type = type;\n\t        w.count = existing.length;\n\t        emitWarning(w);\n\t      }\n\t    }\n\t  }\n\n\t  return target;\n\t}\n\tfunction emitWarning(e) {\n\t  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n\t}\n\tEventEmitter.prototype.addListener = function addListener(type, listener) {\n\t  return _addListener(this, type, listener, false);\n\t};\n\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n\tEventEmitter.prototype.prependListener =\n\t    function prependListener(type, listener) {\n\t      return _addListener(this, type, listener, true);\n\t    };\n\n\tfunction _onceWrap(target, type, listener) {\n\t  var fired = false;\n\t  function g() {\n\t    target.removeListener(type, g);\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(target, arguments);\n\t    }\n\t  }\n\t  g.listener = listener;\n\t  return g;\n\t}\n\n\tEventEmitter.prototype.once = function once(type, listener) {\n\t  if (typeof listener !== 'function')\n\t    throw new TypeError('\"listener\" argument must be a function');\n\t  this.on(type, _onceWrap(this, type, listener));\n\t  return this;\n\t};\n\n\tEventEmitter.prototype.prependOnceListener =\n\t    function prependOnceListener(type, listener) {\n\t      if (typeof listener !== 'function')\n\t        throw new TypeError('\"listener\" argument must be a function');\n\t      this.prependListener(type, _onceWrap(this, type, listener));\n\t      return this;\n\t    };\n\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener =\n\t    function removeListener(type, listener) {\n\t      var list, events, position, i, originalListener;\n\n\t      if (typeof listener !== 'function')\n\t        throw new TypeError('\"listener\" argument must be a function');\n\n\t      events = this._events;\n\t      if (!events)\n\t        return this;\n\n\t      list = events[type];\n\t      if (!list)\n\t        return this;\n\n\t      if (list === listener || (list.listener && list.listener === listener)) {\n\t        if (--this._eventsCount === 0)\n\t          this._events = new EventHandlers();\n\t        else {\n\t          delete events[type];\n\t          if (events.removeListener)\n\t            this.emit('removeListener', type, list.listener || listener);\n\t        }\n\t      } else if (typeof list !== 'function') {\n\t        position = -1;\n\n\t        for (i = list.length; i-- > 0;) {\n\t          if (list[i] === listener ||\n\t              (list[i].listener && list[i].listener === listener)) {\n\t            originalListener = list[i].listener;\n\t            position = i;\n\t            break;\n\t          }\n\t        }\n\n\t        if (position < 0)\n\t          return this;\n\n\t        if (list.length === 1) {\n\t          list[0] = undefined;\n\t          if (--this._eventsCount === 0) {\n\t            this._events = new EventHandlers();\n\t            return this;\n\t          } else {\n\t            delete events[type];\n\t          }\n\t        } else {\n\t          spliceOne(list, position);\n\t        }\n\n\t        if (events.removeListener)\n\t          this.emit('removeListener', type, originalListener || listener);\n\t      }\n\n\t      return this;\n\t    };\n\t    \n\t// Alias for removeListener added in NodeJS 10.0\n\t// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener\n\tEventEmitter.prototype.off = function(type, listener){\n\t    return this.removeListener(type, listener);\n\t};\n\n\tEventEmitter.prototype.removeAllListeners =\n\t    function removeAllListeners(type) {\n\t      var listeners, events;\n\n\t      events = this._events;\n\t      if (!events)\n\t        return this;\n\n\t      // not listening for removeListener, no need to emit\n\t      if (!events.removeListener) {\n\t        if (arguments.length === 0) {\n\t          this._events = new EventHandlers();\n\t          this._eventsCount = 0;\n\t        } else if (events[type]) {\n\t          if (--this._eventsCount === 0)\n\t            this._events = new EventHandlers();\n\t          else\n\t            delete events[type];\n\t        }\n\t        return this;\n\t      }\n\n\t      // emit removeListener for all listeners on all events\n\t      if (arguments.length === 0) {\n\t        var keys = Object.keys(events);\n\t        for (var i = 0, key; i < keys.length; ++i) {\n\t          key = keys[i];\n\t          if (key === 'removeListener') continue;\n\t          this.removeAllListeners(key);\n\t        }\n\t        this.removeAllListeners('removeListener');\n\t        this._events = new EventHandlers();\n\t        this._eventsCount = 0;\n\t        return this;\n\t      }\n\n\t      listeners = events[type];\n\n\t      if (typeof listeners === 'function') {\n\t        this.removeListener(type, listeners);\n\t      } else if (listeners) {\n\t        // LIFO order\n\t        do {\n\t          this.removeListener(type, listeners[listeners.length - 1]);\n\t        } while (listeners[0]);\n\t      }\n\n\t      return this;\n\t    };\n\n\tEventEmitter.prototype.listeners = function listeners(type) {\n\t  var evlistener;\n\t  var ret;\n\t  var events = this._events;\n\n\t  if (!events)\n\t    ret = [];\n\t  else {\n\t    evlistener = events[type];\n\t    if (!evlistener)\n\t      ret = [];\n\t    else if (typeof evlistener === 'function')\n\t      ret = [evlistener.listener || evlistener];\n\t    else\n\t      ret = unwrapListeners(evlistener);\n\t  }\n\n\t  return ret;\n\t};\n\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  if (typeof emitter.listenerCount === 'function') {\n\t    return emitter.listenerCount(type);\n\t  } else {\n\t    return listenerCount$1.call(emitter, type);\n\t  }\n\t};\n\n\tEventEmitter.prototype.listenerCount = listenerCount$1;\n\tfunction listenerCount$1(type) {\n\t  var events = this._events;\n\n\t  if (events) {\n\t    var evlistener = events[type];\n\n\t    if (typeof evlistener === 'function') {\n\t      return 1;\n\t    } else if (evlistener) {\n\t      return evlistener.length;\n\t    }\n\t  }\n\n\t  return 0;\n\t}\n\n\tEventEmitter.prototype.eventNames = function eventNames() {\n\t  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n\t};\n\n\t// About 1.5x faster than the two-arg version of Array#splice().\n\tfunction spliceOne(list, index) {\n\t  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n\t    list[i] = list[k];\n\t  list.pop();\n\t}\n\n\tfunction arrayClone(arr, i) {\n\t  var copy = new Array(i);\n\t  while (i--)\n\t    copy[i] = arr[i];\n\t  return copy;\n\t}\n\n\tfunction unwrapListeners(arr) {\n\t  var ret = new Array(arr.length);\n\t  for (var i = 0; i < ret.length; ++i) {\n\t    ret[i] = arr[i].listener || arr[i];\n\t  }\n\t  return ret;\n\t}\n\n\tvar _polyfillNode_events = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tEventEmitter: EventEmitter,\n\t\tdefault: EventEmitter\n\t});\n\n\t// shim for using process in browser\n\t// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\n\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\tvar cachedSetTimeout = defaultSetTimout;\n\tvar cachedClearTimeout = defaultClearTimeout;\n\tif (typeof global$1.setTimeout === 'function') {\n\t    cachedSetTimeout = setTimeout;\n\t}\n\tif (typeof global$1.clearTimeout === 'function') {\n\t    cachedClearTimeout = clearTimeout;\n\t}\n\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\n\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\n\n\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\tfunction nextTick(fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t}\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tvar title = 'browser';\n\tvar platform = 'browser';\n\tvar browser = true;\n\tvar env = {};\n\tvar argv = [];\n\tvar version = ''; // empty string to avoid regexp issues\n\tvar versions = {};\n\tvar release = {};\n\tvar config = {};\n\n\tfunction noop() {}\n\n\tvar on = noop;\n\tvar addListener = noop;\n\tvar once = noop;\n\tvar off = noop;\n\tvar removeListener = noop;\n\tvar removeAllListeners = noop;\n\tvar emit = noop;\n\n\tfunction binding(name) {\n\t    throw new Error('process.binding is not supported');\n\t}\n\n\tfunction cwd () { return '/' }\n\tfunction chdir (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t}function umask() { return 0; }\n\n\t// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\n\tvar performance = global$1.performance || {};\n\tvar performanceNow =\n\t  performance.now        ||\n\t  performance.mozNow     ||\n\t  performance.msNow      ||\n\t  performance.oNow       ||\n\t  performance.webkitNow  ||\n\t  function(){ return (new Date()).getTime() };\n\n\t// generate timestamp or delta\n\t// see http://nodejs.org/api/process.html#process_process_hrtime\n\tfunction hrtime(previousTimestamp){\n\t  var clocktime = performanceNow.call(performance)*1e-3;\n\t  var seconds = Math.floor(clocktime);\n\t  var nanoseconds = Math.floor((clocktime%1)*1e9);\n\t  if (previousTimestamp) {\n\t    seconds = seconds - previousTimestamp[0];\n\t    nanoseconds = nanoseconds - previousTimestamp[1];\n\t    if (nanoseconds<0) {\n\t      seconds--;\n\t      nanoseconds += 1e9;\n\t    }\n\t  }\n\t  return [seconds,nanoseconds]\n\t}\n\n\tvar startTime = new Date();\n\tfunction uptime() {\n\t  var currentTime = new Date();\n\t  var dif = currentTime - startTime;\n\t  return dif / 1000;\n\t}\n\n\tvar browser$1 = {\n\t  nextTick: nextTick,\n\t  title: title,\n\t  browser: browser,\n\t  env: env,\n\t  argv: argv,\n\t  version: version,\n\t  versions: versions,\n\t  on: on,\n\t  addListener: addListener,\n\t  once: once,\n\t  off: off,\n\t  removeListener: removeListener,\n\t  removeAllListeners: removeAllListeners,\n\t  emit: emit,\n\t  binding: binding,\n\t  cwd: cwd,\n\t  chdir: chdir,\n\t  umask: umask,\n\t  hrtime: hrtime,\n\t  platform: platform,\n\t  release: release,\n\t  config: config,\n\t  uptime: uptime\n\t};\n\n\tvar inherits;\n\tif (typeof Object.create === 'function'){\n\t  inherits = function inherits(ctor, superCtor) {\n\t    // implementation from standard node.js 'util' module\n\t    ctor.super_ = superCtor;\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  inherits = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    var TempCtor = function () {};\n\t    TempCtor.prototype = superCtor.prototype;\n\t    ctor.prototype = new TempCtor();\n\t    ctor.prototype.constructor = ctor;\n\t  };\n\t}\n\n\tvar formatRegExp = /%[sdj%]/g;\n\tfunction format(f) {\n\t  if (!isString(f)) {\n\t    var objects = [];\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      objects.push(inspect(arguments[i]));\n\t    }\n\t    return objects.join(' ');\n\t  }\n\n\t  var i = 1;\n\t  var args = arguments;\n\t  var len = args.length;\n\t  var str = String(f).replace(formatRegExp, function(x) {\n\t    if (x === '%%') return '%';\n\t    if (i >= len) return x;\n\t    switch (x) {\n\t      case '%s': return String(args[i++]);\n\t      case '%d': return Number(args[i++]);\n\t      case '%j':\n\t        try {\n\t          return JSON.stringify(args[i++]);\n\t        } catch (_) {\n\t          return '[Circular]';\n\t        }\n\t      default:\n\t        return x;\n\t    }\n\t  });\n\t  for (var x = args[i]; i < len; x = args[++i]) {\n\t    if (isNull(x) || !isObject(x)) {\n\t      str += ' ' + x;\n\t    } else {\n\t      str += ' ' + inspect(x);\n\t    }\n\t  }\n\t  return str;\n\t}\n\n\t// Mark that a method should not be used.\n\t// Returns a modified function which warns once by default.\n\t// If --no-deprecation is set, then it is a no-op.\n\tfunction deprecate(fn, msg) {\n\t  // Allow for deprecating things in the process of starting up.\n\t  if (isUndefined(global$1.process)) {\n\t    return function() {\n\t      return deprecate(fn, msg).apply(this, arguments);\n\t    };\n\t  }\n\n\t  if (browser$1.noDeprecation === true) {\n\t    return fn;\n\t  }\n\n\t  var warned = false;\n\t  function deprecated() {\n\t    if (!warned) {\n\t      if (browser$1.throwDeprecation) {\n\t        throw new Error(msg);\n\t      } else if (browser$1.traceDeprecation) {\n\t        console.trace(msg);\n\t      } else {\n\t        console.error(msg);\n\t      }\n\t      warned = true;\n\t    }\n\t    return fn.apply(this, arguments);\n\t  }\n\n\t  return deprecated;\n\t}\n\n\tvar debugs = {};\n\tvar debugEnviron;\n\tfunction debuglog(set) {\n\t  if (isUndefined(debugEnviron))\n\t    debugEnviron = browser$1.env.NODE_DEBUG || '';\n\t  set = set.toUpperCase();\n\t  if (!debugs[set]) {\n\t    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n\t      var pid = 0;\n\t      debugs[set] = function() {\n\t        var msg = format.apply(null, arguments);\n\t        console.error('%s %d: %s', set, pid, msg);\n\t      };\n\t    } else {\n\t      debugs[set] = function() {};\n\t    }\n\t  }\n\t  return debugs[set];\n\t}\n\n\t/**\n\t * Echos the value of a value. Trys to print the value out\n\t * in the best way possible given the different types.\n\t *\n\t * @param {Object} obj The object to print out.\n\t * @param {Object} opts Optional options object that alters the output.\n\t */\n\t/* legacy: obj, showHidden, depth, colors*/\n\tfunction inspect(obj, opts) {\n\t  // default options\n\t  var ctx = {\n\t    seen: [],\n\t    stylize: stylizeNoColor\n\t  };\n\t  // legacy...\n\t  if (arguments.length >= 3) ctx.depth = arguments[2];\n\t  if (arguments.length >= 4) ctx.colors = arguments[3];\n\t  if (isBoolean(opts)) {\n\t    // legacy...\n\t    ctx.showHidden = opts;\n\t  } else if (opts) {\n\t    // got an \"options\" object\n\t    _extend(ctx, opts);\n\t  }\n\t  // set default options\n\t  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n\t  if (isUndefined(ctx.depth)) ctx.depth = 2;\n\t  if (isUndefined(ctx.colors)) ctx.colors = false;\n\t  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n\t  if (ctx.colors) ctx.stylize = stylizeWithColor;\n\t  return formatValue(ctx, obj, ctx.depth);\n\t}\n\n\t// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\tinspect.colors = {\n\t  'bold' : [1, 22],\n\t  'italic' : [3, 23],\n\t  'underline' : [4, 24],\n\t  'inverse' : [7, 27],\n\t  'white' : [37, 39],\n\t  'grey' : [90, 39],\n\t  'black' : [30, 39],\n\t  'blue' : [34, 39],\n\t  'cyan' : [36, 39],\n\t  'green' : [32, 39],\n\t  'magenta' : [35, 39],\n\t  'red' : [31, 39],\n\t  'yellow' : [33, 39]\n\t};\n\n\t// Don't use 'blue' not visible on cmd.exe\n\tinspect.styles = {\n\t  'special': 'cyan',\n\t  'number': 'yellow',\n\t  'boolean': 'yellow',\n\t  'undefined': 'grey',\n\t  'null': 'bold',\n\t  'string': 'green',\n\t  'date': 'magenta',\n\t  // \"name\": intentionally not styling\n\t  'regexp': 'red'\n\t};\n\n\n\tfunction stylizeWithColor(str, styleType) {\n\t  var style = inspect.styles[styleType];\n\n\t  if (style) {\n\t    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n\t           '\\u001b[' + inspect.colors[style][1] + 'm';\n\t  } else {\n\t    return str;\n\t  }\n\t}\n\n\n\tfunction stylizeNoColor(str, styleType) {\n\t  return str;\n\t}\n\n\n\tfunction arrayToHash(array) {\n\t  var hash = {};\n\n\t  array.forEach(function(val, idx) {\n\t    hash[val] = true;\n\t  });\n\n\t  return hash;\n\t}\n\n\n\tfunction formatValue(ctx, value, recurseTimes) {\n\t  // Provide a hook for user-specified inspect functions.\n\t  // Check that value is an object with an inspect function on it\n\t  if (ctx.customInspect &&\n\t      value &&\n\t      isFunction(value.inspect) &&\n\t      // Filter out the util module, it's inspect function is special\n\t      value.inspect !== inspect &&\n\t      // Also filter out any prototype objects using the circular check.\n\t      !(value.constructor && value.constructor.prototype === value)) {\n\t    var ret = value.inspect(recurseTimes, ctx);\n\t    if (!isString(ret)) {\n\t      ret = formatValue(ctx, ret, recurseTimes);\n\t    }\n\t    return ret;\n\t  }\n\n\t  // Primitive types cannot have properties\n\t  var primitive = formatPrimitive(ctx, value);\n\t  if (primitive) {\n\t    return primitive;\n\t  }\n\n\t  // Look up the keys of the object.\n\t  var keys = Object.keys(value);\n\t  var visibleKeys = arrayToHash(keys);\n\n\t  if (ctx.showHidden) {\n\t    keys = Object.getOwnPropertyNames(value);\n\t  }\n\n\t  // IE doesn't make error fields non-enumerable\n\t  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\t  if (isError(value)\n\t      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n\t    return formatError(value);\n\t  }\n\n\t  // Some type of object without properties can be shortcutted.\n\t  if (keys.length === 0) {\n\t    if (isFunction(value)) {\n\t      var name = value.name ? ': ' + value.name : '';\n\t      return ctx.stylize('[Function' + name + ']', 'special');\n\t    }\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    }\n\t    if (isDate(value)) {\n\t      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n\t    }\n\t    if (isError(value)) {\n\t      return formatError(value);\n\t    }\n\t  }\n\n\t  var base = '', array = false, braces = ['{', '}'];\n\n\t  // Make Array say that they are Array\n\t  if (isArray(value)) {\n\t    array = true;\n\t    braces = ['[', ']'];\n\t  }\n\n\t  // Make functions say that they are functions\n\t  if (isFunction(value)) {\n\t    var n = value.name ? ': ' + value.name : '';\n\t    base = ' [Function' + n + ']';\n\t  }\n\n\t  // Make RegExps say that they are RegExps\n\t  if (isRegExp(value)) {\n\t    base = ' ' + RegExp.prototype.toString.call(value);\n\t  }\n\n\t  // Make dates with properties first say the date\n\t  if (isDate(value)) {\n\t    base = ' ' + Date.prototype.toUTCString.call(value);\n\t  }\n\n\t  // Make error with message first say the error\n\t  if (isError(value)) {\n\t    base = ' ' + formatError(value);\n\t  }\n\n\t  if (keys.length === 0 && (!array || value.length == 0)) {\n\t    return braces[0] + base + braces[1];\n\t  }\n\n\t  if (recurseTimes < 0) {\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    } else {\n\t      return ctx.stylize('[Object]', 'special');\n\t    }\n\t  }\n\n\t  ctx.seen.push(value);\n\n\t  var output;\n\t  if (array) {\n\t    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n\t  } else {\n\t    output = keys.map(function(key) {\n\t      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n\t    });\n\t  }\n\n\t  ctx.seen.pop();\n\n\t  return reduceToSingleString(output, base, braces);\n\t}\n\n\n\tfunction formatPrimitive(ctx, value) {\n\t  if (isUndefined(value))\n\t    return ctx.stylize('undefined', 'undefined');\n\t  if (isString(value)) {\n\t    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n\t                                             .replace(/'/g, \"\\\\'\")\n\t                                             .replace(/\\\\\"/g, '\"') + '\\'';\n\t    return ctx.stylize(simple, 'string');\n\t  }\n\t  if (isNumber(value))\n\t    return ctx.stylize('' + value, 'number');\n\t  if (isBoolean(value))\n\t    return ctx.stylize('' + value, 'boolean');\n\t  // For some reason typeof null is \"object\", so special case here.\n\t  if (isNull(value))\n\t    return ctx.stylize('null', 'null');\n\t}\n\n\n\tfunction formatError(value) {\n\t  return '[' + Error.prototype.toString.call(value) + ']';\n\t}\n\n\n\tfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n\t  var output = [];\n\t  for (var i = 0, l = value.length; i < l; ++i) {\n\t    if (hasOwnProperty(value, String(i))) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          String(i), true));\n\t    } else {\n\t      output.push('');\n\t    }\n\t  }\n\t  keys.forEach(function(key) {\n\t    if (!key.match(/^\\d+$/)) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          key, true));\n\t    }\n\t  });\n\t  return output;\n\t}\n\n\n\tfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n\t  var name, str, desc;\n\t  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n\t  if (desc.get) {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Getter/Setter]', 'special');\n\t    } else {\n\t      str = ctx.stylize('[Getter]', 'special');\n\t    }\n\t  } else {\n\t    if (desc.set) {\n\t      str = ctx.stylize('[Setter]', 'special');\n\t    }\n\t  }\n\t  if (!hasOwnProperty(visibleKeys, key)) {\n\t    name = '[' + key + ']';\n\t  }\n\t  if (!str) {\n\t    if (ctx.seen.indexOf(desc.value) < 0) {\n\t      if (isNull(recurseTimes)) {\n\t        str = formatValue(ctx, desc.value, null);\n\t      } else {\n\t        str = formatValue(ctx, desc.value, recurseTimes - 1);\n\t      }\n\t      if (str.indexOf('\\n') > -1) {\n\t        if (array) {\n\t          str = str.split('\\n').map(function(line) {\n\t            return '  ' + line;\n\t          }).join('\\n').substr(2);\n\t        } else {\n\t          str = '\\n' + str.split('\\n').map(function(line) {\n\t            return '   ' + line;\n\t          }).join('\\n');\n\t        }\n\t      }\n\t    } else {\n\t      str = ctx.stylize('[Circular]', 'special');\n\t    }\n\t  }\n\t  if (isUndefined(name)) {\n\t    if (array && key.match(/^\\d+$/)) {\n\t      return str;\n\t    }\n\t    name = JSON.stringify('' + key);\n\t    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n\t      name = name.substr(1, name.length - 2);\n\t      name = ctx.stylize(name, 'name');\n\t    } else {\n\t      name = name.replace(/'/g, \"\\\\'\")\n\t                 .replace(/\\\\\"/g, '\"')\n\t                 .replace(/(^\"|\"$)/g, \"'\");\n\t      name = ctx.stylize(name, 'string');\n\t    }\n\t  }\n\n\t  return name + ': ' + str;\n\t}\n\n\n\tfunction reduceToSingleString(output, base, braces) {\n\t  var length = output.reduce(function(prev, cur) {\n\t    if (cur.indexOf('\\n') >= 0) ;\n\t    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n\t  }, 0);\n\n\t  if (length > 60) {\n\t    return braces[0] +\n\t           (base === '' ? '' : base + '\\n ') +\n\t           ' ' +\n\t           output.join(',\\n  ') +\n\t           ' ' +\n\t           braces[1];\n\t  }\n\n\t  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n\t}\n\n\n\t// NOTE: These type checking functions intentionally don't use `instanceof`\n\t// because it is fragile and can be easily faked with `Object.create()`.\n\tfunction isArray(ar) {\n\t  return Array.isArray(ar);\n\t}\n\n\tfunction isBoolean(arg) {\n\t  return typeof arg === 'boolean';\n\t}\n\n\tfunction isNull(arg) {\n\t  return arg === null;\n\t}\n\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\n\tfunction isString(arg) {\n\t  return typeof arg === 'string';\n\t}\n\n\tfunction isUndefined(arg) {\n\t  return arg === undefined;\n\t}\n\n\tfunction isRegExp(re) {\n\t  return isObject(re) && objectToString(re) === '[object RegExp]';\n\t}\n\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\n\tfunction isDate(d) {\n\t  return isObject(d) && objectToString(d) === '[object Date]';\n\t}\n\n\tfunction isError(e) {\n\t  return isObject(e) &&\n\t      (objectToString(e) === '[object Error]' || e instanceof Error);\n\t}\n\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\n\tfunction objectToString(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\n\tfunction _extend(origin, add) {\n\t  // Don't do anything if add isn't an object\n\t  if (!add || !isObject(add)) return origin;\n\n\t  var keys = Object.keys(add);\n\t  var i = keys.length;\n\t  while (i--) {\n\t    origin[keys[i]] = add[keys[i]];\n\t  }\n\t  return origin;\n\t}\n\tfunction hasOwnProperty(obj, prop) {\n\t  return Object.prototype.hasOwnProperty.call(obj, prop);\n\t}\n\n\tfunction BufferList() {\n\t  this.head = null;\n\t  this.tail = null;\n\t  this.length = 0;\n\t}\n\n\tBufferList.prototype.push = function (v) {\n\t  var entry = { data: v, next: null };\n\t  if (this.length > 0) this.tail.next = entry;else this.head = entry;\n\t  this.tail = entry;\n\t  ++this.length;\n\t};\n\n\tBufferList.prototype.unshift = function (v) {\n\t  var entry = { data: v, next: this.head };\n\t  if (this.length === 0) this.tail = entry;\n\t  this.head = entry;\n\t  ++this.length;\n\t};\n\n\tBufferList.prototype.shift = function () {\n\t  if (this.length === 0) return;\n\t  var ret = this.head.data;\n\t  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n\t  --this.length;\n\t  return ret;\n\t};\n\n\tBufferList.prototype.clear = function () {\n\t  this.head = this.tail = null;\n\t  this.length = 0;\n\t};\n\n\tBufferList.prototype.join = function (s) {\n\t  if (this.length === 0) return '';\n\t  var p = this.head;\n\t  var ret = '' + p.data;\n\t  while (p = p.next) {\n\t    ret += s + p.data;\n\t  }return ret;\n\t};\n\n\tBufferList.prototype.concat = function (n) {\n\t  if (this.length === 0) return Buffer.alloc(0);\n\t  if (this.length === 1) return this.head.data;\n\t  var ret = Buffer.allocUnsafe(n >>> 0);\n\t  var p = this.head;\n\t  var i = 0;\n\t  while (p) {\n\t    p.data.copy(ret, i);\n\t    i += p.data.length;\n\t    p = p.next;\n\t  }\n\t  return ret;\n\t};\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\tvar isBufferEncoding = Buffer.isEncoding\n\t  || function(encoding) {\n\t       switch (encoding && encoding.toLowerCase()) {\n\t         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n\t         default: return false;\n\t       }\n\t     };\n\n\n\tfunction assertEncoding(encoding) {\n\t  if (encoding && !isBufferEncoding(encoding)) {\n\t    throw new Error('Unknown encoding: ' + encoding);\n\t  }\n\t}\n\n\t// StringDecoder provides an interface for efficiently splitting a series of\n\t// buffers into a series of JS strings without breaking apart multi-byte\n\t// characters. CESU-8 is handled as part of the UTF-8 encoding.\n\t//\n\t// @TODO Handling all encodings inside a single object makes it very difficult\n\t// to reason about this code, so it should be split up in the future.\n\t// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n\t// points as used by CESU-8.\n\tfunction StringDecoder(encoding) {\n\t  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n\t  assertEncoding(encoding);\n\t  switch (this.encoding) {\n\t    case 'utf8':\n\t      // CESU-8 represents each of Surrogate Pair by 3-bytes\n\t      this.surrogateSize = 3;\n\t      break;\n\t    case 'ucs2':\n\t    case 'utf16le':\n\t      // UTF-16 represents each of Surrogate Pair by 2-bytes\n\t      this.surrogateSize = 2;\n\t      this.detectIncompleteChar = utf16DetectIncompleteChar;\n\t      break;\n\t    case 'base64':\n\t      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n\t      this.surrogateSize = 3;\n\t      this.detectIncompleteChar = base64DetectIncompleteChar;\n\t      break;\n\t    default:\n\t      this.write = passThroughWrite;\n\t      return;\n\t  }\n\n\t  // Enough space to store all bytes of a single character. UTF-8 needs 4\n\t  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n\t  this.charBuffer = new Buffer(6);\n\t  // Number of bytes received for the current incomplete multi-byte character.\n\t  this.charReceived = 0;\n\t  // Number of bytes expected for the current incomplete multi-byte character.\n\t  this.charLength = 0;\n\t}\n\n\t// write decodes the given buffer and returns it as JS string that is\n\t// guaranteed to not contain any partial multi-byte characters. Any partial\n\t// character found at the end of the buffer is buffered up, and will be\n\t// returned when calling write again with the remaining bytes.\n\t//\n\t// Note: Converting a Buffer containing an orphan surrogate to a String\n\t// currently works, but converting a String to a Buffer (via `new Buffer`, or\n\t// Buffer#write) will replace incomplete surrogates with the unicode\n\t// replacement character. See https://codereview.chromium.org/121173009/ .\n\tStringDecoder.prototype.write = function(buffer) {\n\t  var charStr = '';\n\t  // if our last write ended with an incomplete multibyte character\n\t  while (this.charLength) {\n\t    // determine how many remaining bytes this buffer has to offer for this char\n\t    var available = (buffer.length >= this.charLength - this.charReceived) ?\n\t        this.charLength - this.charReceived :\n\t        buffer.length;\n\n\t    // add the new bytes to the char buffer\n\t    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n\t    this.charReceived += available;\n\n\t    if (this.charReceived < this.charLength) {\n\t      // still not enough chars in this buffer? wait for more ...\n\t      return '';\n\t    }\n\n\t    // remove bytes belonging to the current character from the buffer\n\t    buffer = buffer.slice(available, buffer.length);\n\n\t    // get the character that was split\n\t    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n\t    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\t    var charCode = charStr.charCodeAt(charStr.length - 1);\n\t    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n\t      this.charLength += this.surrogateSize;\n\t      charStr = '';\n\t      continue;\n\t    }\n\t    this.charReceived = this.charLength = 0;\n\n\t    // if there are no more bytes in this buffer, just emit our char\n\t    if (buffer.length === 0) {\n\t      return charStr;\n\t    }\n\t    break;\n\t  }\n\n\t  // determine and set charLength / charReceived\n\t  this.detectIncompleteChar(buffer);\n\n\t  var end = buffer.length;\n\t  if (this.charLength) {\n\t    // buffer the incomplete character bytes we got\n\t    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n\t    end -= this.charReceived;\n\t  }\n\n\t  charStr += buffer.toString(this.encoding, 0, end);\n\n\t  var end = charStr.length - 1;\n\t  var charCode = charStr.charCodeAt(end);\n\t  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n\t  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n\t    var size = this.surrogateSize;\n\t    this.charLength += size;\n\t    this.charReceived += size;\n\t    this.charBuffer.copy(this.charBuffer, size, 0, size);\n\t    buffer.copy(this.charBuffer, 0, 0, size);\n\t    return charStr.substring(0, end);\n\t  }\n\n\t  // or just emit the charStr\n\t  return charStr;\n\t};\n\n\t// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n\t// the end of the given buffer. If so, it sets this.charLength to the byte\n\t// length that character, and sets this.charReceived to the number of bytes\n\t// that are available for this character.\n\tStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n\t  // determine how many bytes we have to check at the end of this buffer\n\t  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n\t  // Figure out if one of the last i bytes of our buffer announces an\n\t  // incomplete char.\n\t  for (; i > 0; i--) {\n\t    var c = buffer[buffer.length - i];\n\n\t    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n\t    // 110XXXXX\n\t    if (i == 1 && c >> 5 == 0x06) {\n\t      this.charLength = 2;\n\t      break;\n\t    }\n\n\t    // 1110XXXX\n\t    if (i <= 2 && c >> 4 == 0x0E) {\n\t      this.charLength = 3;\n\t      break;\n\t    }\n\n\t    // 11110XXX\n\t    if (i <= 3 && c >> 3 == 0x1E) {\n\t      this.charLength = 4;\n\t      break;\n\t    }\n\t  }\n\t  this.charReceived = i;\n\t};\n\n\tStringDecoder.prototype.end = function(buffer) {\n\t  var res = '';\n\t  if (buffer && buffer.length)\n\t    res = this.write(buffer);\n\n\t  if (this.charReceived) {\n\t    var cr = this.charReceived;\n\t    var buf = this.charBuffer;\n\t    var enc = this.encoding;\n\t    res += buf.slice(0, cr).toString(enc);\n\t  }\n\n\t  return res;\n\t};\n\n\tfunction passThroughWrite(buffer) {\n\t  return buffer.toString(this.encoding);\n\t}\n\n\tfunction utf16DetectIncompleteChar(buffer) {\n\t  this.charReceived = buffer.length % 2;\n\t  this.charLength = this.charReceived ? 2 : 0;\n\t}\n\n\tfunction base64DetectIncompleteChar(buffer) {\n\t  this.charReceived = buffer.length % 3;\n\t  this.charLength = this.charReceived ? 3 : 0;\n\t}\n\n\tvar _polyfillNode_string_decoder = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tStringDecoder: StringDecoder\n\t});\n\n\tReadable.ReadableState = ReadableState;\n\n\tvar debug = debuglog('stream');\n\tinherits(Readable, EventEmitter);\n\n\tfunction prependListener(emitter, event, fn) {\n\t  // Sadly this is not cacheable as some libraries bundle their own\n\t  // event emitter implementation with them.\n\t  if (typeof emitter.prependListener === 'function') {\n\t    return emitter.prependListener(event, fn);\n\t  } else {\n\t    // This is a hack to make sure that our error handler is attached before any\n\t    // userland ones.  NEVER DO THIS. This is here only because this code needs\n\t    // to continue to work with older versions of Node.js that do not include\n\t    // the prependListener() method. The goal is to eventually remove this hack.\n\t    if (!emitter._events || !emitter._events[event])\n\t      emitter.on(event, fn);\n\t    else if (Array.isArray(emitter._events[event]))\n\t      emitter._events[event].unshift(fn);\n\t    else\n\t      emitter._events[event] = [fn, emitter._events[event]];\n\t  }\n\t}\n\tfunction listenerCount (emitter, type) {\n\t  return emitter.listeners(type).length;\n\t}\n\tfunction ReadableState(options, stream) {\n\n\t  options = options || {};\n\n\t  // object stream flag. Used to make read(n) ignore n and to\n\t  // make all the buffer merging and length checks go away\n\t  this.objectMode = !!options.objectMode;\n\n\t  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n\t  // the point at which it stops calling _read() to fill the buffer\n\t  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\t  var hwm = options.highWaterMark;\n\t  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\t  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n\t  // cast to ints.\n\t  this.highWaterMark = ~ ~this.highWaterMark;\n\n\t  // A linked list is used to store data chunks instead of an array because the\n\t  // linked list can remove elements from the beginning faster than\n\t  // array.shift()\n\t  this.buffer = new BufferList();\n\t  this.length = 0;\n\t  this.pipes = null;\n\t  this.pipesCount = 0;\n\t  this.flowing = null;\n\t  this.ended = false;\n\t  this.endEmitted = false;\n\t  this.reading = false;\n\n\t  // a flag to be able to tell if the onwrite cb is called immediately,\n\t  // or on a later tick.  We set this to true at first, because any\n\t  // actions that shouldn't happen until \"later\" should generally also\n\t  // not happen before the first write call.\n\t  this.sync = true;\n\n\t  // whenever we return null, then we set a flag to say\n\t  // that we're awaiting a 'readable' event emission.\n\t  this.needReadable = false;\n\t  this.emittedReadable = false;\n\t  this.readableListening = false;\n\t  this.resumeScheduled = false;\n\n\t  // Crypto is kind of old and crusty.  Historically, its default string\n\t  // encoding is 'binary' so we have to make this configurable.\n\t  // Everything else in the universe uses 'utf8', though.\n\t  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n\t  // when piping, we only care about 'readable' events that happen\n\t  // after read()ing all the bytes and not getting any pushback.\n\t  this.ranOut = false;\n\n\t  // the number of writers that are awaiting a drain event in .pipe()s\n\t  this.awaitDrain = 0;\n\n\t  // if true, a maybeReadMore has been scheduled\n\t  this.readingMore = false;\n\n\t  this.decoder = null;\n\t  this.encoding = null;\n\t  if (options.encoding) {\n\t    this.decoder = new StringDecoder(options.encoding);\n\t    this.encoding = options.encoding;\n\t  }\n\t}\n\tfunction Readable(options) {\n\n\t  if (!(this instanceof Readable)) return new Readable(options);\n\n\t  this._readableState = new ReadableState(options, this);\n\n\t  // legacy\n\t  this.readable = true;\n\n\t  if (options && typeof options.read === 'function') this._read = options.read;\n\n\t  EventEmitter.call(this);\n\t}\n\n\t// Manually shove something into the read() buffer.\n\t// This returns true if the highWaterMark has not been hit yet,\n\t// similar to how Writable.write() returns true if you should\n\t// write() some more.\n\tReadable.prototype.push = function (chunk, encoding) {\n\t  var state = this._readableState;\n\n\t  if (!state.objectMode && typeof chunk === 'string') {\n\t    encoding = encoding || state.defaultEncoding;\n\t    if (encoding !== state.encoding) {\n\t      chunk = Buffer.from(chunk, encoding);\n\t      encoding = '';\n\t    }\n\t  }\n\n\t  return readableAddChunk(this, state, chunk, encoding, false);\n\t};\n\n\t// Unshift should *always* be something directly out of read()\n\tReadable.prototype.unshift = function (chunk) {\n\t  var state = this._readableState;\n\t  return readableAddChunk(this, state, chunk, '', true);\n\t};\n\n\tReadable.prototype.isPaused = function () {\n\t  return this._readableState.flowing === false;\n\t};\n\n\tfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n\t  var er = chunkInvalid(state, chunk);\n\t  if (er) {\n\t    stream.emit('error', er);\n\t  } else if (chunk === null) {\n\t    state.reading = false;\n\t    onEofChunk(stream, state);\n\t  } else if (state.objectMode || chunk && chunk.length > 0) {\n\t    if (state.ended && !addToFront) {\n\t      var e = new Error('stream.push() after EOF');\n\t      stream.emit('error', e);\n\t    } else if (state.endEmitted && addToFront) {\n\t      var _e = new Error('stream.unshift() after end event');\n\t      stream.emit('error', _e);\n\t    } else {\n\t      var skipAdd;\n\t      if (state.decoder && !addToFront && !encoding) {\n\t        chunk = state.decoder.write(chunk);\n\t        skipAdd = !state.objectMode && chunk.length === 0;\n\t      }\n\n\t      if (!addToFront) state.reading = false;\n\n\t      // Don't add to the buffer if we've decoded to an empty string chunk and\n\t      // we're not in object mode\n\t      if (!skipAdd) {\n\t        // if we want the data now, just emit it.\n\t        if (state.flowing && state.length === 0 && !state.sync) {\n\t          stream.emit('data', chunk);\n\t          stream.read(0);\n\t        } else {\n\t          // update the buffer info.\n\t          state.length += state.objectMode ? 1 : chunk.length;\n\t          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n\t          if (state.needReadable) emitReadable(stream);\n\t        }\n\t      }\n\n\t      maybeReadMore(stream, state);\n\t    }\n\t  } else if (!addToFront) {\n\t    state.reading = false;\n\t  }\n\n\t  return needMoreData(state);\n\t}\n\n\t// if it's past the high water mark, we can push in some more.\n\t// Also, if we have no data yet, we can stand some\n\t// more bytes.  This is to work around cases where hwm=0,\n\t// such as the repl.  Also, if the push() triggered a\n\t// readable event, and the user called read(largeNumber) such that\n\t// needReadable was set, then we ought to push more, so that another\n\t// 'readable' event will be triggered.\n\tfunction needMoreData(state) {\n\t  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n\t}\n\n\t// backwards compatibility.\n\tReadable.prototype.setEncoding = function (enc) {\n\t  this._readableState.decoder = new StringDecoder(enc);\n\t  this._readableState.encoding = enc;\n\t  return this;\n\t};\n\n\t// Don't raise the hwm > 8MB\n\tvar MAX_HWM = 0x800000;\n\tfunction computeNewHighWaterMark(n) {\n\t  if (n >= MAX_HWM) {\n\t    n = MAX_HWM;\n\t  } else {\n\t    // Get the next highest power of 2 to prevent increasing hwm excessively in\n\t    // tiny amounts\n\t    n--;\n\t    n |= n >>> 1;\n\t    n |= n >>> 2;\n\t    n |= n >>> 4;\n\t    n |= n >>> 8;\n\t    n |= n >>> 16;\n\t    n++;\n\t  }\n\t  return n;\n\t}\n\n\t// This function is designed to be inlinable, so please take care when making\n\t// changes to the function body.\n\tfunction howMuchToRead(n, state) {\n\t  if (n <= 0 || state.length === 0 && state.ended) return 0;\n\t  if (state.objectMode) return 1;\n\t  if (n !== n) {\n\t    // Only flow one buffer at a time\n\t    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n\t  }\n\t  // If we're asking for more than the current hwm, then raise the hwm.\n\t  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\t  if (n <= state.length) return n;\n\t  // Don't have enough\n\t  if (!state.ended) {\n\t    state.needReadable = true;\n\t    return 0;\n\t  }\n\t  return state.length;\n\t}\n\n\t// you can override either this method, or the async _read(n) below.\n\tReadable.prototype.read = function (n) {\n\t  debug('read', n);\n\t  n = parseInt(n, 10);\n\t  var state = this._readableState;\n\t  var nOrig = n;\n\n\t  if (n !== 0) state.emittedReadable = false;\n\n\t  // if we're doing read(0) to trigger a readable event, but we\n\t  // already have a bunch of data in the buffer, then just trigger\n\t  // the 'readable' event and move on.\n\t  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n\t    debug('read: emitReadable', state.length, state.ended);\n\t    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n\t    return null;\n\t  }\n\n\t  n = howMuchToRead(n, state);\n\n\t  // if we've ended, and we're now clear, then finish it up.\n\t  if (n === 0 && state.ended) {\n\t    if (state.length === 0) endReadable(this);\n\t    return null;\n\t  }\n\n\t  // All the actual chunk generation logic needs to be\n\t  // *below* the call to _read.  The reason is that in certain\n\t  // synthetic stream cases, such as passthrough streams, _read\n\t  // may be a completely synchronous operation which may change\n\t  // the state of the read buffer, providing enough data when\n\t  // before there was *not* enough.\n\t  //\n\t  // So, the steps are:\n\t  // 1. Figure out what the state of things will be after we do\n\t  // a read from the buffer.\n\t  //\n\t  // 2. If that resulting state will trigger a _read, then call _read.\n\t  // Note that this may be asynchronous, or synchronous.  Yes, it is\n\t  // deeply ugly to write APIs this way, but that still doesn't mean\n\t  // that the Readable class should behave improperly, as streams are\n\t  // designed to be sync/async agnostic.\n\t  // Take note if the _read call is sync or async (ie, if the read call\n\t  // has returned yet), so that we know whether or not it's safe to emit\n\t  // 'readable' etc.\n\t  //\n\t  // 3. Actually pull the requested chunks out of the buffer and return.\n\n\t  // if we need a readable event, then we need to do some reading.\n\t  var doRead = state.needReadable;\n\t  debug('need readable', doRead);\n\n\t  // if we currently have less than the highWaterMark, then also read some\n\t  if (state.length === 0 || state.length - n < state.highWaterMark) {\n\t    doRead = true;\n\t    debug('length less than watermark', doRead);\n\t  }\n\n\t  // however, if we've ended, then there's no point, and if we're already\n\t  // reading, then it's unnecessary.\n\t  if (state.ended || state.reading) {\n\t    doRead = false;\n\t    debug('reading or ended', doRead);\n\t  } else if (doRead) {\n\t    debug('do read');\n\t    state.reading = true;\n\t    state.sync = true;\n\t    // if the length is currently zero, then we *need* a readable event.\n\t    if (state.length === 0) state.needReadable = true;\n\t    // call internal read method\n\t    this._read(state.highWaterMark);\n\t    state.sync = false;\n\t    // If _read pushed data synchronously, then `reading` will be false,\n\t    // and we need to re-evaluate how much data we can return to the user.\n\t    if (!state.reading) n = howMuchToRead(nOrig, state);\n\t  }\n\n\t  var ret;\n\t  if (n > 0) ret = fromList(n, state);else ret = null;\n\n\t  if (ret === null) {\n\t    state.needReadable = true;\n\t    n = 0;\n\t  } else {\n\t    state.length -= n;\n\t  }\n\n\t  if (state.length === 0) {\n\t    // If we have nothing in the buffer, then we want to know\n\t    // as soon as we *do* get something into the buffer.\n\t    if (!state.ended) state.needReadable = true;\n\n\t    // If we tried to read() past the EOF, then emit end on the next tick.\n\t    if (nOrig !== n && state.ended) endReadable(this);\n\t  }\n\n\t  if (ret !== null) this.emit('data', ret);\n\n\t  return ret;\n\t};\n\n\tfunction chunkInvalid(state, chunk) {\n\t  var er = null;\n\t  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n\t    er = new TypeError('Invalid non-string/buffer chunk');\n\t  }\n\t  return er;\n\t}\n\n\tfunction onEofChunk(stream, state) {\n\t  if (state.ended) return;\n\t  if (state.decoder) {\n\t    var chunk = state.decoder.end();\n\t    if (chunk && chunk.length) {\n\t      state.buffer.push(chunk);\n\t      state.length += state.objectMode ? 1 : chunk.length;\n\t    }\n\t  }\n\t  state.ended = true;\n\n\t  // emit 'readable' now to make sure it gets picked up.\n\t  emitReadable(stream);\n\t}\n\n\t// Don't emit readable right away in sync mode, because this can trigger\n\t// another read() call => stack overflow.  This way, it might trigger\n\t// a nextTick recursion warning, but that's not so bad.\n\tfunction emitReadable(stream) {\n\t  var state = stream._readableState;\n\t  state.needReadable = false;\n\t  if (!state.emittedReadable) {\n\t    debug('emitReadable', state.flowing);\n\t    state.emittedReadable = true;\n\t    if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);\n\t  }\n\t}\n\n\tfunction emitReadable_(stream) {\n\t  debug('emit readable');\n\t  stream.emit('readable');\n\t  flow(stream);\n\t}\n\n\t// at this point, the user has presumably seen the 'readable' event,\n\t// and called read() to consume some data.  that may have triggered\n\t// in turn another _read(n) call, in which case reading = true if\n\t// it's in progress.\n\t// However, if we're not ended, or reading, and the length < hwm,\n\t// then go ahead and try to read some more preemptively.\n\tfunction maybeReadMore(stream, state) {\n\t  if (!state.readingMore) {\n\t    state.readingMore = true;\n\t    nextTick(maybeReadMore_, stream, state);\n\t  }\n\t}\n\n\tfunction maybeReadMore_(stream, state) {\n\t  var len = state.length;\n\t  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n\t    debug('maybeReadMore read 0');\n\t    stream.read(0);\n\t    if (len === state.length)\n\t      // didn't get any data, stop spinning.\n\t      break;else len = state.length;\n\t  }\n\t  state.readingMore = false;\n\t}\n\n\t// abstract method.  to be overridden in specific implementation classes.\n\t// call cb(er, data) where data is <= n in length.\n\t// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n\t// arbitrary, and perhaps not very meaningful.\n\tReadable.prototype._read = function (n) {\n\t  this.emit('error', new Error('not implemented'));\n\t};\n\n\tReadable.prototype.pipe = function (dest, pipeOpts) {\n\t  var src = this;\n\t  var state = this._readableState;\n\n\t  switch (state.pipesCount) {\n\t    case 0:\n\t      state.pipes = dest;\n\t      break;\n\t    case 1:\n\t      state.pipes = [state.pipes, dest];\n\t      break;\n\t    default:\n\t      state.pipes.push(dest);\n\t      break;\n\t  }\n\t  state.pipesCount += 1;\n\t  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n\t  var doEnd = (!pipeOpts || pipeOpts.end !== false);\n\n\t  var endFn = doEnd ? onend : cleanup;\n\t  if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);\n\n\t  dest.on('unpipe', onunpipe);\n\t  function onunpipe(readable) {\n\t    debug('onunpipe');\n\t    if (readable === src) {\n\t      cleanup();\n\t    }\n\t  }\n\n\t  function onend() {\n\t    debug('onend');\n\t    dest.end();\n\t  }\n\n\t  // when the dest drains, it reduces the awaitDrain counter\n\t  // on the source.  This would be more elegant with a .once()\n\t  // handler in flow(), but adding and removing repeatedly is\n\t  // too slow.\n\t  var ondrain = pipeOnDrain(src);\n\t  dest.on('drain', ondrain);\n\n\t  var cleanedUp = false;\n\t  function cleanup() {\n\t    debug('cleanup');\n\t    // cleanup event handlers once the pipe is broken\n\t    dest.removeListener('close', onclose);\n\t    dest.removeListener('finish', onfinish);\n\t    dest.removeListener('drain', ondrain);\n\t    dest.removeListener('error', onerror);\n\t    dest.removeListener('unpipe', onunpipe);\n\t    src.removeListener('end', onend);\n\t    src.removeListener('end', cleanup);\n\t    src.removeListener('data', ondata);\n\n\t    cleanedUp = true;\n\n\t    // if the reader is waiting for a drain event from this\n\t    // specific writer, then it would cause it to never start\n\t    // flowing again.\n\t    // So, if this is awaiting a drain, then we just call it now.\n\t    // If we don't know, then assume that we are waiting for one.\n\t    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n\t  }\n\n\t  // If the user pushes more data while we're writing to dest then we'll end up\n\t  // in ondata again. However, we only want to increase awaitDrain once because\n\t  // dest will only emit one 'drain' event for the multiple writes.\n\t  // => Introduce a guard on increasing awaitDrain.\n\t  var increasedAwaitDrain = false;\n\t  src.on('data', ondata);\n\t  function ondata(chunk) {\n\t    debug('ondata');\n\t    increasedAwaitDrain = false;\n\t    var ret = dest.write(chunk);\n\t    if (false === ret && !increasedAwaitDrain) {\n\t      // If the user unpiped during `dest.write()`, it is possible\n\t      // to get stuck in a permanently paused state if that write\n\t      // also returned false.\n\t      // => Check whether `dest` is still a piping destination.\n\t      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n\t        debug('false write response, pause', src._readableState.awaitDrain);\n\t        src._readableState.awaitDrain++;\n\t        increasedAwaitDrain = true;\n\t      }\n\t      src.pause();\n\t    }\n\t  }\n\n\t  // if the dest has an error, then stop piping into it.\n\t  // however, don't suppress the throwing behavior for this.\n\t  function onerror(er) {\n\t    debug('onerror', er);\n\t    unpipe();\n\t    dest.removeListener('error', onerror);\n\t    if (listenerCount(dest, 'error') === 0) dest.emit('error', er);\n\t  }\n\n\t  // Make sure our error handler is attached before userland ones.\n\t  prependListener(dest, 'error', onerror);\n\n\t  // Both close and finish should trigger unpipe, but only once.\n\t  function onclose() {\n\t    dest.removeListener('finish', onfinish);\n\t    unpipe();\n\t  }\n\t  dest.once('close', onclose);\n\t  function onfinish() {\n\t    debug('onfinish');\n\t    dest.removeListener('close', onclose);\n\t    unpipe();\n\t  }\n\t  dest.once('finish', onfinish);\n\n\t  function unpipe() {\n\t    debug('unpipe');\n\t    src.unpipe(dest);\n\t  }\n\n\t  // tell the dest that it's being piped to\n\t  dest.emit('pipe', src);\n\n\t  // start the flow if it hasn't been started already.\n\t  if (!state.flowing) {\n\t    debug('pipe resume');\n\t    src.resume();\n\t  }\n\n\t  return dest;\n\t};\n\n\tfunction pipeOnDrain(src) {\n\t  return function () {\n\t    var state = src._readableState;\n\t    debug('pipeOnDrain', state.awaitDrain);\n\t    if (state.awaitDrain) state.awaitDrain--;\n\t    if (state.awaitDrain === 0 && src.listeners('data').length) {\n\t      state.flowing = true;\n\t      flow(src);\n\t    }\n\t  };\n\t}\n\n\tReadable.prototype.unpipe = function (dest) {\n\t  var state = this._readableState;\n\n\t  // if we're not piping anywhere, then do nothing.\n\t  if (state.pipesCount === 0) return this;\n\n\t  // just one destination.  most common case.\n\t  if (state.pipesCount === 1) {\n\t    // passed in one, but it's not the right one.\n\t    if (dest && dest !== state.pipes) return this;\n\n\t    if (!dest) dest = state.pipes;\n\n\t    // got a match.\n\t    state.pipes = null;\n\t    state.pipesCount = 0;\n\t    state.flowing = false;\n\t    if (dest) dest.emit('unpipe', this);\n\t    return this;\n\t  }\n\n\t  // slow case. multiple pipe destinations.\n\n\t  if (!dest) {\n\t    // remove all.\n\t    var dests = state.pipes;\n\t    var len = state.pipesCount;\n\t    state.pipes = null;\n\t    state.pipesCount = 0;\n\t    state.flowing = false;\n\n\t    for (var _i = 0; _i < len; _i++) {\n\t      dests[_i].emit('unpipe', this);\n\t    }return this;\n\t  }\n\n\t  // try to find the right one.\n\t  var i = indexOf(state.pipes, dest);\n\t  if (i === -1) return this;\n\n\t  state.pipes.splice(i, 1);\n\t  state.pipesCount -= 1;\n\t  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n\t  dest.emit('unpipe', this);\n\n\t  return this;\n\t};\n\n\t// set up data events if they are asked for\n\t// Ensure readable listeners eventually get something\n\tReadable.prototype.on = function (ev, fn) {\n\t  var res = EventEmitter.prototype.on.call(this, ev, fn);\n\n\t  if (ev === 'data') {\n\t    // Start flowing on next tick if stream isn't explicitly paused\n\t    if (this._readableState.flowing !== false) this.resume();\n\t  } else if (ev === 'readable') {\n\t    var state = this._readableState;\n\t    if (!state.endEmitted && !state.readableListening) {\n\t      state.readableListening = state.needReadable = true;\n\t      state.emittedReadable = false;\n\t      if (!state.reading) {\n\t        nextTick(nReadingNextTick, this);\n\t      } else if (state.length) {\n\t        emitReadable(this);\n\t      }\n\t    }\n\t  }\n\n\t  return res;\n\t};\n\tReadable.prototype.addListener = Readable.prototype.on;\n\n\tfunction nReadingNextTick(self) {\n\t  debug('readable nexttick read 0');\n\t  self.read(0);\n\t}\n\n\t// pause() and resume() are remnants of the legacy readable stream API\n\t// If the user uses them, then switch into old mode.\n\tReadable.prototype.resume = function () {\n\t  var state = this._readableState;\n\t  if (!state.flowing) {\n\t    debug('resume');\n\t    state.flowing = true;\n\t    resume(this, state);\n\t  }\n\t  return this;\n\t};\n\n\tfunction resume(stream, state) {\n\t  if (!state.resumeScheduled) {\n\t    state.resumeScheduled = true;\n\t    nextTick(resume_, stream, state);\n\t  }\n\t}\n\n\tfunction resume_(stream, state) {\n\t  if (!state.reading) {\n\t    debug('resume read 0');\n\t    stream.read(0);\n\t  }\n\n\t  state.resumeScheduled = false;\n\t  state.awaitDrain = 0;\n\t  stream.emit('resume');\n\t  flow(stream);\n\t  if (state.flowing && !state.reading) stream.read(0);\n\t}\n\n\tReadable.prototype.pause = function () {\n\t  debug('call pause flowing=%j', this._readableState.flowing);\n\t  if (false !== this._readableState.flowing) {\n\t    debug('pause');\n\t    this._readableState.flowing = false;\n\t    this.emit('pause');\n\t  }\n\t  return this;\n\t};\n\n\tfunction flow(stream) {\n\t  var state = stream._readableState;\n\t  debug('flow', state.flowing);\n\t  while (state.flowing && stream.read() !== null) {}\n\t}\n\n\t// wrap an old-style stream as the async data source.\n\t// This is *not* part of the readable stream interface.\n\t// It is an ugly unfortunate mess of history.\n\tReadable.prototype.wrap = function (stream) {\n\t  var state = this._readableState;\n\t  var paused = false;\n\n\t  var self = this;\n\t  stream.on('end', function () {\n\t    debug('wrapped end');\n\t    if (state.decoder && !state.ended) {\n\t      var chunk = state.decoder.end();\n\t      if (chunk && chunk.length) self.push(chunk);\n\t    }\n\n\t    self.push(null);\n\t  });\n\n\t  stream.on('data', function (chunk) {\n\t    debug('wrapped data');\n\t    if (state.decoder) chunk = state.decoder.write(chunk);\n\n\t    // don't skip over falsy values in objectMode\n\t    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n\t    var ret = self.push(chunk);\n\t    if (!ret) {\n\t      paused = true;\n\t      stream.pause();\n\t    }\n\t  });\n\n\t  // proxy all the other methods.\n\t  // important when wrapping filters and duplexes.\n\t  for (var i in stream) {\n\t    if (this[i] === undefined && typeof stream[i] === 'function') {\n\t      this[i] = function (method) {\n\t        return function () {\n\t          return stream[method].apply(stream, arguments);\n\t        };\n\t      }(i);\n\t    }\n\t  }\n\n\t  // proxy certain important events.\n\t  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n\t  forEach(events, function (ev) {\n\t    stream.on(ev, self.emit.bind(self, ev));\n\t  });\n\n\t  // when we try to consume some more bytes, simply unpause the\n\t  // underlying stream.\n\t  self._read = function (n) {\n\t    debug('wrapped _read', n);\n\t    if (paused) {\n\t      paused = false;\n\t      stream.resume();\n\t    }\n\t  };\n\n\t  return self;\n\t};\n\n\t// exposed for testing purposes only.\n\tReadable._fromList = fromList;\n\n\t// Pluck off n bytes from an array of buffers.\n\t// Length is the combined lengths of all the buffers in the list.\n\t// This function is designed to be inlinable, so please take care when making\n\t// changes to the function body.\n\tfunction fromList(n, state) {\n\t  // nothing buffered\n\t  if (state.length === 0) return null;\n\n\t  var ret;\n\t  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n\t    // read it all, truncate the list\n\t    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n\t    state.buffer.clear();\n\t  } else {\n\t    // read part of list\n\t    ret = fromListPartial(n, state.buffer, state.decoder);\n\t  }\n\n\t  return ret;\n\t}\n\n\t// Extracts only enough buffered data to satisfy the amount requested.\n\t// This function is designed to be inlinable, so please take care when making\n\t// changes to the function body.\n\tfunction fromListPartial(n, list, hasStrings) {\n\t  var ret;\n\t  if (n < list.head.data.length) {\n\t    // slice is the same for buffers and strings\n\t    ret = list.head.data.slice(0, n);\n\t    list.head.data = list.head.data.slice(n);\n\t  } else if (n === list.head.data.length) {\n\t    // first chunk is a perfect match\n\t    ret = list.shift();\n\t  } else {\n\t    // result spans more than one buffer\n\t    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n\t  }\n\t  return ret;\n\t}\n\n\t// Copies a specified amount of characters from the list of buffered data\n\t// chunks.\n\t// This function is designed to be inlinable, so please take care when making\n\t// changes to the function body.\n\tfunction copyFromBufferString(n, list) {\n\t  var p = list.head;\n\t  var c = 1;\n\t  var ret = p.data;\n\t  n -= ret.length;\n\t  while (p = p.next) {\n\t    var str = p.data;\n\t    var nb = n > str.length ? str.length : n;\n\t    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n\t    n -= nb;\n\t    if (n === 0) {\n\t      if (nb === str.length) {\n\t        ++c;\n\t        if (p.next) list.head = p.next;else list.head = list.tail = null;\n\t      } else {\n\t        list.head = p;\n\t        p.data = str.slice(nb);\n\t      }\n\t      break;\n\t    }\n\t    ++c;\n\t  }\n\t  list.length -= c;\n\t  return ret;\n\t}\n\n\t// Copies a specified amount of bytes from the list of buffered data chunks.\n\t// This function is designed to be inlinable, so please take care when making\n\t// changes to the function body.\n\tfunction copyFromBuffer(n, list) {\n\t  var ret = Buffer.allocUnsafe(n);\n\t  var p = list.head;\n\t  var c = 1;\n\t  p.data.copy(ret);\n\t  n -= p.data.length;\n\t  while (p = p.next) {\n\t    var buf = p.data;\n\t    var nb = n > buf.length ? buf.length : n;\n\t    buf.copy(ret, ret.length - n, 0, nb);\n\t    n -= nb;\n\t    if (n === 0) {\n\t      if (nb === buf.length) {\n\t        ++c;\n\t        if (p.next) list.head = p.next;else list.head = list.tail = null;\n\t      } else {\n\t        list.head = p;\n\t        p.data = buf.slice(nb);\n\t      }\n\t      break;\n\t    }\n\t    ++c;\n\t  }\n\t  list.length -= c;\n\t  return ret;\n\t}\n\n\tfunction endReadable(stream) {\n\t  var state = stream._readableState;\n\n\t  // If we get here before consuming all the bytes, then that is a\n\t  // bug in node.  Should never happen.\n\t  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n\t  if (!state.endEmitted) {\n\t    state.ended = true;\n\t    nextTick(endReadableNT, state, stream);\n\t  }\n\t}\n\n\tfunction endReadableNT(state, stream) {\n\t  // Check that we didn't get one last unshift.\n\t  if (!state.endEmitted && state.length === 0) {\n\t    state.endEmitted = true;\n\t    stream.readable = false;\n\t    stream.emit('end');\n\t  }\n\t}\n\n\tfunction forEach(xs, f) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    f(xs[i], i);\n\t  }\n\t}\n\n\tfunction indexOf(xs, x) {\n\t  for (var i = 0, l = xs.length; i < l; i++) {\n\t    if (xs[i] === x) return i;\n\t  }\n\t  return -1;\n\t}\n\n\t// A bit simpler than readable streams.\n\t// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n\t// the drain event emission and buffering.\n\n\tWritable.WritableState = WritableState;\n\tinherits(Writable, EventEmitter);\n\n\tfunction nop() {}\n\n\tfunction WriteReq(chunk, encoding, cb) {\n\t  this.chunk = chunk;\n\t  this.encoding = encoding;\n\t  this.callback = cb;\n\t  this.next = null;\n\t}\n\n\tfunction WritableState(options, stream) {\n\t  Object.defineProperty(this, 'buffer', {\n\t    get: deprecate(function () {\n\t      return this.getBuffer();\n\t    }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n\t  });\n\t  options = options || {};\n\n\t  // object stream flag to indicate whether or not this stream\n\t  // contains buffers or objects.\n\t  this.objectMode = !!options.objectMode;\n\n\t  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n\t  // the point at which write() starts returning false\n\t  // Note: 0 is a valid value, means that we always return false if\n\t  // the entire buffer is not flushed immediately on write()\n\t  var hwm = options.highWaterMark;\n\t  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\t  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n\t  // cast to ints.\n\t  this.highWaterMark = ~ ~this.highWaterMark;\n\n\t  this.needDrain = false;\n\t  // at the start of calling end()\n\t  this.ending = false;\n\t  // when end() has been called, and returned\n\t  this.ended = false;\n\t  // when 'finish' is emitted\n\t  this.finished = false;\n\n\t  // should we decode strings into buffers before passing to _write?\n\t  // this is here so that some node-core streams can optimize string\n\t  // handling at a lower level.\n\t  var noDecode = options.decodeStrings === false;\n\t  this.decodeStrings = !noDecode;\n\n\t  // Crypto is kind of old and crusty.  Historically, its default string\n\t  // encoding is 'binary' so we have to make this configurable.\n\t  // Everything else in the universe uses 'utf8', though.\n\t  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n\t  // not an actual buffer we keep track of, but a measurement\n\t  // of how much we're waiting to get pushed to some underlying\n\t  // socket or file.\n\t  this.length = 0;\n\n\t  // a flag to see when we're in the middle of a write.\n\t  this.writing = false;\n\n\t  // when true all writes will be buffered until .uncork() call\n\t  this.corked = 0;\n\n\t  // a flag to be able to tell if the onwrite cb is called immediately,\n\t  // or on a later tick.  We set this to true at first, because any\n\t  // actions that shouldn't happen until \"later\" should generally also\n\t  // not happen before the first write call.\n\t  this.sync = true;\n\n\t  // a flag to know if we're processing previously buffered items, which\n\t  // may call the _write() callback in the same tick, so that we don't\n\t  // end up in an overlapped onwrite situation.\n\t  this.bufferProcessing = false;\n\n\t  // the callback that's passed to _write(chunk,cb)\n\t  this.onwrite = function (er) {\n\t    onwrite(stream, er);\n\t  };\n\n\t  // the callback that the user supplies to write(chunk,encoding,cb)\n\t  this.writecb = null;\n\n\t  // the amount that is being written when _write is called.\n\t  this.writelen = 0;\n\n\t  this.bufferedRequest = null;\n\t  this.lastBufferedRequest = null;\n\n\t  // number of pending user-supplied write callbacks\n\t  // this must be 0 before 'finish' can be emitted\n\t  this.pendingcb = 0;\n\n\t  // emit prefinish if the only thing we're waiting for is _write cbs\n\t  // This is relevant for synchronous Transform streams\n\t  this.prefinished = false;\n\n\t  // True if the error was already emitted and should not be thrown again\n\t  this.errorEmitted = false;\n\n\t  // count buffered requests\n\t  this.bufferedRequestCount = 0;\n\n\t  // allocate the first CorkedRequest, there is always\n\t  // one allocated and free to use, and we maintain at most two\n\t  this.corkedRequestsFree = new CorkedRequest(this);\n\t}\n\n\tWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n\t  var current = this.bufferedRequest;\n\t  var out = [];\n\t  while (current) {\n\t    out.push(current);\n\t    current = current.next;\n\t  }\n\t  return out;\n\t};\n\tfunction Writable(options) {\n\n\t  // Writable ctor is applied to Duplexes, though they're not\n\t  // instanceof Writable, they're instanceof Readable.\n\t  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n\t  this._writableState = new WritableState(options, this);\n\n\t  // legacy.\n\t  this.writable = true;\n\n\t  if (options) {\n\t    if (typeof options.write === 'function') this._write = options.write;\n\n\t    if (typeof options.writev === 'function') this._writev = options.writev;\n\t  }\n\n\t  EventEmitter.call(this);\n\t}\n\n\t// Otherwise people can pipe Writable streams, which is just wrong.\n\tWritable.prototype.pipe = function () {\n\t  this.emit('error', new Error('Cannot pipe, not readable'));\n\t};\n\n\tfunction writeAfterEnd(stream, cb) {\n\t  var er = new Error('write after end');\n\t  // TODO: defer error events consistently everywhere, not just the cb\n\t  stream.emit('error', er);\n\t  nextTick(cb, er);\n\t}\n\n\t// If we get something that is not a buffer, string, null, or undefined,\n\t// and we're not in objectMode, then that's an error.\n\t// Otherwise stream chunks are all considered to be of length=1, and the\n\t// watermarks determine how many objects to keep in the buffer, rather than\n\t// how many bytes or characters.\n\tfunction validChunk(stream, state, chunk, cb) {\n\t  var valid = true;\n\t  var er = false;\n\t  // Always throw error if a null is written\n\t  // if we are not in object mode then throw\n\t  // if it is not a buffer, string, or undefined.\n\t  if (chunk === null) {\n\t    er = new TypeError('May not write null values to stream');\n\t  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n\t    er = new TypeError('Invalid non-string/buffer chunk');\n\t  }\n\t  if (er) {\n\t    stream.emit('error', er);\n\t    nextTick(cb, er);\n\t    valid = false;\n\t  }\n\t  return valid;\n\t}\n\n\tWritable.prototype.write = function (chunk, encoding, cb) {\n\t  var state = this._writableState;\n\t  var ret = false;\n\n\t  if (typeof encoding === 'function') {\n\t    cb = encoding;\n\t    encoding = null;\n\t  }\n\n\t  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n\t  if (typeof cb !== 'function') cb = nop;\n\n\t  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n\t    state.pendingcb++;\n\t    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n\t  }\n\n\t  return ret;\n\t};\n\n\tWritable.prototype.cork = function () {\n\t  var state = this._writableState;\n\n\t  state.corked++;\n\t};\n\n\tWritable.prototype.uncork = function () {\n\t  var state = this._writableState;\n\n\t  if (state.corked) {\n\t    state.corked--;\n\n\t    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n\t  }\n\t};\n\n\tWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n\t  // node::ParseEncoding() requires lower case.\n\t  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n\t  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n\t  this._writableState.defaultEncoding = encoding;\n\t  return this;\n\t};\n\n\tfunction decodeChunk(state, chunk, encoding) {\n\t  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n\t    chunk = Buffer.from(chunk, encoding);\n\t  }\n\t  return chunk;\n\t}\n\n\t// if we're already writing something, then just put this\n\t// in the queue, and wait our turn.  Otherwise, call _write\n\t// If we return false, then we need a drain event, so set that flag.\n\tfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n\t  chunk = decodeChunk(state, chunk, encoding);\n\n\t  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n\t  var len = state.objectMode ? 1 : chunk.length;\n\n\t  state.length += len;\n\n\t  var ret = state.length < state.highWaterMark;\n\t  // we must ensure that previous needDrain will not be reset to false.\n\t  if (!ret) state.needDrain = true;\n\n\t  if (state.writing || state.corked) {\n\t    var last = state.lastBufferedRequest;\n\t    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n\t    if (last) {\n\t      last.next = state.lastBufferedRequest;\n\t    } else {\n\t      state.bufferedRequest = state.lastBufferedRequest;\n\t    }\n\t    state.bufferedRequestCount += 1;\n\t  } else {\n\t    doWrite(stream, state, false, len, chunk, encoding, cb);\n\t  }\n\n\t  return ret;\n\t}\n\n\tfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n\t  state.writelen = len;\n\t  state.writecb = cb;\n\t  state.writing = true;\n\t  state.sync = true;\n\t  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n\t  state.sync = false;\n\t}\n\n\tfunction onwriteError(stream, state, sync, er, cb) {\n\t  --state.pendingcb;\n\t  if (sync) nextTick(cb, er);else cb(er);\n\n\t  stream._writableState.errorEmitted = true;\n\t  stream.emit('error', er);\n\t}\n\n\tfunction onwriteStateUpdate(state) {\n\t  state.writing = false;\n\t  state.writecb = null;\n\t  state.length -= state.writelen;\n\t  state.writelen = 0;\n\t}\n\n\tfunction onwrite(stream, er) {\n\t  var state = stream._writableState;\n\t  var sync = state.sync;\n\t  var cb = state.writecb;\n\n\t  onwriteStateUpdate(state);\n\n\t  if (er) onwriteError(stream, state, sync, er, cb);else {\n\t    // Check if we're actually ready to finish, but don't emit yet\n\t    var finished = needFinish(state);\n\n\t    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n\t      clearBuffer(stream, state);\n\t    }\n\n\t    if (sync) {\n\t      /*<replacement>*/\n\t        nextTick(afterWrite, stream, state, finished, cb);\n\t      /*</replacement>*/\n\t    } else {\n\t        afterWrite(stream, state, finished, cb);\n\t      }\n\t  }\n\t}\n\n\tfunction afterWrite(stream, state, finished, cb) {\n\t  if (!finished) onwriteDrain(stream, state);\n\t  state.pendingcb--;\n\t  cb();\n\t  finishMaybe(stream, state);\n\t}\n\n\t// Must force callback to be called on nextTick, so that we don't\n\t// emit 'drain' before the write() consumer gets the 'false' return\n\t// value, and has a chance to attach a 'drain' listener.\n\tfunction onwriteDrain(stream, state) {\n\t  if (state.length === 0 && state.needDrain) {\n\t    state.needDrain = false;\n\t    stream.emit('drain');\n\t  }\n\t}\n\n\t// if there's something in the buffer waiting, then process it\n\tfunction clearBuffer(stream, state) {\n\t  state.bufferProcessing = true;\n\t  var entry = state.bufferedRequest;\n\n\t  if (stream._writev && entry && entry.next) {\n\t    // Fast case, write everything using _writev()\n\t    var l = state.bufferedRequestCount;\n\t    var buffer = new Array(l);\n\t    var holder = state.corkedRequestsFree;\n\t    holder.entry = entry;\n\n\t    var count = 0;\n\t    while (entry) {\n\t      buffer[count] = entry;\n\t      entry = entry.next;\n\t      count += 1;\n\t    }\n\n\t    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n\t    // doWrite is almost always async, defer these to save a bit of time\n\t    // as the hot path ends with doWrite\n\t    state.pendingcb++;\n\t    state.lastBufferedRequest = null;\n\t    if (holder.next) {\n\t      state.corkedRequestsFree = holder.next;\n\t      holder.next = null;\n\t    } else {\n\t      state.corkedRequestsFree = new CorkedRequest(state);\n\t    }\n\t  } else {\n\t    // Slow case, write chunks one-by-one\n\t    while (entry) {\n\t      var chunk = entry.chunk;\n\t      var encoding = entry.encoding;\n\t      var cb = entry.callback;\n\t      var len = state.objectMode ? 1 : chunk.length;\n\n\t      doWrite(stream, state, false, len, chunk, encoding, cb);\n\t      entry = entry.next;\n\t      // if we didn't call the onwrite immediately, then\n\t      // it means that we need to wait until it does.\n\t      // also, that means that the chunk and cb are currently\n\t      // being processed, so move the buffer counter past them.\n\t      if (state.writing) {\n\t        break;\n\t      }\n\t    }\n\n\t    if (entry === null) state.lastBufferedRequest = null;\n\t  }\n\n\t  state.bufferedRequestCount = 0;\n\t  state.bufferedRequest = entry;\n\t  state.bufferProcessing = false;\n\t}\n\n\tWritable.prototype._write = function (chunk, encoding, cb) {\n\t  cb(new Error('not implemented'));\n\t};\n\n\tWritable.prototype._writev = null;\n\n\tWritable.prototype.end = function (chunk, encoding, cb) {\n\t  var state = this._writableState;\n\n\t  if (typeof chunk === 'function') {\n\t    cb = chunk;\n\t    chunk = null;\n\t    encoding = null;\n\t  } else if (typeof encoding === 'function') {\n\t    cb = encoding;\n\t    encoding = null;\n\t  }\n\n\t  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n\t  // .end() fully uncorks\n\t  if (state.corked) {\n\t    state.corked = 1;\n\t    this.uncork();\n\t  }\n\n\t  // ignore unnecessary end() calls.\n\t  if (!state.ending && !state.finished) endWritable(this, state, cb);\n\t};\n\n\tfunction needFinish(state) {\n\t  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n\t}\n\n\tfunction prefinish(stream, state) {\n\t  if (!state.prefinished) {\n\t    state.prefinished = true;\n\t    stream.emit('prefinish');\n\t  }\n\t}\n\n\tfunction finishMaybe(stream, state) {\n\t  var need = needFinish(state);\n\t  if (need) {\n\t    if (state.pendingcb === 0) {\n\t      prefinish(stream, state);\n\t      state.finished = true;\n\t      stream.emit('finish');\n\t    } else {\n\t      prefinish(stream, state);\n\t    }\n\t  }\n\t  return need;\n\t}\n\n\tfunction endWritable(stream, state, cb) {\n\t  state.ending = true;\n\t  finishMaybe(stream, state);\n\t  if (cb) {\n\t    if (state.finished) nextTick(cb);else stream.once('finish', cb);\n\t  }\n\t  state.ended = true;\n\t  stream.writable = false;\n\t}\n\n\t// It seems a linked list but it is not\n\t// there will be only 2 of these for each stream\n\tfunction CorkedRequest(state) {\n\t  var _this = this;\n\n\t  this.next = null;\n\t  this.entry = null;\n\n\t  this.finish = function (err) {\n\t    var entry = _this.entry;\n\t    _this.entry = null;\n\t    while (entry) {\n\t      var cb = entry.callback;\n\t      state.pendingcb--;\n\t      cb(err);\n\t      entry = entry.next;\n\t    }\n\t    if (state.corkedRequestsFree) {\n\t      state.corkedRequestsFree.next = _this;\n\t    } else {\n\t      state.corkedRequestsFree = _this;\n\t    }\n\t  };\n\t}\n\n\tinherits(Duplex, Readable);\n\n\tvar keys = Object.keys(Writable.prototype);\n\tfor (var v = 0; v < keys.length; v++) {\n\t  var method = keys[v];\n\t  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n\t}\n\tfunction Duplex(options) {\n\t  if (!(this instanceof Duplex)) return new Duplex(options);\n\n\t  Readable.call(this, options);\n\t  Writable.call(this, options);\n\n\t  if (options && options.readable === false) this.readable = false;\n\n\t  if (options && options.writable === false) this.writable = false;\n\n\t  this.allowHalfOpen = true;\n\t  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n\t  this.once('end', onend);\n\t}\n\n\t// the no-half-open enforcer\n\tfunction onend() {\n\t  // if we allow half-open state, or if the writable side ended,\n\t  // then we're ok.\n\t  if (this.allowHalfOpen || this._writableState.ended) return;\n\n\t  // no more data can be written.\n\t  // But allow more writes to happen in this tick.\n\t  nextTick(onEndNT, this);\n\t}\n\n\tfunction onEndNT(self) {\n\t  self.end();\n\t}\n\n\t// a transform stream is a readable/writable stream where you do\n\t// something with the data.  Sometimes it's called a \"filter\",\n\t// but that's not a great name for it, since that implies a thing where\n\t// some bits pass through, and others are simply ignored.  (That would\n\t// be a valid example of a transform, of course.)\n\t//\n\t// While the output is causally related to the input, it's not a\n\t// necessarily symmetric or synchronous transformation.  For example,\n\t// a zlib stream might take multiple plain-text writes(), and then\n\t// emit a single compressed chunk some time in the future.\n\t//\n\t// Here's how this works:\n\t//\n\t// The Transform stream has all the aspects of the readable and writable\n\t// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n\t// internally, and returns false if there's a lot of pending writes\n\t// buffered up.  When you call read(), that calls _read(n) until\n\t// there's enough pending readable data buffered up.\n\t//\n\t// In a transform stream, the written data is placed in a buffer.  When\n\t// _read(n) is called, it transforms the queued up data, calling the\n\t// buffered _write cb's as it consumes chunks.  If consuming a single\n\t// written chunk would result in multiple output chunks, then the first\n\t// outputted bit calls the readcb, and subsequent chunks just go into\n\t// the read buffer, and will cause it to emit 'readable' if necessary.\n\t//\n\t// This way, back-pressure is actually determined by the reading side,\n\t// since _read has to be called to start processing a new chunk.  However,\n\t// a pathological inflate type of transform can cause excessive buffering\n\t// here.  For example, imagine a stream where every byte of input is\n\t// interpreted as an integer from 0-255, and then results in that many\n\t// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n\t// 1kb of data being output.  In this case, you could write a very small\n\t// amount of input, and end up with a very large amount of output.  In\n\t// such a pathological inflating mechanism, there'd be no way to tell\n\t// the system to stop doing the transform.  A single 4MB write could\n\t// cause the system to run out of memory.\n\t//\n\t// However, even in such a pathological case, only a single written chunk\n\t// would be consumed, and then the rest would wait (un-transformed) until\n\t// the results of the previous transformed chunk were consumed.\n\n\tinherits(Transform, Duplex);\n\n\tfunction TransformState(stream) {\n\t  this.afterTransform = function (er, data) {\n\t    return afterTransform(stream, er, data);\n\t  };\n\n\t  this.needTransform = false;\n\t  this.transforming = false;\n\t  this.writecb = null;\n\t  this.writechunk = null;\n\t  this.writeencoding = null;\n\t}\n\n\tfunction afterTransform(stream, er, data) {\n\t  var ts = stream._transformState;\n\t  ts.transforming = false;\n\n\t  var cb = ts.writecb;\n\n\t  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n\t  ts.writechunk = null;\n\t  ts.writecb = null;\n\n\t  if (data !== null && data !== undefined) stream.push(data);\n\n\t  cb(er);\n\n\t  var rs = stream._readableState;\n\t  rs.reading = false;\n\t  if (rs.needReadable || rs.length < rs.highWaterMark) {\n\t    stream._read(rs.highWaterMark);\n\t  }\n\t}\n\tfunction Transform(options) {\n\t  if (!(this instanceof Transform)) return new Transform(options);\n\n\t  Duplex.call(this, options);\n\n\t  this._transformState = new TransformState(this);\n\n\t  // when the writable side finishes, then flush out anything remaining.\n\t  var stream = this;\n\n\t  // start out asking for a readable event once data is transformed.\n\t  this._readableState.needReadable = true;\n\n\t  // we have implemented the _read method, and done the other things\n\t  // that Readable wants before the first _read call, so unset the\n\t  // sync guard flag.\n\t  this._readableState.sync = false;\n\n\t  if (options) {\n\t    if (typeof options.transform === 'function') this._transform = options.transform;\n\n\t    if (typeof options.flush === 'function') this._flush = options.flush;\n\t  }\n\n\t  this.once('prefinish', function () {\n\t    if (typeof this._flush === 'function') this._flush(function (er) {\n\t      done(stream, er);\n\t    });else done(stream);\n\t  });\n\t}\n\n\tTransform.prototype.push = function (chunk, encoding) {\n\t  this._transformState.needTransform = false;\n\t  return Duplex.prototype.push.call(this, chunk, encoding);\n\t};\n\n\t// This is the part where you do stuff!\n\t// override this function in implementation classes.\n\t// 'chunk' is an input chunk.\n\t//\n\t// Call `push(newChunk)` to pass along transformed output\n\t// to the readable side.  You may call 'push' zero or more times.\n\t//\n\t// Call `cb(err)` when you are done with this chunk.  If you pass\n\t// an error, then that'll put the hurt on the whole operation.  If you\n\t// never call cb(), then you'll never get another chunk.\n\tTransform.prototype._transform = function (chunk, encoding, cb) {\n\t  throw new Error('Not implemented');\n\t};\n\n\tTransform.prototype._write = function (chunk, encoding, cb) {\n\t  var ts = this._transformState;\n\t  ts.writecb = cb;\n\t  ts.writechunk = chunk;\n\t  ts.writeencoding = encoding;\n\t  if (!ts.transforming) {\n\t    var rs = this._readableState;\n\t    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n\t  }\n\t};\n\n\t// Doesn't matter what the args are here.\n\t// _transform does all the work.\n\t// That we got here means that the readable side wants more data.\n\tTransform.prototype._read = function (n) {\n\t  var ts = this._transformState;\n\n\t  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n\t    ts.transforming = true;\n\t    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n\t  } else {\n\t    // mark that we need a transform, so that any data that comes in\n\t    // will get processed, now that we've asked for it.\n\t    ts.needTransform = true;\n\t  }\n\t};\n\n\tfunction done(stream, er) {\n\t  if (er) return stream.emit('error', er);\n\n\t  // if there's nothing in the write buffer, then that means\n\t  // that nothing more will ever be provided\n\t  var ws = stream._writableState;\n\t  var ts = stream._transformState;\n\n\t  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n\t  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n\t  return stream.push(null);\n\t}\n\n\tinherits(PassThrough, Transform);\n\tfunction PassThrough(options) {\n\t  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n\t  Transform.call(this, options);\n\t}\n\n\tPassThrough.prototype._transform = function (chunk, encoding, cb) {\n\t  cb(null, chunk);\n\t};\n\n\tinherits(Stream, EventEmitter);\n\tStream.Readable = Readable;\n\tStream.Writable = Writable;\n\tStream.Duplex = Duplex;\n\tStream.Transform = Transform;\n\tStream.PassThrough = PassThrough;\n\n\t// Backwards-compat with node 0.4.x\n\tStream.Stream = Stream;\n\n\t// old-style streams.  Note that the pipe method (the only relevant\n\t// part of this class) is overridden in the Readable class.\n\n\tfunction Stream() {\n\t  EventEmitter.call(this);\n\t}\n\n\tStream.prototype.pipe = function(dest, options) {\n\t  var source = this;\n\n\t  function ondata(chunk) {\n\t    if (dest.writable) {\n\t      if (false === dest.write(chunk) && source.pause) {\n\t        source.pause();\n\t      }\n\t    }\n\t  }\n\n\t  source.on('data', ondata);\n\n\t  function ondrain() {\n\t    if (source.readable && source.resume) {\n\t      source.resume();\n\t    }\n\t  }\n\n\t  dest.on('drain', ondrain);\n\n\t  // If the 'end' option is not supplied, dest.end() will be called when\n\t  // source gets the 'end' or 'close' events.  Only dest.end() once.\n\t  if (!dest._isStdio && (!options || options.end !== false)) {\n\t    source.on('end', onend);\n\t    source.on('close', onclose);\n\t  }\n\n\t  var didOnEnd = false;\n\t  function onend() {\n\t    if (didOnEnd) return;\n\t    didOnEnd = true;\n\n\t    dest.end();\n\t  }\n\n\n\t  function onclose() {\n\t    if (didOnEnd) return;\n\t    didOnEnd = true;\n\n\t    if (typeof dest.destroy === 'function') dest.destroy();\n\t  }\n\n\t  // don't leave dangling pipes when there are errors.\n\t  function onerror(er) {\n\t    cleanup();\n\t    if (EventEmitter.listenerCount(this, 'error') === 0) {\n\t      throw er; // Unhandled stream error in pipe.\n\t    }\n\t  }\n\n\t  source.on('error', onerror);\n\t  dest.on('error', onerror);\n\n\t  // remove all the event listeners that were added.\n\t  function cleanup() {\n\t    source.removeListener('data', ondata);\n\t    dest.removeListener('drain', ondrain);\n\n\t    source.removeListener('end', onend);\n\t    source.removeListener('close', onclose);\n\n\t    source.removeListener('error', onerror);\n\t    dest.removeListener('error', onerror);\n\n\t    source.removeListener('end', cleanup);\n\t    source.removeListener('close', cleanup);\n\n\t    dest.removeListener('close', cleanup);\n\t  }\n\n\t  source.on('end', cleanup);\n\t  source.on('close', cleanup);\n\n\t  dest.on('close', cleanup);\n\n\t  dest.emit('pipe', source);\n\n\t  // Allow for unix-like usage: A.pipe(B).pipe(C)\n\t  return dest;\n\t};\n\n\tvar _polyfillNode_stream = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tDuplex: Duplex,\n\t\tPassThrough: PassThrough,\n\t\tReadable: Readable,\n\t\tStream: Stream,\n\t\tTransform: Transform,\n\t\tWritable: Writable,\n\t\tdefault: Stream\n\t});\n\n\tvar require$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_stream);\n\n\tvar require$1$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_string_decoder);\n\n\tvar hasRequiredSax;\n\n\tfunction requireSax () {\n\t\tif (hasRequiredSax) return sax;\n\t\thasRequiredSax = 1;\n\t\t(function (exports) {\n\t(function (sax) { // wrapper for non-node envs\n\t\t\t  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) };\n\t\t\t  sax.SAXParser = SAXParser;\n\t\t\t  sax.SAXStream = SAXStream;\n\t\t\t  sax.createStream = createStream;\n\n\t\t\t  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n\t\t\t  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n\t\t\t  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n\t\t\t  // as rare as required, but as often as necessary to ensure never crossing this bound.\n\t\t\t  // Furthermore, buffers are only tested at most once per write(), so passing a very\n\t\t\t  // large string into write() might have undesirable effects, but this is manageable by\n\t\t\t  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n\t\t\t  // edge case, result in creating at most one complete copy of the string passed in.\n\t\t\t  // Set to Infinity to have unlimited buffers.\n\t\t\t  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n\n\t\t\t  var buffers = [\n\t\t\t    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n\t\t\t    'procInstName', 'procInstBody', 'entity', 'attribName',\n\t\t\t    'attribValue', 'cdata', 'script'\n\t\t\t  ];\n\n\t\t\t  sax.EVENTS = [\n\t\t\t    'text',\n\t\t\t    'processinginstruction',\n\t\t\t    'sgmldeclaration',\n\t\t\t    'doctype',\n\t\t\t    'comment',\n\t\t\t    'opentagstart',\n\t\t\t    'attribute',\n\t\t\t    'opentag',\n\t\t\t    'closetag',\n\t\t\t    'opencdata',\n\t\t\t    'cdata',\n\t\t\t    'closecdata',\n\t\t\t    'error',\n\t\t\t    'end',\n\t\t\t    'ready',\n\t\t\t    'script',\n\t\t\t    'opennamespace',\n\t\t\t    'closenamespace'\n\t\t\t  ];\n\n\t\t\t  function SAXParser (strict, opt) {\n\t\t\t    if (!(this instanceof SAXParser)) {\n\t\t\t      return new SAXParser(strict, opt)\n\t\t\t    }\n\n\t\t\t    var parser = this;\n\t\t\t    clearBuffers(parser);\n\t\t\t    parser.q = parser.c = '';\n\t\t\t    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n\t\t\t    parser.opt = opt || {};\n\t\t\t    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n\t\t\t    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';\n\t\t\t    parser.tags = [];\n\t\t\t    parser.closed = parser.closedRoot = parser.sawRoot = false;\n\t\t\t    parser.tag = parser.error = null;\n\t\t\t    parser.strict = !!strict;\n\t\t\t    parser.noscript = !!(strict || parser.opt.noscript);\n\t\t\t    parser.state = S.BEGIN;\n\t\t\t    parser.strictEntities = parser.opt.strictEntities;\n\t\t\t    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);\n\t\t\t    parser.attribList = [];\n\n\t\t\t    // namespaces form a prototype chain.\n\t\t\t    // it always points at the current tag,\n\t\t\t    // which protos to its parent tag.\n\t\t\t    if (parser.opt.xmlns) {\n\t\t\t      parser.ns = Object.create(rootNS);\n\t\t\t    }\n\n\t\t\t    // disallow unquoted attribute values if not otherwise configured\n\t\t\t    // and strict mode is true\n\t\t\t    if (parser.opt.unquotedAttributeValues === undefined) {\n\t\t\t      parser.opt.unquotedAttributeValues = !strict;\n\t\t\t    }\n\n\t\t\t    // mostly just for error reporting\n\t\t\t    parser.trackPosition = parser.opt.position !== false;\n\t\t\t    if (parser.trackPosition) {\n\t\t\t      parser.position = parser.line = parser.column = 0;\n\t\t\t    }\n\t\t\t    emit(parser, 'onready');\n\t\t\t  }\n\n\t\t\t  if (!Object.create) {\n\t\t\t    Object.create = function (o) {\n\t\t\t      function F () {}\n\t\t\t      F.prototype = o;\n\t\t\t      var newf = new F();\n\t\t\t      return newf\n\t\t\t    };\n\t\t\t  }\n\n\t\t\t  if (!Object.keys) {\n\t\t\t    Object.keys = function (o) {\n\t\t\t      var a = [];\n\t\t\t      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n\t\t\t      return a\n\t\t\t    };\n\t\t\t  }\n\n\t\t\t  function checkBufferLength (parser) {\n\t\t\t    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n\t\t\t    var maxActual = 0;\n\t\t\t    for (var i = 0, l = buffers.length; i < l; i++) {\n\t\t\t      var len = parser[buffers[i]].length;\n\t\t\t      if (len > maxAllowed) {\n\t\t\t        // Text/cdata nodes can get big, and since they're buffered,\n\t\t\t        // we can get here under normal conditions.\n\t\t\t        // Avoid issues by emitting the text node now,\n\t\t\t        // so at least it won't get any bigger.\n\t\t\t        switch (buffers[i]) {\n\t\t\t          case 'textNode':\n\t\t\t            closeText(parser);\n\t\t\t            break\n\n\t\t\t          case 'cdata':\n\t\t\t            emitNode(parser, 'oncdata', parser.cdata);\n\t\t\t            parser.cdata = '';\n\t\t\t            break\n\n\t\t\t          case 'script':\n\t\t\t            emitNode(parser, 'onscript', parser.script);\n\t\t\t            parser.script = '';\n\t\t\t            break\n\n\t\t\t          default:\n\t\t\t            error(parser, 'Max buffer length exceeded: ' + buffers[i]);\n\t\t\t        }\n\t\t\t      }\n\t\t\t      maxActual = Math.max(maxActual, len);\n\t\t\t    }\n\t\t\t    // schedule the next check for the earliest possible buffer overrun.\n\t\t\t    var m = sax.MAX_BUFFER_LENGTH - maxActual;\n\t\t\t    parser.bufferCheckPosition = m + parser.position;\n\t\t\t  }\n\n\t\t\t  function clearBuffers (parser) {\n\t\t\t    for (var i = 0, l = buffers.length; i < l; i++) {\n\t\t\t      parser[buffers[i]] = '';\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  function flushBuffers (parser) {\n\t\t\t    closeText(parser);\n\t\t\t    if (parser.cdata !== '') {\n\t\t\t      emitNode(parser, 'oncdata', parser.cdata);\n\t\t\t      parser.cdata = '';\n\t\t\t    }\n\t\t\t    if (parser.script !== '') {\n\t\t\t      emitNode(parser, 'onscript', parser.script);\n\t\t\t      parser.script = '';\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  SAXParser.prototype = {\n\t\t\t    end: function () { end(this); },\n\t\t\t    write: write,\n\t\t\t    resume: function () { this.error = null; return this },\n\t\t\t    close: function () { return this.write(null) },\n\t\t\t    flush: function () { flushBuffers(this); }\n\t\t\t  };\n\n\t\t\t  var Stream;\n\t\t\t  try {\n\t\t\t    Stream = require$0.Stream;\n\t\t\t  } catch (ex) {\n\t\t\t    Stream = function () {};\n\t\t\t  }\n\t\t\t  if (!Stream) Stream = function () {};\n\n\t\t\t  var streamWraps = sax.EVENTS.filter(function (ev) {\n\t\t\t    return ev !== 'error' && ev !== 'end'\n\t\t\t  });\n\n\t\t\t  function createStream (strict, opt) {\n\t\t\t    return new SAXStream(strict, opt)\n\t\t\t  }\n\n\t\t\t  function SAXStream (strict, opt) {\n\t\t\t    if (!(this instanceof SAXStream)) {\n\t\t\t      return new SAXStream(strict, opt)\n\t\t\t    }\n\n\t\t\t    Stream.apply(this);\n\n\t\t\t    this._parser = new SAXParser(strict, opt);\n\t\t\t    this.writable = true;\n\t\t\t    this.readable = true;\n\n\t\t\t    var me = this;\n\n\t\t\t    this._parser.onend = function () {\n\t\t\t      me.emit('end');\n\t\t\t    };\n\n\t\t\t    this._parser.onerror = function (er) {\n\t\t\t      me.emit('error', er);\n\n\t\t\t      // if didn't throw, then means error was handled.\n\t\t\t      // go ahead and clear error, so we can write again.\n\t\t\t      me._parser.error = null;\n\t\t\t    };\n\n\t\t\t    this._decoder = null;\n\n\t\t\t    streamWraps.forEach(function (ev) {\n\t\t\t      Object.defineProperty(me, 'on' + ev, {\n\t\t\t        get: function () {\n\t\t\t          return me._parser['on' + ev]\n\t\t\t        },\n\t\t\t        set: function (h) {\n\t\t\t          if (!h) {\n\t\t\t            me.removeAllListeners(ev);\n\t\t\t            me._parser['on' + ev] = h;\n\t\t\t            return h\n\t\t\t          }\n\t\t\t          me.on(ev, h);\n\t\t\t        },\n\t\t\t        enumerable: true,\n\t\t\t        configurable: false\n\t\t\t      });\n\t\t\t    });\n\t\t\t  }\n\n\t\t\t  SAXStream.prototype = Object.create(Stream.prototype, {\n\t\t\t    constructor: {\n\t\t\t      value: SAXStream\n\t\t\t    }\n\t\t\t  });\n\n\t\t\t  SAXStream.prototype.write = function (data) {\n\t\t\t    if (typeof Buffer === 'function' &&\n\t\t\t      typeof Buffer.isBuffer === 'function' &&\n\t\t\t      Buffer.isBuffer(data)) {\n\t\t\t      if (!this._decoder) {\n\t\t\t        var SD = require$1$1.StringDecoder;\n\t\t\t        this._decoder = new SD('utf8');\n\t\t\t      }\n\t\t\t      data = this._decoder.write(data);\n\t\t\t    }\n\n\t\t\t    this._parser.write(data.toString());\n\t\t\t    this.emit('data', data);\n\t\t\t    return true\n\t\t\t  };\n\n\t\t\t  SAXStream.prototype.end = function (chunk) {\n\t\t\t    if (chunk && chunk.length) {\n\t\t\t      this.write(chunk);\n\t\t\t    }\n\t\t\t    this._parser.end();\n\t\t\t    return true\n\t\t\t  };\n\n\t\t\t  SAXStream.prototype.on = function (ev, handler) {\n\t\t\t    var me = this;\n\t\t\t    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n\t\t\t      me._parser['on' + ev] = function () {\n\t\t\t        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n\t\t\t        args.splice(0, 0, ev);\n\t\t\t        me.emit.apply(me, args);\n\t\t\t      };\n\t\t\t    }\n\n\t\t\t    return Stream.prototype.on.call(me, ev, handler)\n\t\t\t  };\n\n\t\t\t  // this really needs to be replaced with character classes.\n\t\t\t  // XML allows all manner of ridiculous numbers and digits.\n\t\t\t  var CDATA = '[CDATA[';\n\t\t\t  var DOCTYPE = 'DOCTYPE';\n\t\t\t  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\n\t\t\t  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n\t\t\t  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n\n\t\t\t  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n\t\t\t  // This implementation works on strings, a single character at a time\n\t\t\t  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n\t\t\t  // without a significant breaking change to either this  parser, or the\n\t\t\t  // JavaScript language.  Implementation of an emoji-capable xml parser\n\t\t\t  // is left as an exercise for the reader.\n\t\t\t  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n\n\t\t\t  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n\t\t\t  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n\t\t\t  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n\t\t\t  function isWhitespace (c) {\n\t\t\t    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n\t\t\t  }\n\n\t\t\t  function isQuote (c) {\n\t\t\t    return c === '\"' || c === '\\''\n\t\t\t  }\n\n\t\t\t  function isAttribEnd (c) {\n\t\t\t    return c === '>' || isWhitespace(c)\n\t\t\t  }\n\n\t\t\t  function isMatch (regex, c) {\n\t\t\t    return regex.test(c)\n\t\t\t  }\n\n\t\t\t  function notMatch (regex, c) {\n\t\t\t    return !isMatch(regex, c)\n\t\t\t  }\n\n\t\t\t  var S = 0;\n\t\t\t  sax.STATE = {\n\t\t\t    BEGIN: S++, // leading byte order mark or whitespace\n\t\t\t    BEGIN_WHITESPACE: S++, // leading whitespace\n\t\t\t    TEXT: S++, // general stuff\n\t\t\t    TEXT_ENTITY: S++, // &amp and such.\n\t\t\t    OPEN_WAKA: S++, // <\n\t\t\t    SGML_DECL: S++, // <!BLARG\n\t\t\t    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n\t\t\t    DOCTYPE: S++, // <!DOCTYPE\n\t\t\t    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n\t\t\t    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n\t\t\t    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n\t\t\t    COMMENT_STARTING: S++, // <!-\n\t\t\t    COMMENT: S++, // <!--\n\t\t\t    COMMENT_ENDING: S++, // <!-- blah -\n\t\t\t    COMMENT_ENDED: S++, // <!-- blah --\n\t\t\t    CDATA: S++, // <![CDATA[ something\n\t\t\t    CDATA_ENDING: S++, // ]\n\t\t\t    CDATA_ENDING_2: S++, // ]]\n\t\t\t    PROC_INST: S++, // <?hi\n\t\t\t    PROC_INST_BODY: S++, // <?hi there\n\t\t\t    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n\t\t\t    OPEN_TAG: S++, // <strong\n\t\t\t    OPEN_TAG_SLASH: S++, // <strong /\n\t\t\t    ATTRIB: S++, // <a\n\t\t\t    ATTRIB_NAME: S++, // <a foo\n\t\t\t    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n\t\t\t    ATTRIB_VALUE: S++, // <a foo=\n\t\t\t    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n\t\t\t    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n\t\t\t    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n\t\t\t    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n\t\t\t    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n\t\t\t    CLOSE_TAG: S++, // </a\n\t\t\t    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n\t\t\t    SCRIPT: S++, // <script> ...\n\t\t\t    SCRIPT_ENDING: S++ // <script> ... <\n\t\t\t  };\n\n\t\t\t  sax.XML_ENTITIES = {\n\t\t\t    'amp': '&',\n\t\t\t    'gt': '>',\n\t\t\t    'lt': '<',\n\t\t\t    'quot': '\"',\n\t\t\t    'apos': \"'\"\n\t\t\t  };\n\n\t\t\t  sax.ENTITIES = {\n\t\t\t    'amp': '&',\n\t\t\t    'gt': '>',\n\t\t\t    'lt': '<',\n\t\t\t    'quot': '\"',\n\t\t\t    'apos': \"'\",\n\t\t\t    'AElig': 198,\n\t\t\t    'Aacute': 193,\n\t\t\t    'Acirc': 194,\n\t\t\t    'Agrave': 192,\n\t\t\t    'Aring': 197,\n\t\t\t    'Atilde': 195,\n\t\t\t    'Auml': 196,\n\t\t\t    'Ccedil': 199,\n\t\t\t    'ETH': 208,\n\t\t\t    'Eacute': 201,\n\t\t\t    'Ecirc': 202,\n\t\t\t    'Egrave': 200,\n\t\t\t    'Euml': 203,\n\t\t\t    'Iacute': 205,\n\t\t\t    'Icirc': 206,\n\t\t\t    'Igrave': 204,\n\t\t\t    'Iuml': 207,\n\t\t\t    'Ntilde': 209,\n\t\t\t    'Oacute': 211,\n\t\t\t    'Ocirc': 212,\n\t\t\t    'Ograve': 210,\n\t\t\t    'Oslash': 216,\n\t\t\t    'Otilde': 213,\n\t\t\t    'Ouml': 214,\n\t\t\t    'THORN': 222,\n\t\t\t    'Uacute': 218,\n\t\t\t    'Ucirc': 219,\n\t\t\t    'Ugrave': 217,\n\t\t\t    'Uuml': 220,\n\t\t\t    'Yacute': 221,\n\t\t\t    'aacute': 225,\n\t\t\t    'acirc': 226,\n\t\t\t    'aelig': 230,\n\t\t\t    'agrave': 224,\n\t\t\t    'aring': 229,\n\t\t\t    'atilde': 227,\n\t\t\t    'auml': 228,\n\t\t\t    'ccedil': 231,\n\t\t\t    'eacute': 233,\n\t\t\t    'ecirc': 234,\n\t\t\t    'egrave': 232,\n\t\t\t    'eth': 240,\n\t\t\t    'euml': 235,\n\t\t\t    'iacute': 237,\n\t\t\t    'icirc': 238,\n\t\t\t    'igrave': 236,\n\t\t\t    'iuml': 239,\n\t\t\t    'ntilde': 241,\n\t\t\t    'oacute': 243,\n\t\t\t    'ocirc': 244,\n\t\t\t    'ograve': 242,\n\t\t\t    'oslash': 248,\n\t\t\t    'otilde': 245,\n\t\t\t    'ouml': 246,\n\t\t\t    'szlig': 223,\n\t\t\t    'thorn': 254,\n\t\t\t    'uacute': 250,\n\t\t\t    'ucirc': 251,\n\t\t\t    'ugrave': 249,\n\t\t\t    'uuml': 252,\n\t\t\t    'yacute': 253,\n\t\t\t    'yuml': 255,\n\t\t\t    'copy': 169,\n\t\t\t    'reg': 174,\n\t\t\t    'nbsp': 160,\n\t\t\t    'iexcl': 161,\n\t\t\t    'cent': 162,\n\t\t\t    'pound': 163,\n\t\t\t    'curren': 164,\n\t\t\t    'yen': 165,\n\t\t\t    'brvbar': 166,\n\t\t\t    'sect': 167,\n\t\t\t    'uml': 168,\n\t\t\t    'ordf': 170,\n\t\t\t    'laquo': 171,\n\t\t\t    'not': 172,\n\t\t\t    'shy': 173,\n\t\t\t    'macr': 175,\n\t\t\t    'deg': 176,\n\t\t\t    'plusmn': 177,\n\t\t\t    'sup1': 185,\n\t\t\t    'sup2': 178,\n\t\t\t    'sup3': 179,\n\t\t\t    'acute': 180,\n\t\t\t    'micro': 181,\n\t\t\t    'para': 182,\n\t\t\t    'middot': 183,\n\t\t\t    'cedil': 184,\n\t\t\t    'ordm': 186,\n\t\t\t    'raquo': 187,\n\t\t\t    'frac14': 188,\n\t\t\t    'frac12': 189,\n\t\t\t    'frac34': 190,\n\t\t\t    'iquest': 191,\n\t\t\t    'times': 215,\n\t\t\t    'divide': 247,\n\t\t\t    'OElig': 338,\n\t\t\t    'oelig': 339,\n\t\t\t    'Scaron': 352,\n\t\t\t    'scaron': 353,\n\t\t\t    'Yuml': 376,\n\t\t\t    'fnof': 402,\n\t\t\t    'circ': 710,\n\t\t\t    'tilde': 732,\n\t\t\t    'Alpha': 913,\n\t\t\t    'Beta': 914,\n\t\t\t    'Gamma': 915,\n\t\t\t    'Delta': 916,\n\t\t\t    'Epsilon': 917,\n\t\t\t    'Zeta': 918,\n\t\t\t    'Eta': 919,\n\t\t\t    'Theta': 920,\n\t\t\t    'Iota': 921,\n\t\t\t    'Kappa': 922,\n\t\t\t    'Lambda': 923,\n\t\t\t    'Mu': 924,\n\t\t\t    'Nu': 925,\n\t\t\t    'Xi': 926,\n\t\t\t    'Omicron': 927,\n\t\t\t    'Pi': 928,\n\t\t\t    'Rho': 929,\n\t\t\t    'Sigma': 931,\n\t\t\t    'Tau': 932,\n\t\t\t    'Upsilon': 933,\n\t\t\t    'Phi': 934,\n\t\t\t    'Chi': 935,\n\t\t\t    'Psi': 936,\n\t\t\t    'Omega': 937,\n\t\t\t    'alpha': 945,\n\t\t\t    'beta': 946,\n\t\t\t    'gamma': 947,\n\t\t\t    'delta': 948,\n\t\t\t    'epsilon': 949,\n\t\t\t    'zeta': 950,\n\t\t\t    'eta': 951,\n\t\t\t    'theta': 952,\n\t\t\t    'iota': 953,\n\t\t\t    'kappa': 954,\n\t\t\t    'lambda': 955,\n\t\t\t    'mu': 956,\n\t\t\t    'nu': 957,\n\t\t\t    'xi': 958,\n\t\t\t    'omicron': 959,\n\t\t\t    'pi': 960,\n\t\t\t    'rho': 961,\n\t\t\t    'sigmaf': 962,\n\t\t\t    'sigma': 963,\n\t\t\t    'tau': 964,\n\t\t\t    'upsilon': 965,\n\t\t\t    'phi': 966,\n\t\t\t    'chi': 967,\n\t\t\t    'psi': 968,\n\t\t\t    'omega': 969,\n\t\t\t    'thetasym': 977,\n\t\t\t    'upsih': 978,\n\t\t\t    'piv': 982,\n\t\t\t    'ensp': 8194,\n\t\t\t    'emsp': 8195,\n\t\t\t    'thinsp': 8201,\n\t\t\t    'zwnj': 8204,\n\t\t\t    'zwj': 8205,\n\t\t\t    'lrm': 8206,\n\t\t\t    'rlm': 8207,\n\t\t\t    'ndash': 8211,\n\t\t\t    'mdash': 8212,\n\t\t\t    'lsquo': 8216,\n\t\t\t    'rsquo': 8217,\n\t\t\t    'sbquo': 8218,\n\t\t\t    'ldquo': 8220,\n\t\t\t    'rdquo': 8221,\n\t\t\t    'bdquo': 8222,\n\t\t\t    'dagger': 8224,\n\t\t\t    'Dagger': 8225,\n\t\t\t    'bull': 8226,\n\t\t\t    'hellip': 8230,\n\t\t\t    'permil': 8240,\n\t\t\t    'prime': 8242,\n\t\t\t    'Prime': 8243,\n\t\t\t    'lsaquo': 8249,\n\t\t\t    'rsaquo': 8250,\n\t\t\t    'oline': 8254,\n\t\t\t    'frasl': 8260,\n\t\t\t    'euro': 8364,\n\t\t\t    'image': 8465,\n\t\t\t    'weierp': 8472,\n\t\t\t    'real': 8476,\n\t\t\t    'trade': 8482,\n\t\t\t    'alefsym': 8501,\n\t\t\t    'larr': 8592,\n\t\t\t    'uarr': 8593,\n\t\t\t    'rarr': 8594,\n\t\t\t    'darr': 8595,\n\t\t\t    'harr': 8596,\n\t\t\t    'crarr': 8629,\n\t\t\t    'lArr': 8656,\n\t\t\t    'uArr': 8657,\n\t\t\t    'rArr': 8658,\n\t\t\t    'dArr': 8659,\n\t\t\t    'hArr': 8660,\n\t\t\t    'forall': 8704,\n\t\t\t    'part': 8706,\n\t\t\t    'exist': 8707,\n\t\t\t    'empty': 8709,\n\t\t\t    'nabla': 8711,\n\t\t\t    'isin': 8712,\n\t\t\t    'notin': 8713,\n\t\t\t    'ni': 8715,\n\t\t\t    'prod': 8719,\n\t\t\t    'sum': 8721,\n\t\t\t    'minus': 8722,\n\t\t\t    'lowast': 8727,\n\t\t\t    'radic': 8730,\n\t\t\t    'prop': 8733,\n\t\t\t    'infin': 8734,\n\t\t\t    'ang': 8736,\n\t\t\t    'and': 8743,\n\t\t\t    'or': 8744,\n\t\t\t    'cap': 8745,\n\t\t\t    'cup': 8746,\n\t\t\t    'int': 8747,\n\t\t\t    'there4': 8756,\n\t\t\t    'sim': 8764,\n\t\t\t    'cong': 8773,\n\t\t\t    'asymp': 8776,\n\t\t\t    'ne': 8800,\n\t\t\t    'equiv': 8801,\n\t\t\t    'le': 8804,\n\t\t\t    'ge': 8805,\n\t\t\t    'sub': 8834,\n\t\t\t    'sup': 8835,\n\t\t\t    'nsub': 8836,\n\t\t\t    'sube': 8838,\n\t\t\t    'supe': 8839,\n\t\t\t    'oplus': 8853,\n\t\t\t    'otimes': 8855,\n\t\t\t    'perp': 8869,\n\t\t\t    'sdot': 8901,\n\t\t\t    'lceil': 8968,\n\t\t\t    'rceil': 8969,\n\t\t\t    'lfloor': 8970,\n\t\t\t    'rfloor': 8971,\n\t\t\t    'lang': 9001,\n\t\t\t    'rang': 9002,\n\t\t\t    'loz': 9674,\n\t\t\t    'spades': 9824,\n\t\t\t    'clubs': 9827,\n\t\t\t    'hearts': 9829,\n\t\t\t    'diams': 9830\n\t\t\t  };\n\n\t\t\t  Object.keys(sax.ENTITIES).forEach(function (key) {\n\t\t\t    var e = sax.ENTITIES[key];\n\t\t\t    var s = typeof e === 'number' ? String.fromCharCode(e) : e;\n\t\t\t    sax.ENTITIES[key] = s;\n\t\t\t  });\n\n\t\t\t  for (var s in sax.STATE) {\n\t\t\t    sax.STATE[sax.STATE[s]] = s;\n\t\t\t  }\n\n\t\t\t  // shorthand\n\t\t\t  S = sax.STATE;\n\n\t\t\t  function emit (parser, event, data) {\n\t\t\t    parser[event] && parser[event](data);\n\t\t\t  }\n\n\t\t\t  function emitNode (parser, nodeType, data) {\n\t\t\t    if (parser.textNode) closeText(parser);\n\t\t\t    emit(parser, nodeType, data);\n\t\t\t  }\n\n\t\t\t  function closeText (parser) {\n\t\t\t    parser.textNode = textopts(parser.opt, parser.textNode);\n\t\t\t    if (parser.textNode) emit(parser, 'ontext', parser.textNode);\n\t\t\t    parser.textNode = '';\n\t\t\t  }\n\n\t\t\t  function textopts (opt, text) {\n\t\t\t    if (opt.trim) text = text.trim();\n\t\t\t    if (opt.normalize) text = text.replace(/\\s+/g, ' ');\n\t\t\t    return text\n\t\t\t  }\n\n\t\t\t  function error (parser, er) {\n\t\t\t    closeText(parser);\n\t\t\t    if (parser.trackPosition) {\n\t\t\t      er += '\\nLine: ' + parser.line +\n\t\t\t        '\\nColumn: ' + parser.column +\n\t\t\t        '\\nChar: ' + parser.c;\n\t\t\t    }\n\t\t\t    er = new Error(er);\n\t\t\t    parser.error = er;\n\t\t\t    emit(parser, 'onerror', er);\n\t\t\t    return parser\n\t\t\t  }\n\n\t\t\t  function end (parser) {\n\t\t\t    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');\n\t\t\t    if ((parser.state !== S.BEGIN) &&\n\t\t\t      (parser.state !== S.BEGIN_WHITESPACE) &&\n\t\t\t      (parser.state !== S.TEXT)) {\n\t\t\t      error(parser, 'Unexpected end');\n\t\t\t    }\n\t\t\t    closeText(parser);\n\t\t\t    parser.c = '';\n\t\t\t    parser.closed = true;\n\t\t\t    emit(parser, 'onend');\n\t\t\t    SAXParser.call(parser, parser.strict, parser.opt);\n\t\t\t    return parser\n\t\t\t  }\n\n\t\t\t  function strictFail (parser, message) {\n\t\t\t    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n\t\t\t      throw new Error('bad call to strictFail')\n\t\t\t    }\n\t\t\t    if (parser.strict) {\n\t\t\t      error(parser, message);\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  function newTag (parser) {\n\t\t\t    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n\t\t\t    var parent = parser.tags[parser.tags.length - 1] || parser;\n\t\t\t    var tag = parser.tag = { name: parser.tagName, attributes: {} };\n\n\t\t\t    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n\t\t\t    if (parser.opt.xmlns) {\n\t\t\t      tag.ns = parent.ns;\n\t\t\t    }\n\t\t\t    parser.attribList.length = 0;\n\t\t\t    emitNode(parser, 'onopentagstart', tag);\n\t\t\t  }\n\n\t\t\t  function qname (name, attribute) {\n\t\t\t    var i = name.indexOf(':');\n\t\t\t    var qualName = i < 0 ? [ '', name ] : name.split(':');\n\t\t\t    var prefix = qualName[0];\n\t\t\t    var local = qualName[1];\n\n\t\t\t    // <x \"xmlns\"=\"http://foo\">\n\t\t\t    if (attribute && name === 'xmlns') {\n\t\t\t      prefix = 'xmlns';\n\t\t\t      local = '';\n\t\t\t    }\n\n\t\t\t    return { prefix: prefix, local: local }\n\t\t\t  }\n\n\t\t\t  function attrib (parser) {\n\t\t\t    if (!parser.strict) {\n\t\t\t      parser.attribName = parser.attribName[parser.looseCase]();\n\t\t\t    }\n\n\t\t\t    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n\t\t\t      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n\t\t\t      parser.attribName = parser.attribValue = '';\n\t\t\t      return\n\t\t\t    }\n\n\t\t\t    if (parser.opt.xmlns) {\n\t\t\t      var qn = qname(parser.attribName, true);\n\t\t\t      var prefix = qn.prefix;\n\t\t\t      var local = qn.local;\n\n\t\t\t      if (prefix === 'xmlns') {\n\t\t\t        // namespace binding attribute. push the binding into scope\n\t\t\t        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n\t\t\t          strictFail(parser,\n\t\t\t            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n\t\t\t            'Actual: ' + parser.attribValue);\n\t\t\t        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n\t\t\t          strictFail(parser,\n\t\t\t            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n\t\t\t            'Actual: ' + parser.attribValue);\n\t\t\t        } else {\n\t\t\t          var tag = parser.tag;\n\t\t\t          var parent = parser.tags[parser.tags.length - 1] || parser;\n\t\t\t          if (tag.ns === parent.ns) {\n\t\t\t            tag.ns = Object.create(parent.ns);\n\t\t\t          }\n\t\t\t          tag.ns[local] = parser.attribValue;\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      // defer onattribute events until all attributes have been seen\n\t\t\t      // so any new bindings can take effect. preserve attribute order\n\t\t\t      // so deferred events can be emitted in document order\n\t\t\t      parser.attribList.push([parser.attribName, parser.attribValue]);\n\t\t\t    } else {\n\t\t\t      // in non-xmlns mode, we can emit the event right away\n\t\t\t      parser.tag.attributes[parser.attribName] = parser.attribValue;\n\t\t\t      emitNode(parser, 'onattribute', {\n\t\t\t        name: parser.attribName,\n\t\t\t        value: parser.attribValue\n\t\t\t      });\n\t\t\t    }\n\n\t\t\t    parser.attribName = parser.attribValue = '';\n\t\t\t  }\n\n\t\t\t  function openTag (parser, selfClosing) {\n\t\t\t    if (parser.opt.xmlns) {\n\t\t\t      // emit namespace binding events\n\t\t\t      var tag = parser.tag;\n\n\t\t\t      // add namespace info to tag\n\t\t\t      var qn = qname(parser.tagName);\n\t\t\t      tag.prefix = qn.prefix;\n\t\t\t      tag.local = qn.local;\n\t\t\t      tag.uri = tag.ns[qn.prefix] || '';\n\n\t\t\t      if (tag.prefix && !tag.uri) {\n\t\t\t        strictFail(parser, 'Unbound namespace prefix: ' +\n\t\t\t          JSON.stringify(parser.tagName));\n\t\t\t        tag.uri = qn.prefix;\n\t\t\t      }\n\n\t\t\t      var parent = parser.tags[parser.tags.length - 1] || parser;\n\t\t\t      if (tag.ns && parent.ns !== tag.ns) {\n\t\t\t        Object.keys(tag.ns).forEach(function (p) {\n\t\t\t          emitNode(parser, 'onopennamespace', {\n\t\t\t            prefix: p,\n\t\t\t            uri: tag.ns[p]\n\t\t\t          });\n\t\t\t        });\n\t\t\t      }\n\n\t\t\t      // handle deferred onattribute events\n\t\t\t      // Note: do not apply default ns to attributes:\n\t\t\t      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\t\t\t      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n\t\t\t        var nv = parser.attribList[i];\n\t\t\t        var name = nv[0];\n\t\t\t        var value = nv[1];\n\t\t\t        var qualName = qname(name, true);\n\t\t\t        var prefix = qualName.prefix;\n\t\t\t        var local = qualName.local;\n\t\t\t        var uri = prefix === '' ? '' : (tag.ns[prefix] || '');\n\t\t\t        var a = {\n\t\t\t          name: name,\n\t\t\t          value: value,\n\t\t\t          prefix: prefix,\n\t\t\t          local: local,\n\t\t\t          uri: uri\n\t\t\t        };\n\n\t\t\t        // if there's any attributes with an undefined namespace,\n\t\t\t        // then fail on them now.\n\t\t\t        if (prefix && prefix !== 'xmlns' && !uri) {\n\t\t\t          strictFail(parser, 'Unbound namespace prefix: ' +\n\t\t\t            JSON.stringify(prefix));\n\t\t\t          a.uri = prefix;\n\t\t\t        }\n\t\t\t        parser.tag.attributes[name] = a;\n\t\t\t        emitNode(parser, 'onattribute', a);\n\t\t\t      }\n\t\t\t      parser.attribList.length = 0;\n\t\t\t    }\n\n\t\t\t    parser.tag.isSelfClosing = !!selfClosing;\n\n\t\t\t    // process the tag\n\t\t\t    parser.sawRoot = true;\n\t\t\t    parser.tags.push(parser.tag);\n\t\t\t    emitNode(parser, 'onopentag', parser.tag);\n\t\t\t    if (!selfClosing) {\n\t\t\t      // special case for <script> in non-strict mode.\n\t\t\t      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n\t\t\t        parser.state = S.SCRIPT;\n\t\t\t      } else {\n\t\t\t        parser.state = S.TEXT;\n\t\t\t      }\n\t\t\t      parser.tag = null;\n\t\t\t      parser.tagName = '';\n\t\t\t    }\n\t\t\t    parser.attribName = parser.attribValue = '';\n\t\t\t    parser.attribList.length = 0;\n\t\t\t  }\n\n\t\t\t  function closeTag (parser) {\n\t\t\t    if (!parser.tagName) {\n\t\t\t      strictFail(parser, 'Weird empty close tag.');\n\t\t\t      parser.textNode += '</>';\n\t\t\t      parser.state = S.TEXT;\n\t\t\t      return\n\t\t\t    }\n\n\t\t\t    if (parser.script) {\n\t\t\t      if (parser.tagName !== 'script') {\n\t\t\t        parser.script += '</' + parser.tagName + '>';\n\t\t\t        parser.tagName = '';\n\t\t\t        parser.state = S.SCRIPT;\n\t\t\t        return\n\t\t\t      }\n\t\t\t      emitNode(parser, 'onscript', parser.script);\n\t\t\t      parser.script = '';\n\t\t\t    }\n\n\t\t\t    // first make sure that the closing tag actually exists.\n\t\t\t    // <a><b></c></b></a> will close everything, otherwise.\n\t\t\t    var t = parser.tags.length;\n\t\t\t    var tagName = parser.tagName;\n\t\t\t    if (!parser.strict) {\n\t\t\t      tagName = tagName[parser.looseCase]();\n\t\t\t    }\n\t\t\t    var closeTo = tagName;\n\t\t\t    while (t--) {\n\t\t\t      var close = parser.tags[t];\n\t\t\t      if (close.name !== closeTo) {\n\t\t\t        // fail the first time in strict mode\n\t\t\t        strictFail(parser, 'Unexpected close tag');\n\t\t\t      } else {\n\t\t\t        break\n\t\t\t      }\n\t\t\t    }\n\n\t\t\t    // didn't find it.  we already failed for strict, so just abort.\n\t\t\t    if (t < 0) {\n\t\t\t      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);\n\t\t\t      parser.textNode += '</' + parser.tagName + '>';\n\t\t\t      parser.state = S.TEXT;\n\t\t\t      return\n\t\t\t    }\n\t\t\t    parser.tagName = tagName;\n\t\t\t    var s = parser.tags.length;\n\t\t\t    while (s-- > t) {\n\t\t\t      var tag = parser.tag = parser.tags.pop();\n\t\t\t      parser.tagName = parser.tag.name;\n\t\t\t      emitNode(parser, 'onclosetag', parser.tagName);\n\n\t\t\t      var x = {};\n\t\t\t      for (var i in tag.ns) {\n\t\t\t        x[i] = tag.ns[i];\n\t\t\t      }\n\n\t\t\t      var parent = parser.tags[parser.tags.length - 1] || parser;\n\t\t\t      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n\t\t\t        // remove namespace bindings introduced by tag\n\t\t\t        Object.keys(tag.ns).forEach(function (p) {\n\t\t\t          var n = tag.ns[p];\n\t\t\t          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });\n\t\t\t        });\n\t\t\t      }\n\t\t\t    }\n\t\t\t    if (t === 0) parser.closedRoot = true;\n\t\t\t    parser.tagName = parser.attribValue = parser.attribName = '';\n\t\t\t    parser.attribList.length = 0;\n\t\t\t    parser.state = S.TEXT;\n\t\t\t  }\n\n\t\t\t  function parseEntity (parser) {\n\t\t\t    var entity = parser.entity;\n\t\t\t    var entityLC = entity.toLowerCase();\n\t\t\t    var num;\n\t\t\t    var numStr = '';\n\n\t\t\t    if (parser.ENTITIES[entity]) {\n\t\t\t      return parser.ENTITIES[entity]\n\t\t\t    }\n\t\t\t    if (parser.ENTITIES[entityLC]) {\n\t\t\t      return parser.ENTITIES[entityLC]\n\t\t\t    }\n\t\t\t    entity = entityLC;\n\t\t\t    if (entity.charAt(0) === '#') {\n\t\t\t      if (entity.charAt(1) === 'x') {\n\t\t\t        entity = entity.slice(2);\n\t\t\t        num = parseInt(entity, 16);\n\t\t\t        numStr = num.toString(16);\n\t\t\t      } else {\n\t\t\t        entity = entity.slice(1);\n\t\t\t        num = parseInt(entity, 10);\n\t\t\t        numStr = num.toString(10);\n\t\t\t      }\n\t\t\t    }\n\t\t\t    entity = entity.replace(/^0+/, '');\n\t\t\t    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n\t\t\t      strictFail(parser, 'Invalid character entity');\n\t\t\t      return '&' + parser.entity + ';'\n\t\t\t    }\n\n\t\t\t    return String.fromCodePoint(num)\n\t\t\t  }\n\n\t\t\t  function beginWhiteSpace (parser, c) {\n\t\t\t    if (c === '<') {\n\t\t\t      parser.state = S.OPEN_WAKA;\n\t\t\t      parser.startTagPosition = parser.position;\n\t\t\t    } else if (!isWhitespace(c)) {\n\t\t\t      // have to process this as a text node.\n\t\t\t      // weird, but happens.\n\t\t\t      strictFail(parser, 'Non-whitespace before first tag.');\n\t\t\t      parser.textNode = c;\n\t\t\t      parser.state = S.TEXT;\n\t\t\t    }\n\t\t\t  }\n\n\t\t\t  function charAt (chunk, i) {\n\t\t\t    var result = '';\n\t\t\t    if (i < chunk.length) {\n\t\t\t      result = chunk.charAt(i);\n\t\t\t    }\n\t\t\t    return result\n\t\t\t  }\n\n\t\t\t  function write (chunk) {\n\t\t\t    var parser = this;\n\t\t\t    if (this.error) {\n\t\t\t      throw this.error\n\t\t\t    }\n\t\t\t    if (parser.closed) {\n\t\t\t      return error(parser,\n\t\t\t        'Cannot write after close. Assign an onready handler.')\n\t\t\t    }\n\t\t\t    if (chunk === null) {\n\t\t\t      return end(parser)\n\t\t\t    }\n\t\t\t    if (typeof chunk === 'object') {\n\t\t\t      chunk = chunk.toString();\n\t\t\t    }\n\t\t\t    var i = 0;\n\t\t\t    var c = '';\n\t\t\t    while (true) {\n\t\t\t      c = charAt(chunk, i++);\n\t\t\t      parser.c = c;\n\n\t\t\t      if (!c) {\n\t\t\t        break\n\t\t\t      }\n\n\t\t\t      if (parser.trackPosition) {\n\t\t\t        parser.position++;\n\t\t\t        if (c === '\\n') {\n\t\t\t          parser.line++;\n\t\t\t          parser.column = 0;\n\t\t\t        } else {\n\t\t\t          parser.column++;\n\t\t\t        }\n\t\t\t      }\n\n\t\t\t      switch (parser.state) {\n\t\t\t        case S.BEGIN:\n\t\t\t          parser.state = S.BEGIN_WHITESPACE;\n\t\t\t          if (c === '\\uFEFF') {\n\t\t\t            continue\n\t\t\t          }\n\t\t\t          beginWhiteSpace(parser, c);\n\t\t\t          continue\n\n\t\t\t        case S.BEGIN_WHITESPACE:\n\t\t\t          beginWhiteSpace(parser, c);\n\t\t\t          continue\n\n\t\t\t        case S.TEXT:\n\t\t\t          if (parser.sawRoot && !parser.closedRoot) {\n\t\t\t            var starti = i - 1;\n\t\t\t            while (c && c !== '<' && c !== '&') {\n\t\t\t              c = charAt(chunk, i++);\n\t\t\t              if (c && parser.trackPosition) {\n\t\t\t                parser.position++;\n\t\t\t                if (c === '\\n') {\n\t\t\t                  parser.line++;\n\t\t\t                  parser.column = 0;\n\t\t\t                } else {\n\t\t\t                  parser.column++;\n\t\t\t                }\n\t\t\t              }\n\t\t\t            }\n\t\t\t            parser.textNode += chunk.substring(starti, i - 1);\n\t\t\t          }\n\t\t\t          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n\t\t\t            parser.state = S.OPEN_WAKA;\n\t\t\t            parser.startTagPosition = parser.position;\n\t\t\t          } else {\n\t\t\t            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n\t\t\t              strictFail(parser, 'Text data outside of root node.');\n\t\t\t            }\n\t\t\t            if (c === '&') {\n\t\t\t              parser.state = S.TEXT_ENTITY;\n\t\t\t            } else {\n\t\t\t              parser.textNode += c;\n\t\t\t            }\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.SCRIPT:\n\t\t\t          // only non-strict\n\t\t\t          if (c === '<') {\n\t\t\t            parser.state = S.SCRIPT_ENDING;\n\t\t\t          } else {\n\t\t\t            parser.script += c;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.SCRIPT_ENDING:\n\t\t\t          if (c === '/') {\n\t\t\t            parser.state = S.CLOSE_TAG;\n\t\t\t          } else {\n\t\t\t            parser.script += '<' + c;\n\t\t\t            parser.state = S.SCRIPT;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.OPEN_WAKA:\n\t\t\t          // either a /, ?, !, or text is coming next.\n\t\t\t          if (c === '!') {\n\t\t\t            parser.state = S.SGML_DECL;\n\t\t\t            parser.sgmlDecl = '';\n\t\t\t          } else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) {\n\t\t\t            parser.state = S.OPEN_TAG;\n\t\t\t            parser.tagName = c;\n\t\t\t          } else if (c === '/') {\n\t\t\t            parser.state = S.CLOSE_TAG;\n\t\t\t            parser.tagName = '';\n\t\t\t          } else if (c === '?') {\n\t\t\t            parser.state = S.PROC_INST;\n\t\t\t            parser.procInstName = parser.procInstBody = '';\n\t\t\t          } else {\n\t\t\t            strictFail(parser, 'Unencoded <');\n\t\t\t            // if there was some whitespace, then add that in.\n\t\t\t            if (parser.startTagPosition + 1 < parser.position) {\n\t\t\t              var pad = parser.position - parser.startTagPosition;\n\t\t\t              c = new Array(pad).join(' ') + c;\n\t\t\t            }\n\t\t\t            parser.textNode += '<' + c;\n\t\t\t            parser.state = S.TEXT;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.SGML_DECL:\n\t\t\t          if (parser.sgmlDecl + c === '--') {\n\t\t\t            parser.state = S.COMMENT;\n\t\t\t            parser.comment = '';\n\t\t\t            parser.sgmlDecl = '';\n\t\t\t            continue;\n\t\t\t          }\n\n\t\t\t          if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {\n\t\t\t            parser.state = S.DOCTYPE_DTD;\n\t\t\t            parser.doctype += '<!' + parser.sgmlDecl + c;\n\t\t\t            parser.sgmlDecl = '';\n\t\t\t          } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n\t\t\t            emitNode(parser, 'onopencdata');\n\t\t\t            parser.state = S.CDATA;\n\t\t\t            parser.sgmlDecl = '';\n\t\t\t            parser.cdata = '';\n\t\t\t          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n\t\t\t            parser.state = S.DOCTYPE;\n\t\t\t            if (parser.doctype || parser.sawRoot) {\n\t\t\t              strictFail(parser,\n\t\t\t                'Inappropriately located doctype declaration');\n\t\t\t            }\n\t\t\t            parser.doctype = '';\n\t\t\t            parser.sgmlDecl = '';\n\t\t\t          } else if (c === '>') {\n\t\t\t            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);\n\t\t\t            parser.sgmlDecl = '';\n\t\t\t            parser.state = S.TEXT;\n\t\t\t          } else if (isQuote(c)) {\n\t\t\t            parser.state = S.SGML_DECL_QUOTED;\n\t\t\t            parser.sgmlDecl += c;\n\t\t\t          } else {\n\t\t\t            parser.sgmlDecl += c;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.SGML_DECL_QUOTED:\n\t\t\t          if (c === parser.q) {\n\t\t\t            parser.state = S.SGML_DECL;\n\t\t\t            parser.q = '';\n\t\t\t          }\n\t\t\t          parser.sgmlDecl += c;\n\t\t\t          continue\n\n\t\t\t        case S.DOCTYPE:\n\t\t\t          if (c === '>') {\n\t\t\t            parser.state = S.TEXT;\n\t\t\t            emitNode(parser, 'ondoctype', parser.doctype);\n\t\t\t            parser.doctype = true; // just remember that we saw it.\n\t\t\t          } else {\n\t\t\t            parser.doctype += c;\n\t\t\t            if (c === '[') {\n\t\t\t              parser.state = S.DOCTYPE_DTD;\n\t\t\t            } else if (isQuote(c)) {\n\t\t\t              parser.state = S.DOCTYPE_QUOTED;\n\t\t\t              parser.q = c;\n\t\t\t            }\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.DOCTYPE_QUOTED:\n\t\t\t          parser.doctype += c;\n\t\t\t          if (c === parser.q) {\n\t\t\t            parser.q = '';\n\t\t\t            parser.state = S.DOCTYPE;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.DOCTYPE_DTD:\n\t\t\t          if (c === ']') {\n\t\t\t            parser.doctype += c;\n\t\t\t            parser.state = S.DOCTYPE;\n\t\t\t          } else if (c === '<') {\n\t\t\t            parser.state = S.OPEN_WAKA;\n\t\t\t            parser.startTagPosition = parser.position;\n\t\t\t          } else if (isQuote(c)) {\n\t\t\t            parser.doctype += c;\n\t\t\t            parser.state = S.DOCTYPE_DTD_QUOTED;\n\t\t\t            parser.q = c;\n\t\t\t          } else {\n\t\t\t            parser.doctype += c;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.DOCTYPE_DTD_QUOTED:\n\t\t\t          parser.doctype += c;\n\t\t\t          if (c === parser.q) {\n\t\t\t            parser.state = S.DOCTYPE_DTD;\n\t\t\t            parser.q = '';\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.COMMENT:\n\t\t\t          if (c === '-') {\n\t\t\t            parser.state = S.COMMENT_ENDING;\n\t\t\t          } else {\n\t\t\t            parser.comment += c;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.COMMENT_ENDING:\n\t\t\t          if (c === '-') {\n\t\t\t            parser.state = S.COMMENT_ENDED;\n\t\t\t            parser.comment = textopts(parser.opt, parser.comment);\n\t\t\t            if (parser.comment) {\n\t\t\t              emitNode(parser, 'oncomment', parser.comment);\n\t\t\t            }\n\t\t\t            parser.comment = '';\n\t\t\t          } else {\n\t\t\t            parser.comment += '-' + c;\n\t\t\t            parser.state = S.COMMENT;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.COMMENT_ENDED:\n\t\t\t          if (c !== '>') {\n\t\t\t            strictFail(parser, 'Malformed comment');\n\t\t\t            // allow <!-- blah -- bloo --> in non-strict mode,\n\t\t\t            // which is a comment of \" blah -- bloo \"\n\t\t\t            parser.comment += '--' + c;\n\t\t\t            parser.state = S.COMMENT;\n\t\t\t          } else if (parser.doctype && parser.doctype !== true) {\n\t\t\t            parser.state = S.DOCTYPE_DTD;\n\t\t\t          } else {\n\t\t\t            parser.state = S.TEXT;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.CDATA:\n\t\t\t          if (c === ']') {\n\t\t\t            parser.state = S.CDATA_ENDING;\n\t\t\t          } else {\n\t\t\t            parser.cdata += c;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.CDATA_ENDING:\n\t\t\t          if (c === ']') {\n\t\t\t            parser.state = S.CDATA_ENDING_2;\n\t\t\t          } else {\n\t\t\t            parser.cdata += ']' + c;\n\t\t\t            parser.state = S.CDATA;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.CDATA_ENDING_2:\n\t\t\t          if (c === '>') {\n\t\t\t            if (parser.cdata) {\n\t\t\t              emitNode(parser, 'oncdata', parser.cdata);\n\t\t\t            }\n\t\t\t            emitNode(parser, 'onclosecdata');\n\t\t\t            parser.cdata = '';\n\t\t\t            parser.state = S.TEXT;\n\t\t\t          } else if (c === ']') {\n\t\t\t            parser.cdata += ']';\n\t\t\t          } else {\n\t\t\t            parser.cdata += ']]' + c;\n\t\t\t            parser.state = S.CDATA;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.PROC_INST:\n\t\t\t          if (c === '?') {\n\t\t\t            parser.state = S.PROC_INST_ENDING;\n\t\t\t          } else if (isWhitespace(c)) {\n\t\t\t            parser.state = S.PROC_INST_BODY;\n\t\t\t          } else {\n\t\t\t            parser.procInstName += c;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.PROC_INST_BODY:\n\t\t\t          if (!parser.procInstBody && isWhitespace(c)) {\n\t\t\t            continue\n\t\t\t          } else if (c === '?') {\n\t\t\t            parser.state = S.PROC_INST_ENDING;\n\t\t\t          } else {\n\t\t\t            parser.procInstBody += c;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.PROC_INST_ENDING:\n\t\t\t          if (c === '>') {\n\t\t\t            emitNode(parser, 'onprocessinginstruction', {\n\t\t\t              name: parser.procInstName,\n\t\t\t              body: parser.procInstBody\n\t\t\t            });\n\t\t\t            parser.procInstName = parser.procInstBody = '';\n\t\t\t            parser.state = S.TEXT;\n\t\t\t          } else {\n\t\t\t            parser.procInstBody += '?' + c;\n\t\t\t            parser.state = S.PROC_INST_BODY;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.OPEN_TAG:\n\t\t\t          if (isMatch(nameBody, c)) {\n\t\t\t            parser.tagName += c;\n\t\t\t          } else {\n\t\t\t            newTag(parser);\n\t\t\t            if (c === '>') {\n\t\t\t              openTag(parser);\n\t\t\t            } else if (c === '/') {\n\t\t\t              parser.state = S.OPEN_TAG_SLASH;\n\t\t\t            } else {\n\t\t\t              if (!isWhitespace(c)) {\n\t\t\t                strictFail(parser, 'Invalid character in tag name');\n\t\t\t              }\n\t\t\t              parser.state = S.ATTRIB;\n\t\t\t            }\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.OPEN_TAG_SLASH:\n\t\t\t          if (c === '>') {\n\t\t\t            openTag(parser, true);\n\t\t\t            closeTag(parser);\n\t\t\t          } else {\n\t\t\t            strictFail(parser, 'Forward-slash in opening tag not followed by >');\n\t\t\t            parser.state = S.ATTRIB;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.ATTRIB:\n\t\t\t          // haven't read the attribute name yet.\n\t\t\t          if (isWhitespace(c)) {\n\t\t\t            continue\n\t\t\t          } else if (c === '>') {\n\t\t\t            openTag(parser);\n\t\t\t          } else if (c === '/') {\n\t\t\t            parser.state = S.OPEN_TAG_SLASH;\n\t\t\t          } else if (isMatch(nameStart, c)) {\n\t\t\t            parser.attribName = c;\n\t\t\t            parser.attribValue = '';\n\t\t\t            parser.state = S.ATTRIB_NAME;\n\t\t\t          } else {\n\t\t\t            strictFail(parser, 'Invalid attribute name');\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.ATTRIB_NAME:\n\t\t\t          if (c === '=') {\n\t\t\t            parser.state = S.ATTRIB_VALUE;\n\t\t\t          } else if (c === '>') {\n\t\t\t            strictFail(parser, 'Attribute without value');\n\t\t\t            parser.attribValue = parser.attribName;\n\t\t\t            attrib(parser);\n\t\t\t            openTag(parser);\n\t\t\t          } else if (isWhitespace(c)) {\n\t\t\t            parser.state = S.ATTRIB_NAME_SAW_WHITE;\n\t\t\t          } else if (isMatch(nameBody, c)) {\n\t\t\t            parser.attribName += c;\n\t\t\t          } else {\n\t\t\t            strictFail(parser, 'Invalid attribute name');\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.ATTRIB_NAME_SAW_WHITE:\n\t\t\t          if (c === '=') {\n\t\t\t            parser.state = S.ATTRIB_VALUE;\n\t\t\t          } else if (isWhitespace(c)) {\n\t\t\t            continue\n\t\t\t          } else {\n\t\t\t            strictFail(parser, 'Attribute without value');\n\t\t\t            parser.tag.attributes[parser.attribName] = '';\n\t\t\t            parser.attribValue = '';\n\t\t\t            emitNode(parser, 'onattribute', {\n\t\t\t              name: parser.attribName,\n\t\t\t              value: ''\n\t\t\t            });\n\t\t\t            parser.attribName = '';\n\t\t\t            if (c === '>') {\n\t\t\t              openTag(parser);\n\t\t\t            } else if (isMatch(nameStart, c)) {\n\t\t\t              parser.attribName = c;\n\t\t\t              parser.state = S.ATTRIB_NAME;\n\t\t\t            } else {\n\t\t\t              strictFail(parser, 'Invalid attribute name');\n\t\t\t              parser.state = S.ATTRIB;\n\t\t\t            }\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.ATTRIB_VALUE:\n\t\t\t          if (isWhitespace(c)) {\n\t\t\t            continue\n\t\t\t          } else if (isQuote(c)) {\n\t\t\t            parser.q = c;\n\t\t\t            parser.state = S.ATTRIB_VALUE_QUOTED;\n\t\t\t          } else {\n\t\t\t            if (!parser.opt.unquotedAttributeValues) {\n\t\t\t              error(parser, 'Unquoted attribute value');\n\t\t\t            }\n\t\t\t            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n\t\t\t            parser.attribValue = c;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.ATTRIB_VALUE_QUOTED:\n\t\t\t          if (c !== parser.q) {\n\t\t\t            if (c === '&') {\n\t\t\t              parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n\t\t\t            } else {\n\t\t\t              parser.attribValue += c;\n\t\t\t            }\n\t\t\t            continue\n\t\t\t          }\n\t\t\t          attrib(parser);\n\t\t\t          parser.q = '';\n\t\t\t          parser.state = S.ATTRIB_VALUE_CLOSED;\n\t\t\t          continue\n\n\t\t\t        case S.ATTRIB_VALUE_CLOSED:\n\t\t\t          if (isWhitespace(c)) {\n\t\t\t            parser.state = S.ATTRIB;\n\t\t\t          } else if (c === '>') {\n\t\t\t            openTag(parser);\n\t\t\t          } else if (c === '/') {\n\t\t\t            parser.state = S.OPEN_TAG_SLASH;\n\t\t\t          } else if (isMatch(nameStart, c)) {\n\t\t\t            strictFail(parser, 'No whitespace between attributes');\n\t\t\t            parser.attribName = c;\n\t\t\t            parser.attribValue = '';\n\t\t\t            parser.state = S.ATTRIB_NAME;\n\t\t\t          } else {\n\t\t\t            strictFail(parser, 'Invalid attribute name');\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.ATTRIB_VALUE_UNQUOTED:\n\t\t\t          if (!isAttribEnd(c)) {\n\t\t\t            if (c === '&') {\n\t\t\t              parser.state = S.ATTRIB_VALUE_ENTITY_U;\n\t\t\t            } else {\n\t\t\t              parser.attribValue += c;\n\t\t\t            }\n\t\t\t            continue\n\t\t\t          }\n\t\t\t          attrib(parser);\n\t\t\t          if (c === '>') {\n\t\t\t            openTag(parser);\n\t\t\t          } else {\n\t\t\t            parser.state = S.ATTRIB;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.CLOSE_TAG:\n\t\t\t          if (!parser.tagName) {\n\t\t\t            if (isWhitespace(c)) {\n\t\t\t              continue\n\t\t\t            } else if (notMatch(nameStart, c)) {\n\t\t\t              if (parser.script) {\n\t\t\t                parser.script += '</' + c;\n\t\t\t                parser.state = S.SCRIPT;\n\t\t\t              } else {\n\t\t\t                strictFail(parser, 'Invalid tagname in closing tag.');\n\t\t\t              }\n\t\t\t            } else {\n\t\t\t              parser.tagName = c;\n\t\t\t            }\n\t\t\t          } else if (c === '>') {\n\t\t\t            closeTag(parser);\n\t\t\t          } else if (isMatch(nameBody, c)) {\n\t\t\t            parser.tagName += c;\n\t\t\t          } else if (parser.script) {\n\t\t\t            parser.script += '</' + parser.tagName;\n\t\t\t            parser.tagName = '';\n\t\t\t            parser.state = S.SCRIPT;\n\t\t\t          } else {\n\t\t\t            if (!isWhitespace(c)) {\n\t\t\t              strictFail(parser, 'Invalid tagname in closing tag');\n\t\t\t            }\n\t\t\t            parser.state = S.CLOSE_TAG_SAW_WHITE;\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.CLOSE_TAG_SAW_WHITE:\n\t\t\t          if (isWhitespace(c)) {\n\t\t\t            continue\n\t\t\t          }\n\t\t\t          if (c === '>') {\n\t\t\t            closeTag(parser);\n\t\t\t          } else {\n\t\t\t            strictFail(parser, 'Invalid characters in closing tag');\n\t\t\t          }\n\t\t\t          continue\n\n\t\t\t        case S.TEXT_ENTITY:\n\t\t\t        case S.ATTRIB_VALUE_ENTITY_Q:\n\t\t\t        case S.ATTRIB_VALUE_ENTITY_U:\n\t\t\t          var returnState;\n\t\t\t          var buffer;\n\t\t\t          switch (parser.state) {\n\t\t\t            case S.TEXT_ENTITY:\n\t\t\t              returnState = S.TEXT;\n\t\t\t              buffer = 'textNode';\n\t\t\t              break\n\n\t\t\t            case S.ATTRIB_VALUE_ENTITY_Q:\n\t\t\t              returnState = S.ATTRIB_VALUE_QUOTED;\n\t\t\t              buffer = 'attribValue';\n\t\t\t              break\n\n\t\t\t            case S.ATTRIB_VALUE_ENTITY_U:\n\t\t\t              returnState = S.ATTRIB_VALUE_UNQUOTED;\n\t\t\t              buffer = 'attribValue';\n\t\t\t              break\n\t\t\t          }\n\n\t\t\t          if (c === ';') {\n\t\t\t            var parsedEntity = parseEntity(parser);\n\t\t\t            if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {\n\t\t\t              parser.entity = '';\n\t\t\t              parser.state = returnState;\n\t\t\t              parser.write(parsedEntity);\n\t\t\t            } else {\n\t\t\t              parser[buffer] += parsedEntity;\n\t\t\t              parser.entity = '';\n\t\t\t              parser.state = returnState;\n\t\t\t            }\n\t\t\t          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n\t\t\t            parser.entity += c;\n\t\t\t          } else {\n\t\t\t            strictFail(parser, 'Invalid character in entity name');\n\t\t\t            parser[buffer] += '&' + parser.entity + c;\n\t\t\t            parser.entity = '';\n\t\t\t            parser.state = returnState;\n\t\t\t          }\n\n\t\t\t          continue\n\n\t\t\t        default: /* istanbul ignore next */ {\n\t\t\t          throw new Error(parser, 'Unknown state: ' + parser.state)\n\t\t\t        }\n\t\t\t      }\n\t\t\t    } // while\n\n\t\t\t    if (parser.position >= parser.bufferCheckPosition) {\n\t\t\t      checkBufferLength(parser);\n\t\t\t    }\n\t\t\t    return parser\n\t\t\t  }\n\n\t\t\t  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n\t\t\t  /* istanbul ignore next */\n\t\t\t  if (!String.fromCodePoint) {\n\t\t\t    (function () {\n\t\t\t      var stringFromCharCode = String.fromCharCode;\n\t\t\t      var floor = Math.floor;\n\t\t\t      var fromCodePoint = function () {\n\t\t\t        var MAX_SIZE = 0x4000;\n\t\t\t        var codeUnits = [];\n\t\t\t        var highSurrogate;\n\t\t\t        var lowSurrogate;\n\t\t\t        var index = -1;\n\t\t\t        var length = arguments.length;\n\t\t\t        if (!length) {\n\t\t\t          return ''\n\t\t\t        }\n\t\t\t        var result = '';\n\t\t\t        while (++index < length) {\n\t\t\t          var codePoint = Number(arguments[index]);\n\t\t\t          if (\n\t\t\t            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t            codePoint < 0 || // not a valid Unicode code point\n\t\t\t            codePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t            floor(codePoint) !== codePoint // not an integer\n\t\t\t          ) {\n\t\t\t            throw RangeError('Invalid code point: ' + codePoint)\n\t\t\t          }\n\t\t\t          if (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t            codeUnits.push(codePoint);\n\t\t\t          } else { // Astral code point; split in surrogate halves\n\t\t\t            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t            codePoint -= 0x10000;\n\t\t\t            highSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t            lowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t            codeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t          }\n\t\t\t          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n\t\t\t            result += stringFromCharCode.apply(null, codeUnits);\n\t\t\t            codeUnits.length = 0;\n\t\t\t          }\n\t\t\t        }\n\t\t\t        return result\n\t\t\t      };\n\t\t\t      /* istanbul ignore next */\n\t\t\t      if (Object.defineProperty) {\n\t\t\t        Object.defineProperty(String, 'fromCodePoint', {\n\t\t\t          value: fromCodePoint,\n\t\t\t          configurable: true,\n\t\t\t          writable: true\n\t\t\t        });\n\t\t\t      } else {\n\t\t\t        String.fromCodePoint = fromCodePoint;\n\t\t\t      }\n\t\t\t    }());\n\t\t\t  }\n\t\t\t})(exports); \n\t\t} (sax));\n\t\treturn sax;\n\t}\n\n\tvar require$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_events);\n\n\tvar bom = {};\n\n\tvar hasRequiredBom;\n\n\tfunction requireBom () {\n\t\tif (hasRequiredBom) return bom;\n\t\thasRequiredBom = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  bom.stripBOM = function(str) {\n\t\t    if (str[0] === '\\uFEFF') {\n\t\t      return str.substring(1);\n\t\t    } else {\n\t\t      return str;\n\t\t    }\n\t\t  };\n\n\t\t}).call(bom);\n\t\treturn bom;\n\t}\n\n\tvar processors = {};\n\n\tvar hasRequiredProcessors;\n\n\tfunction requireProcessors () {\n\t\tif (hasRequiredProcessors) return processors;\n\t\thasRequiredProcessors = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var prefixMatch;\n\n\t\t  prefixMatch = new RegExp(/(?!xmlns)^.*:/);\n\n\t\t  processors.normalize = function(str) {\n\t\t    return str.toLowerCase();\n\t\t  };\n\n\t\t  processors.firstCharLowerCase = function(str) {\n\t\t    return str.charAt(0).toLowerCase() + str.slice(1);\n\t\t  };\n\n\t\t  processors.stripPrefix = function(str) {\n\t\t    return str.replace(prefixMatch, '');\n\t\t  };\n\n\t\t  processors.parseNumbers = function(str) {\n\t\t    if (!isNaN(str)) {\n\t\t      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);\n\t\t    }\n\t\t    return str;\n\t\t  };\n\n\t\t  processors.parseBooleans = function(str) {\n\t\t    if (/^(?:true|false)$/i.test(str)) {\n\t\t      str = str.toLowerCase() === 'true';\n\t\t    }\n\t\t    return str;\n\t\t  };\n\n\t\t}).call(processors);\n\t\treturn processors;\n\t}\n\n\t/*\n\tMIT Licence\n\tCopyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola\n\thttps://github.com/YuzuJS/setImmediate/blob/f1ccbfdf09cb93aadf77c4aa749ea554503b9234/LICENSE.txt\n\t*/\n\n\tvar nextHandle = 1; // Spec says greater than zero\n\tvar tasksByHandle = {};\n\tvar currentlyRunningATask = false;\n\tvar doc = global$1.document;\n\tvar registerImmediate;\n\n\tfunction setImmediate(callback) {\n\t  // Callback can either be a function or a string\n\t  if (typeof callback !== \"function\") {\n\t    callback = new Function(\"\" + callback);\n\t  }\n\t  // Copy function arguments\n\t  var args = new Array(arguments.length - 1);\n\t  for (var i = 0; i < args.length; i++) {\n\t      args[i] = arguments[i + 1];\n\t  }\n\t  // Store and register the task\n\t  var task = { callback: callback, args: args };\n\t  tasksByHandle[nextHandle] = task;\n\t  registerImmediate(nextHandle);\n\t  return nextHandle++;\n\t}\n\n\tfunction clearImmediate(handle) {\n\t    delete tasksByHandle[handle];\n\t}\n\n\tfunction run(task) {\n\t    var callback = task.callback;\n\t    var args = task.args;\n\t    switch (args.length) {\n\t    case 0:\n\t        callback();\n\t        break;\n\t    case 1:\n\t        callback(args[0]);\n\t        break;\n\t    case 2:\n\t        callback(args[0], args[1]);\n\t        break;\n\t    case 3:\n\t        callback(args[0], args[1], args[2]);\n\t        break;\n\t    default:\n\t        callback.apply(undefined, args);\n\t        break;\n\t    }\n\t}\n\n\tfunction runIfPresent(handle) {\n\t    // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n\t    // So if we're currently running a task, we'll need to delay this invocation.\n\t    if (currentlyRunningATask) {\n\t        // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n\t        // \"too much recursion\" error.\n\t        setTimeout(runIfPresent, 0, handle);\n\t    } else {\n\t        var task = tasksByHandle[handle];\n\t        if (task) {\n\t            currentlyRunningATask = true;\n\t            try {\n\t                run(task);\n\t            } finally {\n\t                clearImmediate(handle);\n\t                currentlyRunningATask = false;\n\t            }\n\t        }\n\t    }\n\t}\n\n\tfunction installNextTickImplementation() {\n\t    registerImmediate = function(handle) {\n\t        browser$1.nextTick(function () { runIfPresent(handle); });\n\t    };\n\t}\n\n\tfunction canUsePostMessage() {\n\t    // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n\t    // where `global.postMessage` means something completely different and can't be used for this purpose.\n\t    if (global$1.postMessage && !global$1.importScripts) {\n\t        var postMessageIsAsynchronous = true;\n\t        var oldOnMessage = global$1.onmessage;\n\t        global$1.onmessage = function() {\n\t            postMessageIsAsynchronous = false;\n\t        };\n\t        global$1.postMessage(\"\", \"*\");\n\t        global$1.onmessage = oldOnMessage;\n\t        return postMessageIsAsynchronous;\n\t    }\n\t}\n\n\tfunction installPostMessageImplementation() {\n\t    // Installs an event handler on `global` for the `message` event: see\n\t    // * https://developer.mozilla.org/en/DOM/window.postMessage\n\t    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n\t    var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n\t    var onGlobalMessage = function(event) {\n\t        if (event.source === global$1 &&\n\t            typeof event.data === \"string\" &&\n\t            event.data.indexOf(messagePrefix) === 0) {\n\t            runIfPresent(+event.data.slice(messagePrefix.length));\n\t        }\n\t    };\n\n\t    if (global$1.addEventListener) {\n\t        global$1.addEventListener(\"message\", onGlobalMessage, false);\n\t    } else {\n\t        global$1.attachEvent(\"onmessage\", onGlobalMessage);\n\t    }\n\n\t    registerImmediate = function(handle) {\n\t        global$1.postMessage(messagePrefix + handle, \"*\");\n\t    };\n\t}\n\n\tfunction installMessageChannelImplementation() {\n\t    var channel = new MessageChannel();\n\t    channel.port1.onmessage = function(event) {\n\t        var handle = event.data;\n\t        runIfPresent(handle);\n\t    };\n\n\t    registerImmediate = function(handle) {\n\t        channel.port2.postMessage(handle);\n\t    };\n\t}\n\n\tfunction installReadyStateChangeImplementation() {\n\t    var html = doc.documentElement;\n\t    registerImmediate = function(handle) {\n\t        // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t        // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t        var script = doc.createElement(\"script\");\n\t        script.onreadystatechange = function () {\n\t            runIfPresent(handle);\n\t            script.onreadystatechange = null;\n\t            html.removeChild(script);\n\t            script = null;\n\t        };\n\t        html.appendChild(script);\n\t    };\n\t}\n\n\tfunction installSetTimeoutImplementation() {\n\t    registerImmediate = function(handle) {\n\t        setTimeout(runIfPresent, 0, handle);\n\t    };\n\t}\n\n\t// If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n\tvar attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global$1);\n\tattachTo = attachTo && attachTo.setTimeout ? attachTo : global$1;\n\n\t// Don't get fooled by e.g. browserify environments.\n\tif ({}.toString.call(global$1.process) === \"[object process]\") {\n\t    // For Node.js before 0.9\n\t    installNextTickImplementation();\n\n\t} else if (canUsePostMessage()) {\n\t    // For non-IE10 modern browsers\n\t    installPostMessageImplementation();\n\n\t} else if (global$1.MessageChannel) {\n\t    // For web workers, where supported\n\t    installMessageChannelImplementation();\n\n\t} else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n\t    // For IE 68\n\t    installReadyStateChangeImplementation();\n\n\t} else {\n\t    // For older browsers\n\t    installSetTimeoutImplementation();\n\t}\n\n\t// DOM APIs, for completeness\n\tvar apply = Function.prototype.apply;\n\n\tfunction clearInterval(timeout) {\n\t  if (typeof timeout === 'number' && typeof global$1.clearInterval === 'function') {\n\t    global$1.clearInterval(timeout);\n\t  } else {\n\t    clearFn(timeout);\n\t  }\n\t}\n\tfunction clearTimeout$1(timeout) {\n\t  if (typeof timeout === 'number' && typeof global$1.clearTimeout === 'function') {\n\t    global$1.clearTimeout(timeout);\n\t  } else {\n\t    clearFn(timeout);\n\t  }\n\t}\n\tfunction clearFn(timeout) {\n\t  if (timeout && typeof timeout.close === 'function') {\n\t    timeout.close();\n\t  }\n\t}\n\tfunction setTimeout$1() {\n\t  return new Timeout(apply.call(global$1.setTimeout, window, arguments));\n\t}\n\tfunction setInterval() {\n\t  return new Timeout(apply.call(global$1.setInterval, window, arguments));\n\t}\n\n\tfunction Timeout(id) {\n\t  this._id = id;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  clearFn(this._id);\n\t};\n\n\t// Does not start the time, just sets up the members needed.\n\tfunction enroll(item, msecs) {\n\t  clearTimeout$1(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t}\n\n\tfunction unenroll(item) {\n\t  clearTimeout$1(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t}\n\tvar _unrefActive = active;\n\tfunction active(item) {\n\t  clearTimeout$1(item._idleTimeoutId);\n\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout$1(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t}\n\n\tvar _polyfillNode_timers = {\n\t  setImmediate: setImmediate,\n\t  clearImmediate: clearImmediate,\n\t  setTimeout: setTimeout$1,\n\t  clearTimeout: clearTimeout$1,\n\t  setInterval: setInterval,\n\t  clearInterval: clearInterval,\n\t  active: active,\n\t  unenroll: unenroll,\n\t  _unrefActive: _unrefActive,\n\t  enroll: enroll\n\t};\n\n\tvar _polyfillNode_timers$1 = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\t_unrefActive: _unrefActive,\n\t\tactive: active,\n\t\tclearImmediate: clearImmediate,\n\t\tclearInterval: clearInterval,\n\t\tclearTimeout: clearTimeout$1,\n\t\tdefault: _polyfillNode_timers,\n\t\tenroll: enroll,\n\t\tsetImmediate: setImmediate,\n\t\tsetInterval: setInterval,\n\t\tsetTimeout: setTimeout$1,\n\t\tunenroll: unenroll\n\t});\n\n\tvar require$4 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_timers$1);\n\n\tvar hasRequiredParser;\n\n\tfunction requireParser () {\n\t\tif (hasRequiredParser) return parser;\n\t\thasRequiredParser = 1;\n\t\t(function (exports) {\n\t\t\t// Generated by CoffeeScript 1.12.7\n\t\t\t(function() {\n\t\t\t  var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate,\n\t\t\t    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t\t  sax = requireSax();\n\n\t\t\t  events = require$1;\n\n\t\t\t  bom = requireBom();\n\n\t\t\t  processors = requireProcessors();\n\n\t\t\t  setImmediate = require$4.setImmediate;\n\n\t\t\t  defaults = requireDefaults().defaults;\n\n\t\t\t  isEmpty = function(thing) {\n\t\t\t    return typeof thing === \"object\" && (thing != null) && Object.keys(thing).length === 0;\n\t\t\t  };\n\n\t\t\t  processItem = function(processors, item, key) {\n\t\t\t    var i, len, process;\n\t\t\t    for (i = 0, len = processors.length; i < len; i++) {\n\t\t\t      process = processors[i];\n\t\t\t      item = process(item, key);\n\t\t\t    }\n\t\t\t    return item;\n\t\t\t  };\n\n\t\t\t  defineProperty = function(obj, key, value) {\n\t\t\t    var descriptor;\n\t\t\t    descriptor = Object.create(null);\n\t\t\t    descriptor.value = value;\n\t\t\t    descriptor.writable = true;\n\t\t\t    descriptor.enumerable = true;\n\t\t\t    descriptor.configurable = true;\n\t\t\t    return Object.defineProperty(obj, key, descriptor);\n\t\t\t  };\n\n\t\t\t  exports.Parser = (function(superClass) {\n\t\t\t    extend(Parser, superClass);\n\n\t\t\t    function Parser(opts) {\n\t\t\t      this.parseStringPromise = bind(this.parseStringPromise, this);\n\t\t\t      this.parseString = bind(this.parseString, this);\n\t\t\t      this.reset = bind(this.reset, this);\n\t\t\t      this.assignOrPush = bind(this.assignOrPush, this);\n\t\t\t      this.processAsync = bind(this.processAsync, this);\n\t\t\t      var key, ref, value;\n\t\t\t      if (!(this instanceof exports.Parser)) {\n\t\t\t        return new exports.Parser(opts);\n\t\t\t      }\n\t\t\t      this.options = {};\n\t\t\t      ref = defaults[\"0.2\"];\n\t\t\t      for (key in ref) {\n\t\t\t        if (!hasProp.call(ref, key)) continue;\n\t\t\t        value = ref[key];\n\t\t\t        this.options[key] = value;\n\t\t\t      }\n\t\t\t      for (key in opts) {\n\t\t\t        if (!hasProp.call(opts, key)) continue;\n\t\t\t        value = opts[key];\n\t\t\t        this.options[key] = value;\n\t\t\t      }\n\t\t\t      if (this.options.xmlns) {\n\t\t\t        this.options.xmlnskey = this.options.attrkey + \"ns\";\n\t\t\t      }\n\t\t\t      if (this.options.normalizeTags) {\n\t\t\t        if (!this.options.tagNameProcessors) {\n\t\t\t          this.options.tagNameProcessors = [];\n\t\t\t        }\n\t\t\t        this.options.tagNameProcessors.unshift(processors.normalize);\n\t\t\t      }\n\t\t\t      this.reset();\n\t\t\t    }\n\n\t\t\t    Parser.prototype.processAsync = function() {\n\t\t\t      var chunk, err;\n\t\t\t      try {\n\t\t\t        if (this.remaining.length <= this.options.chunkSize) {\n\t\t\t          chunk = this.remaining;\n\t\t\t          this.remaining = '';\n\t\t\t          this.saxParser = this.saxParser.write(chunk);\n\t\t\t          return this.saxParser.close();\n\t\t\t        } else {\n\t\t\t          chunk = this.remaining.substr(0, this.options.chunkSize);\n\t\t\t          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);\n\t\t\t          this.saxParser = this.saxParser.write(chunk);\n\t\t\t          return setImmediate(this.processAsync);\n\t\t\t        }\n\t\t\t      } catch (error1) {\n\t\t\t        err = error1;\n\t\t\t        if (!this.saxParser.errThrown) {\n\t\t\t          this.saxParser.errThrown = true;\n\t\t\t          return this.emit(err);\n\t\t\t        }\n\t\t\t      }\n\t\t\t    };\n\n\t\t\t    Parser.prototype.assignOrPush = function(obj, key, newValue) {\n\t\t\t      if (!(key in obj)) {\n\t\t\t        if (!this.options.explicitArray) {\n\t\t\t          return defineProperty(obj, key, newValue);\n\t\t\t        } else {\n\t\t\t          return defineProperty(obj, key, [newValue]);\n\t\t\t        }\n\t\t\t      } else {\n\t\t\t        if (!(obj[key] instanceof Array)) {\n\t\t\t          defineProperty(obj, key, [obj[key]]);\n\t\t\t        }\n\t\t\t        return obj[key].push(newValue);\n\t\t\t      }\n\t\t\t    };\n\n\t\t\t    Parser.prototype.reset = function() {\n\t\t\t      var attrkey, charkey, ontext, stack;\n\t\t\t      this.removeAllListeners();\n\t\t\t      this.saxParser = sax.parser(this.options.strict, {\n\t\t\t        trim: false,\n\t\t\t        normalize: false,\n\t\t\t        xmlns: this.options.xmlns\n\t\t\t      });\n\t\t\t      this.saxParser.errThrown = false;\n\t\t\t      this.saxParser.onerror = (function(_this) {\n\t\t\t        return function(error) {\n\t\t\t          _this.saxParser.resume();\n\t\t\t          if (!_this.saxParser.errThrown) {\n\t\t\t            _this.saxParser.errThrown = true;\n\t\t\t            return _this.emit(\"error\", error);\n\t\t\t          }\n\t\t\t        };\n\t\t\t      })(this);\n\t\t\t      this.saxParser.onend = (function(_this) {\n\t\t\t        return function() {\n\t\t\t          if (!_this.saxParser.ended) {\n\t\t\t            _this.saxParser.ended = true;\n\t\t\t            return _this.emit(\"end\", _this.resultObject);\n\t\t\t          }\n\t\t\t        };\n\t\t\t      })(this);\n\t\t\t      this.saxParser.ended = false;\n\t\t\t      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;\n\t\t\t      this.resultObject = null;\n\t\t\t      stack = [];\n\t\t\t      attrkey = this.options.attrkey;\n\t\t\t      charkey = this.options.charkey;\n\t\t\t      this.saxParser.onopentag = (function(_this) {\n\t\t\t        return function(node) {\n\t\t\t          var key, newValue, obj, processedKey, ref;\n\t\t\t          obj = {};\n\t\t\t          obj[charkey] = \"\";\n\t\t\t          if (!_this.options.ignoreAttrs) {\n\t\t\t            ref = node.attributes;\n\t\t\t            for (key in ref) {\n\t\t\t              if (!hasProp.call(ref, key)) continue;\n\t\t\t              if (!(attrkey in obj) && !_this.options.mergeAttrs) {\n\t\t\t                obj[attrkey] = {};\n\t\t\t              }\n\t\t\t              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];\n\t\t\t              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;\n\t\t\t              if (_this.options.mergeAttrs) {\n\t\t\t                _this.assignOrPush(obj, processedKey, newValue);\n\t\t\t              } else {\n\t\t\t                defineProperty(obj[attrkey], processedKey, newValue);\n\t\t\t              }\n\t\t\t            }\n\t\t\t          }\n\t\t\t          obj[\"#name\"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;\n\t\t\t          if (_this.options.xmlns) {\n\t\t\t            obj[_this.options.xmlnskey] = {\n\t\t\t              uri: node.uri,\n\t\t\t              local: node.local\n\t\t\t            };\n\t\t\t          }\n\t\t\t          return stack.push(obj);\n\t\t\t        };\n\t\t\t      })(this);\n\t\t\t      this.saxParser.onclosetag = (function(_this) {\n\t\t\t        return function() {\n\t\t\t          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;\n\t\t\t          obj = stack.pop();\n\t\t\t          nodeName = obj[\"#name\"];\n\t\t\t          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {\n\t\t\t            delete obj[\"#name\"];\n\t\t\t          }\n\t\t\t          if (obj.cdata === true) {\n\t\t\t            cdata = obj.cdata;\n\t\t\t            delete obj.cdata;\n\t\t\t          }\n\t\t\t          s = stack[stack.length - 1];\n\t\t\t          if (obj[charkey].match(/^\\s*$/) && !cdata) {\n\t\t\t            emptyStr = obj[charkey];\n\t\t\t            delete obj[charkey];\n\t\t\t          } else {\n\t\t\t            if (_this.options.trim) {\n\t\t\t              obj[charkey] = obj[charkey].trim();\n\t\t\t            }\n\t\t\t            if (_this.options.normalize) {\n\t\t\t              obj[charkey] = obj[charkey].replace(/\\s{2,}/g, \" \").trim();\n\t\t\t            }\n\t\t\t            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];\n\t\t\t            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {\n\t\t\t              obj = obj[charkey];\n\t\t\t            }\n\t\t\t          }\n\t\t\t          if (isEmpty(obj)) {\n\t\t\t            if (typeof _this.options.emptyTag === 'function') {\n\t\t\t              obj = _this.options.emptyTag();\n\t\t\t            } else {\n\t\t\t              obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;\n\t\t\t            }\n\t\t\t          }\n\t\t\t          if (_this.options.validator != null) {\n\t\t\t            xpath = \"/\" + ((function() {\n\t\t\t              var i, len, results;\n\t\t\t              results = [];\n\t\t\t              for (i = 0, len = stack.length; i < len; i++) {\n\t\t\t                node = stack[i];\n\t\t\t                results.push(node[\"#name\"]);\n\t\t\t              }\n\t\t\t              return results;\n\t\t\t            })()).concat(nodeName).join(\"/\");\n\t\t\t            (function() {\n\t\t\t              var err;\n\t\t\t              try {\n\t\t\t                return obj = _this.options.validator(xpath, s && s[nodeName], obj);\n\t\t\t              } catch (error1) {\n\t\t\t                err = error1;\n\t\t\t                return _this.emit(\"error\", err);\n\t\t\t              }\n\t\t\t            })();\n\t\t\t          }\n\t\t\t          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {\n\t\t\t            if (!_this.options.preserveChildrenOrder) {\n\t\t\t              node = {};\n\t\t\t              if (_this.options.attrkey in obj) {\n\t\t\t                node[_this.options.attrkey] = obj[_this.options.attrkey];\n\t\t\t                delete obj[_this.options.attrkey];\n\t\t\t              }\n\t\t\t              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {\n\t\t\t                node[_this.options.charkey] = obj[_this.options.charkey];\n\t\t\t                delete obj[_this.options.charkey];\n\t\t\t              }\n\t\t\t              if (Object.getOwnPropertyNames(obj).length > 0) {\n\t\t\t                node[_this.options.childkey] = obj;\n\t\t\t              }\n\t\t\t              obj = node;\n\t\t\t            } else if (s) {\n\t\t\t              s[_this.options.childkey] = s[_this.options.childkey] || [];\n\t\t\t              objClone = {};\n\t\t\t              for (key in obj) {\n\t\t\t                if (!hasProp.call(obj, key)) continue;\n\t\t\t                defineProperty(objClone, key, obj[key]);\n\t\t\t              }\n\t\t\t              s[_this.options.childkey].push(objClone);\n\t\t\t              delete obj[\"#name\"];\n\t\t\t              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {\n\t\t\t                obj = obj[charkey];\n\t\t\t              }\n\t\t\t            }\n\t\t\t          }\n\t\t\t          if (stack.length > 0) {\n\t\t\t            return _this.assignOrPush(s, nodeName, obj);\n\t\t\t          } else {\n\t\t\t            if (_this.options.explicitRoot) {\n\t\t\t              old = obj;\n\t\t\t              obj = {};\n\t\t\t              defineProperty(obj, nodeName, old);\n\t\t\t            }\n\t\t\t            _this.resultObject = obj;\n\t\t\t            _this.saxParser.ended = true;\n\t\t\t            return _this.emit(\"end\", _this.resultObject);\n\t\t\t          }\n\t\t\t        };\n\t\t\t      })(this);\n\t\t\t      ontext = (function(_this) {\n\t\t\t        return function(text) {\n\t\t\t          var charChild, s;\n\t\t\t          s = stack[stack.length - 1];\n\t\t\t          if (s) {\n\t\t\t            s[charkey] += text;\n\t\t\t            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\\\n/g, '').trim() !== '')) {\n\t\t\t              s[_this.options.childkey] = s[_this.options.childkey] || [];\n\t\t\t              charChild = {\n\t\t\t                '#name': '__text__'\n\t\t\t              };\n\t\t\t              charChild[charkey] = text;\n\t\t\t              if (_this.options.normalize) {\n\t\t\t                charChild[charkey] = charChild[charkey].replace(/\\s{2,}/g, \" \").trim();\n\t\t\t              }\n\t\t\t              s[_this.options.childkey].push(charChild);\n\t\t\t            }\n\t\t\t            return s;\n\t\t\t          }\n\t\t\t        };\n\t\t\t      })(this);\n\t\t\t      this.saxParser.ontext = ontext;\n\t\t\t      return this.saxParser.oncdata = (function(_this) {\n\t\t\t        return function(text) {\n\t\t\t          var s;\n\t\t\t          s = ontext(text);\n\t\t\t          if (s) {\n\t\t\t            return s.cdata = true;\n\t\t\t          }\n\t\t\t        };\n\t\t\t      })();\n\t\t\t    };\n\n\t\t\t    Parser.prototype.parseString = function(str, cb) {\n\t\t\t      var err;\n\t\t\t      if ((cb != null) && typeof cb === \"function\") {\n\t\t\t        this.on(\"end\", function(result) {\n\t\t\t          this.reset();\n\t\t\t          return cb(null, result);\n\t\t\t        });\n\t\t\t        this.on(\"error\", function(err) {\n\t\t\t          this.reset();\n\t\t\t          return cb(err);\n\t\t\t        });\n\t\t\t      }\n\t\t\t      try {\n\t\t\t        str = str.toString();\n\t\t\t        if (str.trim() === '') {\n\t\t\t          this.emit(\"end\", null);\n\t\t\t          return true;\n\t\t\t        }\n\t\t\t        str = bom.stripBOM(str);\n\t\t\t        if (this.options.async) {\n\t\t\t          this.remaining = str;\n\t\t\t          setImmediate(this.processAsync);\n\t\t\t          return this.saxParser;\n\t\t\t        }\n\t\t\t        return this.saxParser.write(str).close();\n\t\t\t      } catch (error1) {\n\t\t\t        err = error1;\n\t\t\t        if (!(this.saxParser.errThrown || this.saxParser.ended)) {\n\t\t\t          this.emit('error', err);\n\t\t\t          return this.saxParser.errThrown = true;\n\t\t\t        } else if (this.saxParser.ended) {\n\t\t\t          throw err;\n\t\t\t        }\n\t\t\t      }\n\t\t\t    };\n\n\t\t\t    Parser.prototype.parseStringPromise = function(str) {\n\t\t\t      return new Promise((function(_this) {\n\t\t\t        return function(resolve, reject) {\n\t\t\t          return _this.parseString(str, function(err, value) {\n\t\t\t            if (err) {\n\t\t\t              return reject(err);\n\t\t\t            } else {\n\t\t\t              return resolve(value);\n\t\t\t            }\n\t\t\t          });\n\t\t\t        };\n\t\t\t      })(this));\n\t\t\t    };\n\n\t\t\t    return Parser;\n\n\t\t\t  })(events);\n\n\t\t\t  exports.parseString = function(str, a, b) {\n\t\t\t    var cb, options, parser;\n\t\t\t    if (b != null) {\n\t\t\t      if (typeof b === 'function') {\n\t\t\t        cb = b;\n\t\t\t      }\n\t\t\t      if (typeof a === 'object') {\n\t\t\t        options = a;\n\t\t\t      }\n\t\t\t    } else {\n\t\t\t      if (typeof a === 'function') {\n\t\t\t        cb = a;\n\t\t\t      }\n\t\t\t      options = {};\n\t\t\t    }\n\t\t\t    parser = new exports.Parser(options);\n\t\t\t    return parser.parseString(str, cb);\n\t\t\t  };\n\n\t\t\t  exports.parseStringPromise = function(str, a) {\n\t\t\t    var options, parser;\n\t\t\t    if (typeof a === 'object') {\n\t\t\t      options = a;\n\t\t\t    }\n\t\t\t    parser = new exports.Parser(options);\n\t\t\t    return parser.parseStringPromise(str);\n\t\t\t  };\n\n\t\t\t}).call(parser); \n\t\t} (parser));\n\t\treturn parser;\n\t}\n\n\tvar hasRequiredXml2js;\n\n\tfunction requireXml2js () {\n\t\tif (hasRequiredXml2js) return xml2js;\n\t\thasRequiredXml2js = 1;\n\t\t// Generated by CoffeeScript 1.12.7\n\t\t(function() {\n\t\t  var builder, defaults, parser, processors,\n\t\t    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t\t    hasProp = {}.hasOwnProperty;\n\n\t\t  defaults = requireDefaults();\n\n\t\t  builder = requireBuilder();\n\n\t\t  parser = requireParser();\n\n\t\t  processors = requireProcessors();\n\n\t\t  xml2js.defaults = defaults.defaults;\n\n\t\t  xml2js.processors = processors;\n\n\t\t  xml2js.ValidationError = (function(superClass) {\n\t\t    extend(ValidationError, superClass);\n\n\t\t    function ValidationError(message) {\n\t\t      this.message = message;\n\t\t    }\n\n\t\t    return ValidationError;\n\n\t\t  })(Error);\n\n\t\t  xml2js.Builder = builder.Builder;\n\n\t\t  xml2js.Parser = parser.Parser;\n\n\t\t  xml2js.parseString = parser.parseString;\n\n\t\t  xml2js.parseStringPromise = parser.parseStringPromise;\n\n\t\t}).call(xml2js);\n\t\treturn xml2js;\n\t}\n\n\tvar xml2jsExports = requireXml2js();\n\n\tconst REGEX_CONDITION =\r\n\t  /\\?\\((?:(\\w+)\\.)?(\\w+)(?:\\.(\\w+))?\\s*(==|<|>)\\s*[\"']?([^\"'\\s]+)[\"']?\\)/;\r\n\tconst REGEX_PROPS =\r\n\t  /\\$(?:(\\w+)\\.)?(\\w+)(?:\\.(\\w+))?\\s*=\\s*(\"[^\"]+\"|'[^']+'|\\b\\w+\\b|\\d+)/;\r\n\tconst REGEX_EMOTION = /\\{\\{.+?\\}\\}/g;\r\n\tconst REGEX_NAME = /@(\\w+):/;\r\n\r\n\t// TODO: Show errors in DOM instead of console\r\n\t// TODO: Detect if quests in conditions even exist\r\n\t// TODO: Add option to see and remove one (or all) accepted names\r\n\t// TODO: Check each passage has atleast one line without a condition\r\n\t// TODO: allow multiple conditions like: ?($quest.Dueling_Chefs_Part1_FindKitchenBlueprints.bench == false && quest.Dueling_Chefs_Part1_FindKitchenBlueprints.screws) Oh also\r\n\r\n\tconst parseLink = (text) => text.trim().replace(/^!*\\[\\[|\\]\\]!*$/g, \"\");\r\n\r\n\tconst parseQuestData = (lines) => {\r\n\t  const questOpeningIndex = lines.findIndex((line) => line.includes(\"<quest>\"));\r\n\t  if (questOpeningIndex < 0) return;\r\n\t  const questClosingIndex = lines.findIndex((line) =>\r\n\t    line.includes(\"</quest>\")\r\n\t  );\r\n\t  if (!questClosingIndex < 0)\r\n\t    return alert(\"You have an opening but no closing quest tag\");\r\n\r\n\t  const questLines = lines.slice(questOpeningIndex, questClosingIndex + 1);\r\n\t  const questHTML = questLines.join(\"\\n\");\r\n\r\n\t  lines.splice(questOpeningIndex, questClosingIndex - questOpeningIndex + 1);\r\n\r\n\t  return parseXml(questHTML);\r\n\t};\r\n\r\n\tconst parseXml = async (xmlString) => {\r\n\t  const parser = new xml2jsExports.Parser();\r\n\t  const { quest } = await parser.parseStringPromise(xmlString);\r\n\r\n\t  const safeGet = (param) => {\r\n\t    if (!quest[param]?.[0])\r\n\t      throw new Error(\"Missing important quest parameter: \" + param);\r\n\t    return quest[param][0];\r\n\t  };\r\n\r\n\t  const objectives = safeGet(\"objectives\");\r\n\t  const rewards = safeGet(\"rewards\");\r\n\r\n\t  const toReturn = {\r\n\t    title: safeGet(\"title\"),\r\n\t    description: safeGet(\"description\"),\r\n\t    turnInNPC: safeGet(\"turn-in-npc\"),\r\n\t    links: {\r\n\t      onReturn: parseLink(safeGet(\"link-on-return\")),\r\n\t      onComplete: parseLink(safeGet(\"link-on-complete\")),\r\n\t    },\r\n\r\n\t    objectives: objectives.objective.reduce((acc, obj) => {\r\n\t      const objective = {\r\n\t        text: obj._,\r\n\t        type: obj.$.type,\r\n\t      };\r\n\t      if (objective.type === \"progress\") {\r\n\t        const goal = parseInt(obj.$.goal);\r\n\t        if (!goal || goal <= 0) {\r\n\t          throw new Error(\"Missing goal of objective: \" + obj.$.id);\r\n\t        }\r\n\t        objective.goal = goal;\r\n\t      }\r\n\t      acc[obj.$.id] = objective;\r\n\t      return acc;\r\n\t    }, {}),\r\n\t    rewards: {},\r\n\t  };\r\n\r\n\t  if (rewards.item) {\r\n\t    toReturn.rewards.items = rewards.item.reduce((acc, item) => {\r\n\t      acc[item.$.id] = parseInt(item.$.amount ?? 1);\r\n\t      return acc;\r\n\t    }, {});\r\n\t  }\r\n\r\n\t  if (rewards.prop) {\r\n\t    toReturn.rewards.props = rewards.prop.reduce((acc, prop) => {\r\n\t      acc[prop.$.id] = parseInt(prop.$.amount ?? 1);\r\n\t      return acc;\r\n\t    }, {});\r\n\t  }\r\n\r\n\t  let objectivesArr = Object.values(toReturn.objectives);\r\n\t  if (objectivesArr.length == 0) {\r\n\t    throw new Error(\"Need atleast one objective\");\r\n\t  }\r\n\t  if (objectivesArr.find((obj) => ![\"progress\", \"check\"].includes(obj.type))) {\r\n\t    throw new Error(\"Objective has to be either progress type or check type\");\r\n\t  }\r\n\r\n\t  return toReturn;\r\n\t};\r\n\r\n\tconst decodeHtmlEntities = (text) => {\r\n\t  return text.replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\r\n\t};\r\n\r\n\tconst formatLuaObject = (value, indent = 0) => {\r\n\t  const indentString = \"  \".repeat(indent);\r\n\r\n\t  if (Array.isArray(value)) {\r\n\t    const elements = value.map((item) => formatLuaObject(item, indent + 1));\r\n\t    return `{\\n${indentString}  ${elements.join(\r\n      `,\\n${indentString}  `\r\n    )}\\n${indentString}}`;\r\n\t  }\r\n\r\n\t  if (typeof value === \"object\" && value !== null) {\r\n\t    const entries = Object.entries(value).map(\r\n\t      ([key, val]) =>\r\n\t        `${indentString}  ${key} = ${formatLuaObject(val, indent + 1)}`\r\n\t    );\r\n\t    return `{\\n${entries.join(\",\\n\")}\\n${indentString}}`;\r\n\t  }\r\n\r\n\t  if (typeof value === \"string\") {\r\n\t    return JSON.stringify(value); // Properly format strings with quotes\r\n\t  }\r\n\r\n\t  return value.toString(); // For numbers and booleans\r\n\t};\r\n\r\n\tconst convertToLuaScript = (data) => {\r\n\t  const formattedLua = formatLuaObject(data);\r\n\t  return `return ${formattedLua}`;\r\n\t};\r\n\r\n\tconst getCondition = (text) => {\r\n\t  const match = text.match(REGEX_CONDITION);\r\n\t  if (!match) return;\r\n\t  let [_, type, field, subField, comparator, value] = match;\r\n\r\n\t  switch (comparator) {\r\n\t    case \"==\":\r\n\t      comparator = \"eq\";\r\n\t      break;\r\n\t    case \">\":\r\n\t      comparator = \"gt\";\r\n\t      // value = parseFloat(value);\r\n\t      break;\r\n\t    case \"<\":\r\n\t      comparator = \"lt\";\r\n\t      // value = parseFloat(value);\r\n\t      break;\r\n\t  }\r\n\t  try {\r\n\t    value = JSON.parse(value);\r\n\t  } catch (error) {}\r\n\t  return {\r\n\t    field,\r\n\t    subField,\r\n\t    type: type ?? \"checks\",\r\n\t    comparator,\r\n\t    value,\r\n\t  };\r\n\t};\r\n\r\n\tconst parseResponse = ({ unparsedText, emotion }) => {\r\n\t  const safeLink = parseLink(unparsedText);\r\n\t  const splitLink = safeLink.split(\"|\");\r\n\t  const toReturn = {};\r\n\t  if (splitLink.length == 1) toReturn.link = splitLink[0];\r\n\r\n\t  const condition = getCondition(splitLink[0]);\r\n\t  if (condition) toReturn.condition = condition;\r\n\r\n\t  if (splitLink.length == 2) {\r\n\t    toReturn.link = splitLink[1];\r\n\t    if (!condition) {\r\n\t      toReturn.text = splitLink[0];\r\n\t    }\r\n\t  } else if (splitLink.length == 3) {\r\n\t    toReturn.link = splitLink[2];\r\n\t    toReturn.text = splitLink[1];\r\n\t  }\r\n\r\n\t  if (toReturn.text?.startsWith(\"---\")) {\r\n\t    toReturn.isEnd = true;\r\n\t    toReturn.text = toReturn.text.replace(/^---/, \"\");\r\n\t    if (!toReturn.text) delete toReturn.text;\r\n\t  }\r\n\t  if (unparsedText.startsWith(\"!\") && unparsedText.endsWith(\"!\")) {\r\n\t    toReturn.isUrgent = true;\r\n\t  }\r\n\t  if (emotion) toReturn.emotion = emotion;\r\n\r\n\t  return toReturn;\r\n\t};\r\n\r\n\tconst extractResponsesFromText = (texts) => {\r\n\t  const responses = [];\r\n\r\n\t  for (let i = texts.length - 1; i >= 0; i--) {\r\n\t    const currentString = texts[i];\r\n\t    const responseMatches = currentString.match(/!*\\[\\[.+?\\]\\]!*/g);\r\n\t    const emotionMatches = currentString.match(REGEX_EMOTION);\r\n\r\n\t    if (responseMatches) {\r\n\t      const newResponse = { unparsedText: responseMatches[0] };\r\n\t      if (emotionMatches) {\r\n\t        newResponse.emotion = emotionMatches[0].replace(/^\\{\\{|\\}\\}$/g, \"\");\r\n\t      }\r\n\t      responses.unshift(newResponse);\r\n\t      texts.splice(i, 1);\r\n\t    }\r\n\t  }\r\n\r\n\t  if (responses.length == 0) return;\r\n\r\n\t  return responses\r\n\t    .map(parseResponse)\r\n\t    .sort((response) => (response.isUrgent ? 1 : 0));\r\n\t};\r\n\r\n\tconst extractPropsFromText = (texts) => {\r\n\t  const props = [];\r\n\r\n\t  for (let i = texts.length - 1; i >= 0; i--) {\r\n\t    const currentString = texts[i];\r\n\t    const match = currentString.match(REGEX_PROPS);\r\n\r\n\t    if (match) {\r\n\t      const [_, type, field, subField, value] = match;\r\n\t      const prop = { field, type: type ?? \"checks\" };\r\n\t      try {\r\n\t        prop.value = JSON.parse(value);\r\n\t      } catch (error) {\r\n\t        prop.value = value;\r\n\t      }\r\n\r\n\t      props.push(prop);\r\n\t      texts.splice(i, 1);\r\n\t    }\r\n\t  }\r\n\r\n\t  return Object.keys(props).length > 0 ? props : null;\r\n\t};\r\n\r\n\tconst cleanLinesArray = (texts) => {\r\n\t  return texts\r\n\t    .map((text) => decodeHtmlEntities(text).trim())\r\n\t    .filter((text) => !!text);\r\n\t};\r\n\r\n\tconst parseLine = (line) => {\r\n\t  const toReturnLine = {\r\n\t    text: line\r\n\t      .replace(REGEX_CONDITION, \"\")\r\n\t      .replace(REGEX_EMOTION, \"\")\r\n\t      .replace(REGEX_NAME, \"\")\r\n\t      .trim(),\r\n\t  };\r\n\t  const condition = getCondition(line);\r\n\t  const emotion = line.match(REGEX_EMOTION);\r\n\t  const nameMatch = line.match(REGEX_NAME);\r\n\r\n\t  if (condition) toReturnLine.condition = condition;\r\n\t  if (emotion) toReturnLine.emotion = emotion[0].replace(/^\\{\\{|\\}\\}$/g, \"\");\r\n\t  if (nameMatch) toReturnLine.name = nameMatch[1];\r\n\r\n\t  return toReturnLine;\r\n\t};\r\n\r\n\tconst convertPassage = async (passage) => {\r\n\t  const lines = cleanLinesArray(passage.innerHTML.split(\"\\n\"));\r\n\t  const dict = {};\r\n\r\n\t  const quest = await parseQuestData(lines);\r\n\t  if (quest) dict.quest = quest;\r\n\r\n\t  const responses = extractResponsesFromText(lines);\r\n\t  if (responses) {\r\n\t    dict.responses = responses.filter((response) => !!response.text);\r\n\t    dict.redirects = responses.filter((response) => !response.text);\r\n\t    if (!dict.responses.length) delete dict.responses;\r\n\t    if (!dict.redirects.length) delete dict.redirects;\r\n\t  }\r\n\r\n\t  const props = extractPropsFromText(lines);\r\n\t  if (props) dict.props = props;\r\n\r\n\t  [\"name\", \"pid\"].forEach((attr) => {\r\n\t    const value = passage.attributes[attr].value;\r\n\t    if (value) dict[attr] = value;\r\n\t  });\r\n\r\n\t  if (dict.tags) dict.tags = dict.tags.split(\" \");\r\n\t  dict.lines = cleanLinesArray(lines).map(parseLine);\r\n\r\n\t  return dict;\r\n\t};\r\n\r\n\tconst convertStory = async (story) => {\r\n\t  const passages = story.getElementsByTagName(\"tw-passagedata\");\r\n\t  const convertedPassages = await Promise.all(\r\n\t    Array.prototype.slice.call(passages).map(convertPassage)\r\n\t  );\r\n\r\n\t  const dict = {\r\n\t    passages: {},\r\n\t    name: story.attributes.name.value,\r\n\t    start_node_name: convertedPassages.find(\r\n\t      (passage) => passage.pid == story.attributes.startnode.value\r\n\t    ).name,\r\n\t  };\r\n\r\n\t  convertedPassages.forEach((row) => {\r\n\t    dict.passages[row.name] = { ...row, name: undefined, pid: undefined };\r\n\t  });\r\n\r\n\t  return JSON.parse(JSON.stringify(dict));\r\n\t};\r\n\r\n\tconst parseTwineToLua = async () => {\r\n\t  const storyData = document.getElementsByTagName(\"tw-storydata\")[0];\r\n\t  const response = convertToLuaScript(await convertStory(storyData));\r\n\t  document.getElementById(\"output\").innerHTML = response;\r\n\t};\r\n\r\n\twindow.parseTwineToLua = parseTwineToLua;\n\n})();\n\r\n  </script>\r\n  <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\r\n  <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\r\n  <link href=\"https://fonts.googleapis.com/css2?family=Parkinsans:wght@300..800&display=swap\" rel=\"stylesheet\">\r\n  <style>\r\n    body,\r\n    html {\r\n      background-color: #365486;\r\n    }\r\n\r\n    * {\r\n      font-family: \"Parkinsans\", sans-serif;\r\n      color: #7FC7D9;\r\n      box-sizing: border-box;\r\n      margin: 0;\r\n      padding: 0;\r\n    }\r\n\r\n    main {\r\n      display: flex;\r\n      justify-content: center;\r\n      align-items: center;\r\n      margin: auto;\r\n      gap: 4em;\r\n      height: 100%;\r\n      max-width: 1000px;\r\n    }\r\n\r\n    .halfOfScreen {\r\n      flex: 1;\r\n      gap: 1em;\r\n      display: flex;\r\n      flex-direction: column;\r\n      justify-content: center;\r\n      align-items: center;\r\n    }\r\n\r\n    .outputWrapper {\r\n      flex: 2;\r\n    }\r\n\r\n    #storyData {\r\n      display: none;\r\n    }\r\n\r\n    #output {\r\n      overflow-y: auto;\r\n      text-wrap: wrap;\r\n      padding: 1em;\r\n      background-color: #00000040;\r\n      border-radius: 10px;\r\n      width: 100%;\r\n      color: #7fc7d98f;\r\n      font-size: 0.5em;\r\n      max-height: 75vh;\r\n    }\r\n\r\n    #unrecognizedNames {\r\n      margin-top: 1em;\r\n      padding: 1em 2em;\r\n      border-radius: 10px;\r\n      color: white;\r\n      width: 100%;\r\n      background-color: #00000040;\r\n    }\r\n\r\n    #unrecognizedNames button {\r\n      display: absolute;\r\n      position: absolute;\r\n      width: 32px;\r\n      height: 32px;\r\n      border-radius: 32px;\r\n      top: 50%;\r\n      left: -10px;\r\n      transform: translate(-100%, -50%);\r\n\r\n      font-size: 1.5em;\r\n      line-height: 32.5px;\r\n    }\r\n\r\n    ul {\r\n      list-style: none;\r\n    }\r\n\r\n    li {\r\n      position: relative;\r\n      padding: 1em 0;\r\n    }\r\n\r\n    button {\r\n      width: 180px;\r\n      height: 40px;\r\n      border-radius: 10px;\r\n      font-size: 1em;\r\n      background-color: #7FC7D9;\r\n      color: white;\r\n      border: #DCF2F1 1px solid;\r\n      transition: 0.2s;\r\n      cursor: pointer;\r\n    }\r\n\r\n    button:hover {\r\n      opacity: 0.5;\r\n    }\r\n\r\n    button:active {\r\n      opacity: 0.2;\r\n    }\r\n\r\n    button:disabled {\r\n      opacity: 1;\r\n    }\r\n  </style>\r\n</head>\r\n\r\n<body>\r\n  <main>\r\n    <div class=\"halfOfScreen outputWrapper\">\r\n      <pre id=\"output\"></pre>\r\n      <button onclick=\"copyText()\">Copy output</button>\r\n    </div>\r\n    <div class=\"halfOfScreen\">\r\n      <h3>Unrecognized Names:</h3>\r\n      <ul id=\"unrecognizedNames\">\r\n      </ul>\r\n    </div>\r\n  </main>\r\n\r\n  <div id=\"storyData\">\r\n    {{STORY_DATA}}\r\n  </div>\r\n\r\n  <script>\r\n    const recognizedNames = JSON.parse(localStorage.getItem(\"recognizedNames\") || \"[]\");\r\n    const nameRegex = /@(\\w+)/g;\r\n    const turnInNPCRegex = /\\b(turnInNPC|name)\\b\\s*=\\s*\"(\\w+)\"/g;\r\n\r\n    function displayUnrecognizedNames(names) {\r\n      const unrecognizedDiv = document.getElementById(\"unrecognizedNames\");\r\n      unrecognizedDiv.innerHTML = \"\";\r\n\r\n      names.forEach(name => {\r\n        const nameDiv = document.createElement(\"li\");\r\n        nameDiv.textContent = name;\r\n\r\n        const addButton = document.createElement(\"button\");\r\n        addButton.textContent = \"+\";\r\n        addButton.onclick = () => addToRecognizedNames(name);\r\n\r\n        nameDiv.appendChild(addButton);\r\n        unrecognizedDiv.appendChild(nameDiv);\r\n      });\r\n    }\r\n\r\n    function addToRecognizedNames(name) {\r\n      recognizedNames.push(name);\r\n      localStorage.setItem(\"recognizedNames\", JSON.stringify(recognizedNames));\r\n      findUnrecognizedNames();\r\n    }\r\n\r\n    function findUnrecognizedNames() {\r\n      const text = document.getElementById(\"output\").innerText\r\n      const unrecognized = {};\r\n      [...text.matchAll(nameRegex)].forEach(match => {\r\n        if (!recognizedNames.includes(match[1])) {\r\n          unrecognized[match[1]] = true;\r\n        }\r\n      });\r\n      [...text.matchAll(turnInNPCRegex)].forEach(match => {\r\n        if (!recognizedNames.includes(match[2])) {\r\n          unrecognized[match[2]] = true;\r\n        }\r\n      });\r\n\r\n      displayUnrecognizedNames(Object.keys(unrecognized));\r\n    }\r\n\r\n    function copyText() {\r\n      const textToCopy = document.getElementById(\"output\").innerText;\r\n      const textarea = document.createElement(\"textarea\");\r\n      textarea.value = textToCopy;\r\n\r\n      document.body.appendChild(textarea);\r\n      textarea.select();\r\n      document.execCommand('copy');\r\n      document.body.removeChild(textarea);\r\n\r\n      const button = document.querySelector('button');\r\n      button.textContent = 'Copied to clipboard';\r\n      button.disabled = true\r\n\r\n      setTimeout(() => {\r\n        button.textContent = 'Copy output';\r\n        button.disabled = false\r\n      }, 1500);\r\n    }\r\n\r\n    async function start() {\r\n      await parseTwineToLua();\r\n      findUnrecognizedNames();\r\n    }\r\n\r\n    start()\r\n  </script>\r\n</body>\r\n\r\n</html>"
});